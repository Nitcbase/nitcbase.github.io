<!DOCTYPE HTML>
<html>

<head>
    <title>Cache</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">
</head>
    
    
<body>
    <div class="header" id="top">
        <div id="title">
            <h1> <a href="index.html">Nitcbase</a></h1>
            <!--h3> Database Management System</h3-->
        </div>
        
        <div id="menubar">
            <ul id="menu">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="documentation.html"> Documentation</a></li>
                <li> <a href="roadmap.html">Roadmap</a></li>
            </ul>
        </div>
    </div>
    
    <div id="content">
        <div class="sidemenu">
            <ul>
                <li> <a href="#layout">Layout</a></li>
                <li> <a href="#relcache">Relation Cache</a></li>
                <li> <a href="#attrcache">Attribute Cache</a></li>
                <li> <a href="#openreltable">Open Relation Table</a></li>
                <li> <a href="#"></a></li>
            </ul>
        </div>
        
        <div id="main-content">
            <div class="pagetitle"><h1>Cache Layer</h1></div>
            
            <div id="layout" class="detail">
                <h2> Layout</h2>
                <p>The job of this module is to cache the catalogs information of 'opened' relations in memory and store any other memory meta data, thereby providing immediate access to this information whenever required by any other layer. Since catalog information is frequently required by any query processing modules, this layer of caching reduces the number of disk access made for those catalogs. Also this provides clean interface to these catalogs and hence hiding how the catalogs are stored and maintained internally. the following diagram summarizes the design of this module with public interfaces provided.</p>
                <center><img src="img/cache_class.png"></center>
            </div>
            
            <div id="relcache" class="detail">
                <h2> Relation Cache</h2>
                <p>Relation catalog stores metadata coresponding to all relations in the system. In addition to storing this information in the disk, a set of relation catalog entries of open relations are cached in the main memory for easy access to this information and to achieve a good performance. This is called Relation Cache. A maximum of MAXOPEN = 12 relations are cached at the same time. Relation Cache contains all the fields from relation catalog and type of each entry is defined as 'struct RelCatEntry' as shown below:</p>
                <div class="code">
    typedef struct RelCatEntry {
        char rel_name[ATTR_SIZE];
        int num_attr;
        int num_rec;
        int first_blk;          //Head of linked list of blocks
        int num_slots_blk;      //Number of slots in a block
    } RelCatEntry ;</div>
                In addition to these fields, few more information is stored in <a href="#openreltable">open relation table</a>.
            </div>
            
            <div id="attrcache" class="detail">
                <h2> Attribute Cache</h2> 
                <p>Attribute catalog, analogous to relation catalog stores meta information for every attribute in every relation of the system. In addition to storing this catalog in disk, attribute catalog information for a set of open relations is also cached in the main memory for easy access and also for performance reasons. This is called Attribute Cache. Attribute cache will be stored for every open relation (every relation whose relation catalog entry cached also has its attribute catalog entries cached). Hence we can cache attribute catalog information for atmost MAXOPEN=12 relations.Each Attribute Cache entry contains all the fields from attribute catalog and some extra fields as explained below. Type of memory cached attribute catalog entry is defined as 'AttrCatEntry' and that of Attribute Cache entry is defined as 'AttributeCache'. Since a relation can have an arbitrary number of attributes (though it is bounded in Nitcbase), Attribute cache is stored in memory as a linked list of Attribute Cache entries.</p>
                <div class="code">
    typedef struct AttrCatEntry {
        char rel_name[ATTR_SIZE];
        char attr_name[ATTR_SIZE];
        int attr_type;
        bool primary_flag;
        int root_block;
        int offset;
    } AttrCatEntry ;

    typedef struct AttributeCache {
        AttrCatEntry attrcat_entry;
        bool dirty;
        recId rec_id;
        SearchIndexId sid;          /*IMPORTANT: used for storing state information of any search.
                                                which will be used for getting next hit. */
        struct AttributeCache *next;
    } AttributeCache;
                </div>
                <p>As already stated, Attribute cache also stores some inmemory information which will not be committed back to disk. They are:</p>
                <ol>
                    <li>dirty: Indicates whether the attribute catalog entry is modified</li>
                    <li>rec_id: Stores the record id (block#, slot#) of the attribute catalog entry in the disk. This is useful to commit the catalog entry to disk when it is modified.</li>
                    <li>sid: This is used to store state of any search operation. It essentially stores information regardng last/previous hit. Search interfaces uses this information to know where previous search call returned and to quickly search for the next hit.</li>
                </ol>
            </div>

            <div id="openreltable" class="detail">
                <h2>Open Relation Table</h2>
                <p>Cache layer stores the catalog cache in a tablular structure called Open Relation Table. An open relation table consists of a total of MAXOPEN=12 rows. Each row corresponds to an open relation. The index to the open relation table is considered as the relation identifier (relId). Any layer that wishes to access the meta information of a open relation need to access it using its relId. Each row in the Open Relation Table has the following fields:</p>
                <ol>
                    <li>relcat_entry: cached relation catalog entry of the relation</li>
                    <li>free: Indicates whether the row is free or occupied.</li>
                    <li>dirty: Indicates whether relation catalog entry is modified.</li>
                    <li>rec_id: Stores the record id (block#, slot#) of the relation catalog entry in the disk. This is useful to commit the catalog entry to disk when it is modified.</li>
                    <li>attr_list: Head of the linked list storing attribute catalog cache whose length is equal to number of attributes in the relation.</li>
                </ol>
                <center><img src="img/openreltable.png" style="width: 80%"></center>
                <p>The above figure shows the structure of Open relation table. Both the catalogs are stored as relations internally and have entries corresponding to themselves. Name of relation catalog is "relcat" and that of attribute catalog is "attrcat". These catalogs will always be open with predefined relation ids as 0 and 1 respectively. In other words, first row of the open relation table corresponds to Relation Catalog and second row corresponds to Attribute Catalog.</p>
                <p>Open Relation Table is a static class (<b>Note:</b> In C++ static classes can be implemented by declaring each field and member function as static explicitly) which means there exists only a single static object of the class at any point of time. The actual table(data) is private to the class and access to the information is provided through public methods which define interface to the cache layer. Since all interfaces are static, they can be called on the class name instead of calling on an object (object is allocated statically). Class structure showing public interfaces can be found in the following code:</p>
                <div class="gist">
                    <script src="https://gist.github.com/rohithv/bfd38d0c6757a5058cb70e709ff0c0ac.js"></script>
                </div>
                <p>The interfaces given by cache layer to other layers are:</p>
                <ol>
                    <li>relId OpenRel(char rel_name[16]): In order to work with any relation, above layers should open the relation in to memory before 
                        they access the relation(as like opening a file before working on it). This method loads the metadata of specified relation 
                        into one of the free entry in OpenReltable. using this interface above layers can Open the specified relation.
                        <br>
                        this method checks for a free entry in openreltable, if there is no free entry(among 8 relcache entries), returns FALILURE. else,  
                        goes through all the relations that are present in the relation catalog of disk, if specefied relation is not found in Relation catalog, 
                        returns FAILURE. else , updates the relcat_entry of free relcache entry in openreltable with the fields of specified relation 
                        in relation catalog, Nitcbase stores metadata about attributes of opened relation, in Linked list of AttributeCache, where each entry in 
                        Linked list stores metadata about one of the attributes of corresponding relation and stores head of linked list in relcache entry of free relcache 
                        entry found. by going through all the blocks of attribute catalog in disk, whenever we find a entry corresponding to specified relation, update the 
                        Linked list by adding a new node(attributecache_entry) with the fields: attrcat_entry:fields of found attribute catalog entry, dirty:false, recid: 
                        recid of found attribute catalog entry, sid: (sblock=-1,sindex=-1). update the rest of fields in free openreltable_entry to free: false, dirty: false
                        <br>
                        after updating all the fields in free relcache entry found, returns the relid(index of relcache among 8 entries in openreltable).
                        <br>
                        NOTE: The layers above bufffer uses interfaces of buffer layer in order to access the disk blocks(here relation catalog, attribute 
                        catalog blocks in disk).
                    </li>
                    <br>
                    <li>
                        int CloseRel(relId rel_id): This method closes the opened Relation correspoding to rel_id'th RelCache entry in openreltable, 
                        <br>
                        In this method, if rel_id is not between 0 and 7, or rel_id'th relcache entry is found to be free, return FAILURE. else, if a RelCache 
                        entry of target relation has the field dirty:true, then the correspoding relation catalog entry 
                        should be updated before closing it, recid(#block,#slot) of target relation's relation catalog entry can be found in correspoding 
                        RelCache, using the interfaces of buffer, relation catalog entry's record can be updated with the one as Relcat_entry in 
                        openreltable. traverse the AttributeCache linked list corresponding to target RelCache entry. if any of the AttributeCache entry is 
                        found to have dirty:true, update the corresponding attribute catalog entry(whose recid is stored in AttributeCache node) with 
                        as that of attrcat_entry in AttributeCache. return SUCCESS.
                    </li>
                    <br>
                    <li>
                            int setRelCatEntry(relId rel_id, RelCatEntry relcat_rec): if rel_id is not between 0 and 7 returns FAILURE. else updates the 
                            Relcat_entry of rel_id'th relcache entry with relcat_rec(passed as argument) and updates the corresponding dirty field with true.
                    </li>
                    <br>
                    <li>
                        relId getRelId(char rel_name[16]): Iterate through all the RelCache entries of openreltable, if Relcache entry correspoding to 
                        rel_name(passed as argument) is found, returns the respective entry's index among the 8 entries of openreltable. if rel_name 
                        doesn't correspond to any of the entry in openreltable, returns FAILURE.
                    </li>
                    <br>
                    
                </ol>
            </div>
            
        </div>
    </div>
</body>

</html>
<!DOCTYPE HTML>
<html>

<head>
    <title>Cache Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-sm-2">
                    <nav class="navbar navbar-expand-sm sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            <li> <a href="#layout">Layout</a></li>
                            <li> <a href="#relation_cache">Relation Cache</a></li>
                            <li> <a href="#attribute_cache">Attribute Cache</a></li>
                            <li> <a href="#openrel_table">Open Relation Table</a></li>
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-sm-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>Cache Layer</h1>
                        </div>
                        
                         <div id="layout" class="detail">
                            <h2>Layout</h2>
                            <p> The job of this module is to cache the catalog information of 'opened' relations in memory. Some meta data related to open relations is also managed by the cache layer. thereby providing immediate access to this information whenever required by any other layer. Since catalog information is frequently required by any query processing module, this layer of caching reduces the number of disk accesses for those catalogs. The cache layer provides a clean interface to for catalog access, hiding from the higher layers how the catalogs are stored and maintained internally. The following diagram summarizes the design of this module with public interfaces provided. </p>
                            <center><img class="img-fluid" src="img/cache_class.png"></center>
                        </div>
                        
                        <div id="relation_cache" class="detail">
                        <h2>Relation Cache</h2>
                        <p>Relation catalog stores metadata coresponding to all relations in the system. In addition to storing this information in the disk, a set of relation catalog entries of open relations are cached in the main memory for easy access to this information and to achieve a good performance. This is called Relation Cache. A maximum of MAXOPEN = 12 relations are cached at the same time. Relation Cache contains all entries of the correspondig relation catalog entry.  Each cache entry is stored as a 'RelCatEntry' structure as shown below:</p>
                		<div class="code"><pre><code>typedef struct RelCatEntry {
    char rel_name[ATTR_SIZE];
    int num_attr;
    int num_rec;
    int first_blk;          //Head of linked list of blocks
    int num_slots_blk;      //Number of slots in a block
} RelCatEntry ;</code></pre></div>
                		<p>In addition to the cached copy of relation catalog entry, Nitcbase maintains some meta-data for each open relation in an <a href="#openrel_table">open relation table</a>. Relation cache entry for an open relation is part of open relation table entry for the relation.</p>
                        </div>
                        
                        <div id="attribute_cache" class="detail">
                            <h2>Attribute Cache</h2>
                            <p>The Attribute catalog, analogous to the relation catalog stores meta information for every attribute in every relation of the system. In addition to storing this catalog in the disk, the attribute catalog information for a set of open relations is also cached in the main memory for performance reasons and  easy access. The attribute catalog cache for opened relations is called the Attribute Cache. An Attribute cache entry will be created for every open relation. (Each relation whose relation catalog entry is cached in the relation cache will also have its attribute catalog entries cached in the attribute cache.) Hence the attribute catalog information for atmost MAXOPEN=12 relations are cached. Each Attribute Cache entry contains all the fields from attribute catalog and some extra fields for storing meta-data as explained below. Type of memory cached attribute catalog entry is defined as 'AttrCatEntry' and that of Attribute Cache entry is defined as 'AttributeCache'. Since a relation can have a variable number of attributes (though the maximum number of attributes for a relation is bounded in Nitcbase by 125 - why?), Attribute cache is stored in memory as a linked list of Attribute Cache entries.</p>
                            
                            <div class="code"><pre><code>     typedef struct AttrCatEntry {
        char rel_name[ATTR_SIZE];
        char attr_name[ATTR_SIZE];
        int attr_type;
        bool primary_flag;
        int root_block;
        int offset;
    } AttrCatEntry ;

    typedef struct AttributeCache {
        AttrCatEntry attrcat_entry;
        bool dirty;
        recId rec_id;
        SearchIndexId sid;          /*IMPORTANT: used for storing state information of any search.
                                                which will be used for getting next hit. */
        struct AttributeCache *next;
    } AttributeCache;</code></pre></div>
                          	<p>As already stated, Attribute cache also stores some in memory information which will not be committed back to disk. They are:</p>
                           	<ol>
                           		<li><i>dirty</i>: Indicates whether the attribute catalog entry is modified.</li>
                    			<li><i>recid</i>: Stores the record id (block#, slot#) of the attribute catalog entry in the disk. This is useful to commit the catalog entry to disk when it is modified.</li>
                    			<li><i>prev_recid</i>: This is used to store state of any search operation. It essentially stores information regardng last/previous hit. Search interfaces uses this information to know where previous search call returned and to quickly search for the next hit.</li>
                    		</ol> 
                        </div>
                        
                        <div id = "openrel_table" class="detail">
                        	<h2>Open Relation Table</h2>
                        	<p>Cache layer stores the catalog cache in a tablular structure called Open Relation Table. Open relation table consists of a total of MAXOPEN=12 entries. Each entry corresponds to an open relation. The index to the entry in open relation table is considered as the relation identifier (relId). Any layer that wishes to access the meta information of an open relation need to access it using its relId. Each row in the Open Relation Table has the following fields:</p>
                        	<ol>
                        		<li>relcat_entry: cached relation catalog entry of the relation</li>
                    			<li>free: Indicates whether the row is free or occupied.</li>
                    			<li>dirty: Indicates whether relation catalog entry is modified.</li>
                    			<li>rec_id: Stores the record id (block#, slot#) of the relation catalog entry in the disk. This is useful to commit the catalog entry to disk when it is modified.</li>
                    			<li>attr_list: Head of the linked list storing attribute catalog cache whose length is equal to number of attributes in the relation.</li>
                			</ol>
                        	<center><img class="img-fluid" src="img/openreltable.png"></center>
                        	<p>The above figure shows the structure of Open relation table.</p>
                			<p>Relation catalog and the attribute catalog are the only two "default" relations in Nitcbase.  (The catalogs which store meta-information about other relations are themselves treated as relations by Nitcbase).  Hence both the relation catalog and the attribute catalog contain entries corresponding to themselves.  The relation catalog entry for the relation catalog has Relname set to the default name "relcat".   The relation catalog entry for the attribute catalog has Relname set to the default name "attrcat".  The attribute catalog will contain default entries corresponding each attribute of the relation catalog and each attribute of the attribute catalog.  The relation catalog and the attribute catalog are always open, with predefined relation ids as 0 and 1 respectively. Consequently, the first and the second entries of the open relation table corresponds to the Relation Catalog and the Attribute Catalog respectively.</p>
                			<p>Open Relation Table is a static class (<b>Note:</b> In C++ static classes can be implemented by declaring each field and member function as static explicitly). <b>This means that there exists only a single static object of the class at any point of time</b>. The actual table(data) is private to the class and access to the information is provided through public methods which define interface to the cache layer. Since all interfaces are static, they can be called on the class name instead of calling on an an instance (as the object is allocated statically).</p>
                        </div>
                        
                        <div class="pagetitle">
                            <h1>Methods of Cache Layer</h1>
                        </div>
                        
                        <div id="openrel" class="detail">
                            <h2>OpenRel</h2>
                        </div>
                        
                        <div id="closerel" class="detail">
                            <h2>CloseRel</h2>
                        </div>
                        
                        <div id="getrelid" class="detail">
                            <h2>getRelId</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relName</td>
                                    <td>char[ATTR_SIZE]</td>
                                    <td>Name of the Relation.</td>
                                </tr>
                            </table>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relId</td>
                                    <td>Returns the relId corresponding to the relation with name relName, if it is already open</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If the relation with name relName is not open</td>
                                </tr>
                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>relId OpenRelTable::getRelId(char relName[ATTR_SIZE]){
	//Iterate over the relation cache{
		//if relation with relation name relName is opened in the relation cache
			return relid //return corresponding relid
	//}
	return E_NOTOPEN;
}</code></pre></div> <!-- End of algo div -->
                            <a href="code/cache_getrelid.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="getrelcatentry" class="detail">
                            <h2>getRelCatEntry</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation.</td>
                                </tr>
                                <tr>
                                    <td>relcat_buf</td>
                                    <td>RelCatEntry *</td>
                                    <td>pointer to the buffer of type RelCatEntry into which the relation catalog entry is to be copied from the relation cache.</td>
                                </tr>
                            </table>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>On successful copy of the relation catalog entry corresponding to the relation with id relid</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::getRelCatEntry(relId relid, RelCatEntry *relcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relation catalog in the relation cache to the relcat_buf
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                            <a href="code/cache_getrelcatentry.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="setrelcatentry" class="detail">
                            <h2>setRelCatEntry</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation.</td>
                                </tr>
                                <tr>
                                    <td>relcat_buf</td>
                                    <td>RelCatEntry *</td>
                                    <td>pointer to the buffer of type RelCatEntry from which the relation catalog entry is to be copied into the relation cache.</td>
                                </tr>
                            </table>

                            <div class=retval>
                                <h4>Return value:</h4>
                                <table class="table table-bordered table-hover table-responsive">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>On successful copy of the relation catalog entry corresponding to the relation with id relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>

                                </table>
                            </div>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::setRelCatEntry(relId relid, RelCatEntry *relcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relcat_buf to the relation catalog in the relation cache
	//set the dirty flag corresponding to the relation with Id relid in the relation cache
	return SUCCESS;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_setrelcatentry.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="getprevrecid" class="detail">
                            <h2>getPrevRecId</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>recidbuff_ptr</td>
                                    <td>recId *</td>
                                    <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair). The record id field of the previous hit stored in the meta information of the relation cache is to be copied into recid_ptr.</td>
                                </tr>
                            </table>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>If record id of previous hit is copied to recid. It means that the id pointed by recid is valid.</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::getPrevRecId(relId relid, recId *recidbuff_ptr){
	if(relid&lt; 0 || relid&gt;= MAXOPEN){//check whether relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation in the relation cache to the recidbuff_ptr*/
	return SUCCESS;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_getprevrecid.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="setprevrecid" class="detail">
                            <h2>setPrevRecId</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>recidbuff_ptr</td>
                                    <td>recId *</td>
                                    <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair). The record id field of the previous hit is to be stored to the meta information of the relation cache from  recid_ptr.</td>
                                </tr>
                            </table>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>If the record id is successfully copied into the Relation Catalog Cache.</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::setPrevRecId(relId rel_id, recId *recidbuff_ptr){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation from the recidbuff_ptr to the relation cache*/
	return SUCCESS;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_setprevrecid.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="getattrcatentry" class="detail">
                            <h2>getAttrCatEntry</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>attrName/attr_offset</td>
                                    <td>char[ATTR_SIZE] / int</td>
                                    <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                </tr>
                                <tr>
                                    <td>attrcat_buf</td>
                                    <td>AttrCatEntry *</td>
                                    <td>pointer to the buffer of type AttrCatEntry where the attribute catalog entry is to be copied.</td>
                                </tr>
                            </table>
                            <b>Note:</b>This method is overloaded in type of the second argument</p>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>On successful copy of the attribute catalog entry corresponding to the relation with id relid and attribute with name attrName or having offset attr_offset</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>
                                <tr>
                                    <td>E_ATTRNOTEXIST</td>
                                    <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::getAttrCatEntry(relId relid, char attr_name[ATTR_SIZE/int attr_offset, AttrCatEntry *attrcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			//copy the attribute catalog in the attribute cache to the attrcat_buf
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_getattrcatentry.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="setattrcatentry" class="detail">
                            <h2>setAttrCatEntry</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>attrName/attr_offset</td>
                                    <td>char[ATTR_SIZE] / int</td>
                                    <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                </tr>
                                <tr>
                                    <td>attrcat_buf</td>
                                    <td>AttrCatEntry *</td>
                                    <td>pointer to the buffer of type AttrCatEntry from where the attribute catalog entry is to be copied to the Attribute catalog cache.</td>
                                </tr>
                            </table>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>

                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>On successful copy of the attribute catalog entry into the cache corresponding to the relation with id relid and attribute with name attrName or having offset attr_offset</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>
                                <tr>
                                    <td>E_ATTRNOTEXIST</td>
                                    <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::setAttrCatEntry(relId relid, char attr_name[ATTR_SIZE/int attr_offset, AttrCatEntry *attrcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			//copy the attrcat_buf to the corresponding attibute node in the attribute cache
			//set the dirty flag corresponding to the attribute in the attribute cache
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_setattrcatentry.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                         <div id="getprevindexid" class="detail">
                            <h2>getPrevIndexId</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>attrName/attr_offset</td>
                                    <td>char[ATTR_SIZE] / int</td>
                                    <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                </tr>
                                <tr>
                                    <td>indid</td>
                                    <td>IndexId *</td>
                                    <td>pointer to buffer of type IndexId where the index id is to be copied.</td>
                                </tr>
                            </table>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>
                                <h4>Return value:</h4>
                                <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If index id of previous hit is copied to indid. It means that the id pointed by indid is valid.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_ATTRNOTEXIST</td>
                                        <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                    </tr>

                                </table>
                             </div>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::getPrevIndexId(relId relid, char attr_name[ATTR_SIZE/int attr_offset, IndexId *indid){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			/*copy the previous index id (in meta informatiom) corresponding to 
			  the attribute in the attribute cache to the indid*/
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_getprevindexid.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>

                        <div id="setprevindexid" class="detail">
                            <h2>setPrevIndexId</h2>
                            <h4>Arguments:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>relid</td>
                                    <td>int</td>
                                    <td>Relation Id of the Relation</td>
                                </tr>
                                <tr>
                                    <td>attrName/attr_offset</td>
                                    <td>char[ATTR_SIZE] / int</td>
                                    <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                </tr>
                                <tr>
                                    <td>indid</td>
                                    <td>IndexId *</td>
                                    <td>pointer to buffer of type IndexId from where the index id is to be copied into the Attribute catalog cache.</td>
                                </tr>
                            </table>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>
                            <h4>Return value:</h4>
                            <table class="table table-bordered table-hover table-responsive">
                                <tr>
                                    <td>SUCCESS</td>
                                    <td>If index id pointed by indid is successfully copied to the Attribute catalog cache.</td>
                                </tr>
                                <tr>
                                    <td>E_OUTOFBOUND</td>
                                    <td>If the relid is out of the range 0-MAXOPEN</td>
                                </tr>
                                <tr>
                                    <td>E_NOTOPEN</td>
                                    <td>If there is no open relation exist corresponding to the id given by relid</td>
                                </tr>
                                <tr>
                                    <td>E_ATTRNOTEXIST</td>
                                    <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                </tr>

                            </table>

                            <h4>Description:</h4>
                            <p>Description of the function/method</p>

                            <h4>Algorithm:</h4>
                            <div class="code"><pre><code>int OpenRelTable::setPrevIndexId(relId relid, char attr_name[ATTR_SIZE/int attr_offset, IndexId *indid){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			/*copy the indid to the previous index id (in meta informatiom)
			  corresponding to the attribute in the attribute cache*/
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                            </div> <!-- End of algo div -->
                            <a href="code/cache_setprevindexid.cpp" target="_blank" download>Click here</a> to download the code.
                        </div>
                        
                       
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

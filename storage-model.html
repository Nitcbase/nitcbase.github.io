<!DOCTYPE HTML>
<html>

<head>
    <title>Storage Model</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/style.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
</head>
    
    
<body>
    <div class="header" id="top">
        <div id="title">
            <h1> <a href="index.html">Nitcbase</a></h1>
            <!--h3> Database Management System</h3-->
        </div>
        
        <div id="menubar">
            <ul id="menu">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="documentation.html"> Documentation</a></li>
                <li> <a href="roadmap.html">Roadmap</a></li>
            </ul>
        </div>
    </div>
    
    <div id="content">
        
        <div class="sidemenu">
            <ul>
                <li> <a href="#disk_model">Disk model</a></li>
                <li> <a href="#record_blk">Record block structure</a></li>
                <li> <a href="#index_blk">Index block structure</a></li>
                <li> <a href="#relcat">Relation Catalog</a></li>
                <li> <a href="#attrcat">Attribute Catalog</a></li>
            </ul>
        </div>
        
        <div id="main-content">
            
            <div class="pagetitle"><h1>Storage Model</h1></div>
            
            <div id="disk_model" class="detail">
                <h2>Disk Model</h2>
                <p> Nitcbase assumes that disk is a sequence of blocks and a block is a sequence of bytes. The disk consists of 8192 blocks and a block is of 2048 bytes. Hence there is a total of 16MB of storage. Disk blocks are indexed from 0 to 8191. </p>
                <p> Block# 0-3 are reserved for storing Block allocation map where as Block# 4, 5 are for storing first Block of Relation Catalog and Attribute Catalog respectively. Block allocation map tells us whether a particular block is free or occupied and requires one byte per each block. Hence a total of 8192/2048=4 blocks are required for Block allocation map. The following figure summarizes the disk structure. </p>
                <center><img src="img/disk_model.png"></center>
                
                <p> Based on type of information stored in a block, a block can be of 2 types- 1. Record block, 2. Index block . </p>
            </div>
            
            <div id="record_blk" class="detail">
                <h2>Record block structure</h2>
                <p> Nitcbase is a collection of relations, and each relation is a collection of records.  The DBMS must store relations in the disk and the strategy is to store each relation in a set of blocks in the disk, organized as a linked list. Each block in such a linked list will be called a record block. The block will also contains some meta data like indices of the left and right blocks in the linked list. </p>
                <p> Records in a relation are composed of fields known as attributes each of which contains one item of information. Nitcbase fixes the size of attribute as 16 bytes.
                    But the records in a relation are of variable size, the size can vary from 16 bytes (record with single attribute) to the size that the record can fit in a block. </p>
                <p> A record block stores the actual data records. In addition to data records, each block also stores meta data in preamble/header. </p>
                
                <center><img src="img/record_block.png"></center>
                
                <p> First four bytes(0-3) of header are used to identify the type of block(REC/IND) where REC represents a record block. Next four bytes(4-7) are used for storing parent block pointer which has no significance for a record block and can be set to -1. Byte# 8-11 and 12-15 are used for storing Left and right block numbers respectively. Next four bytes are used for storing number of records currently stored in the block. Bytes 20-31 are reserved for future use.</p>
                <p>  The record block is divided into slots of variable record size . Each slot stores a single record. Each block can have an arbitrary number of slots depending on the number of attributes in the relation. Number of slots(Maximum number of records) that fits in a block for any given relation can be calculated using the formula:</p>
                <p><math>#Slots = \frac{2016}{16*#Attributes + 1}</math></p>
                <p> Slotmap is used for knowing whether a slot is occupied or free. Size of slotmap is equal to number of slots that fits in the block. If a slot is free, its corresponding entry in slotmap will be 0 else it will be 1. Slotmap starts from 32<sup>nd</sup>byte of the header followed by the slots which store actual records. Some amount of space may be left unused at the end whose size is less than the size of a record.</p>
                
            </div>
            
            <div id="index_blk" class="detail">
                <h2>Index block structure</h2>
                <p> Nitcbase uses the B-Tree data structure for indexing records in a relation.  The DBMS maintains at least one index per relation (and possibly more on requirement).  Corresponding to each index of a relation, the DBMS mantains a B-Tree to store the indices.  Each node of a B-Tree is stored into a block in the disk.  A disk block that stores a node of a B-Tree is called an index block.   Each index block in Nitcbase is designed to store a maximum of 55 indices.  An index is a 3-tuple (attribute value, block number, slot number).  Each index in a B-Tree node also has an associated pair of left and right child block pointers.  Hence, in addition to the indices, each index block is required to store a total of 56 child pointers. (Only 56 Child pointers are required because the right child of one index is the same as the left child of the next index).</p>
                <center><img src="img/index_block.png"></center>
                <p> An index block is divided into two parts.  The first 32 bytes contain a header followed by actual indices and child pointers.  The header contains meta data similar to that of a record block. The first four bytes of the header stores the value IND.  PBlock is the Block# of parent block in the B-Tree. LBlock and RBlock have no significance for an index block. #Entries field stores the actual number of indices stored in the block. The remaining space in the header are left unused.</p>
                
                <p> Each entry in the index block is a 3-tuple (attribute value, block number, slot number) corresponding to the particular record. Block# and slot# occupy 4 bytes each and any attribute occupies 16 bytes.  Thus each index requires 24 bytes.  Eight bytes of unused space is maintained for future use.  Thus a total of 32 bytes are allocated for a single index entry. Each child pointer requires 4 bytes of storage. Children and indices are stored alternatively in an index block in such a way that child to the left of an index entry is its left child and child to the right is its right child. The remaining space in the block (32 bytes) is left unused.</p>  
                
               
            </div>
            
            
            <div class="pagetitle"><h1>Catalog structures</h1></div>
            
            <div class="detail" id="intro">
                <p> A relational database has two catalogs for storing the meta data information about relations, attributes, indexes etc. In addition to storing these catalogs in disk, a DBMS also caches some of them in memory for quick access. Such cache is called Catalog cache. Nitcbase uses two types of catalogs for storing the meta data. </p>
                <ol>
                    <li>Relation Catalog</li>
                    <li>Attribute Catalog</li>
                </ol>
                <p> In an RDBMS, a relation refers to collection of records where each record is an n-tuple of attribute values. An attribute is a column or field in a relation. A database is a collection of relations. </p>
                <p> Nitcbase organizes these catalogs as relations. The block structures used for the catalogs are record block structures since the catalogs are implemented as relations in Nitcbase.
                </p>
                
            </div>

            
            <div class="detail" id="relcat">
                <h2>Relation Catalog</h2>
                <p> Nitcbase stores first block of Relation Catalog in Block# 4 of the disk. Relation Catalog stores meta information regarding relations in a database. Each entry in Relation Catalog is of size 80 bytes and has the following attributes: Relation Name, #Attributes, #Records, First Block and #Slots per Block .In each entry, RelName(byte# 0-15) stores name of the relation, #Attributes(byte# 16-31) stores number of attributes of the relation, #Records(byte# 24-27) stores the number of records currently stored in the relation and First Block (byte# 48-63) stores the block number of the first record block of the relation. Since record blocks are arranged as linked list, First Block essentially stores head of the linked list, #Slots per block (byte# 64-79) stores the number of slots a record block of that relation has. This can be calculated from #Attributes</p>
 
                <center><img src="img/rel_cat.png"></center>
                
                <p>Since the Relation is also implemented as a relation, its block structure is similar to the record block with 5 attributes.</p>
            </div>
            
            <div class="detail" id="attrcat">
                <h2>Attribute Catalog</h2>
                <p>Attribute Catalog stores meta information regarding every attribute of every relation. Each entry of attribute catalog has following attributes: Relation name, Attribute Name, Attribute Type, Primary flag, Root block Index and offset where Attribute Name is name of the attribute and Attribute Type is data type of the attribute, Nitcbase permits three data types for attributes. They are integer, floating point numbers and strings(of maximum size 16).Primary flag is set to 1 if the attribute is a primary key. Nitcbase uses B-Tree for indexing. Root block Index stores the root block number of the B-Tree if there is an index created on the attribute else it contains -1. Offset is an integer which specifies the relative offset of the attribute in the record (0 for first attribute, 1 for seconf attribute etc.). </p>
                
                <center><img src="img/attr_cat.png"></center>
                
                <p>Attribute catalog is also implemented internally as a relation. Hence it's block structure is also similar to a record block with 6 attributes as shown in the figure above.</p>
            </div>
            
        </div>
    </div>
    
</body>

</html>

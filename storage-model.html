<!DOCTYPE HTML>
<html>

<head>
    <title>Physical Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
    <!-- MATHJAX CONFIG AND SCRIPT -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-sm-2">
                    <nav class="navbar navbar-expand-sm sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            <li> <a href="#disk_model">Disk model</a></li>
                            <li> <a href="#disk_class">Disk class</a></li>
                            <li> <a href="#record_blk">Record block structure</a></li>
                            <li> <a href="#intind_blk">Internal index block structure</a></li>
                            <li> <a href="#leafind_blk">Leaf index block structure</a></li>
                            <li> <a href="#relcat">Relation Catalog</a></li>
                            <li> <a href="#attrcat">Attribute Catalog</a></li>
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-sm-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>Physical Layer</h1>
                        </div>
                        
                        <div id="disk_model" class="detail">
                            <h2>Disk Model</h2>
                            <p>Nitcbase assumes that the disk is a sequence of blocks, and a block is a sequence of bytes. The disk consists of 8192 blocks, and each block is of 2048 bytes, resulting in a total of 16MB of storage. Disk blocks are indexed from 0 to 8191.</p>
			    <p>Blocks 0-3 are reserved for storing Block Allocation Map, whereas Blocks 4 and 5 are for storing the first block of <a href=#relcat>Relation Catalog</a> and <a href=#attrcat>Attribute Catalog</a>, respectively. <b>Block Allocation Map</b> tells us whether a particular block is free or occupied. If occupied, it stores the type of the block stored (<a href="/constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF</a>). It requires one byte per each block. Hence a total of 8192/2048=4 blocks are required for Block Allocation Map. The following figure summarizes the disk structure. </p>
                            <center><img class="img-fluid" src="img/disk_model.png"></center>
                            
			</div>   
                        <div id="disk_class" class="detail">
                             <h2>Disk class</h2>
                             <p>Higher layers access the disk through the disk class. 
				The class contains a constructor, a destructor, a function to read from the disk, and a function to write to the disk. 
				Out of these functions, the readBlock and writeBlock are static. 
				C++ allows static functions to be accessed using the semantics classname::functionname() (instead of objectinstance->functionname() as in the case of methods that are not declared statically). 
				These are the only functions through which the disk can be accessed. These functions are supplied to you in the NITCbase package, and hence you do not need to implement them. 
				A single object of the class needs to be declared at the start of the session, whose sole purpose is to run the constructor and the destructor of the class. 
 			     </p>
			     <center><img class="img-fluid" src="/img/disk_class.png"></center>
			     <br><br>
                             <div class="code">
                                <pre><code>class Disk {			
public:
	Disk();
	~Disk();
	static int readBlock(unsigned char *block, int blockNum);
	static int writeBlock(unsigned char *block, int blockNum);
};
                                </code></pre>
                             </div>
                             <br>
                             <ul class="methods">
                                 <li>
                                    <div class="detail" id="disk_constructor">
                                        <h2><i>public:</i> Disk (Constructor)</h2>
                                        <h5>Arguments:</h5>
                                        <p>Nil</p>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Used to make a temporary copy of the disk contents before the starting of a new session. This ensures that if the system has a forced shutdown during the course of the session, the previous state of the disk is not lost.
</p>                                        
                                    </div>
                                 </li>
                                 
                                 <li>
                                    <div class="detail" id="disk_destructor">
                                        <h2><i>public:</i> ~Disk (Destructor)</h2>
                                        <h5>Arguments:</h5>
                                        <p>Nil</p>                            
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Used to update the changes made to the disk on graceful termination of the latest session. This ensures that these changes are visible in future sessions.</p>
                                        
                                    </div>
                                 </li>
				     
				     
				 
                                 
                                 <li>
                                    <div class="detail" id="disk_readBlock">
                                        <h2><i>public: </i>readBlock</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>buffer</td>
                                                    <td>unsigned char *</td>
                                                    <td>Memory pointer of the buffer to which the block contents is to be loaded/read.</td>
                                                </tr>
                                                <tr>
                                                    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the disk block to be read.</td>
                                                </tr>		

                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>SUCCESS</td>
                                                    <td>Successful loading/reading of the block to the buffer.</td>
                                                </tr>
                                                <tr>
                                                    <td>E_OUTOFBOUND</td>
                                                    <td>Block number is out of range.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Description:</h5>
                                        <p>Transfers the contents of the specified disk block to the input memory buffer. Used in buffer layer to load disk block to buffer.</p>
					<p><b>NOTE:</b> Higher layers must allocate memory for the unsigned character array of size 2048 before passing its pointer to the function. </p>
                                    </div>
                                 </li>
                                 
                                 
                                 <li>
                                    <div class="detail" id="disk_writeBlock">
                                        <h2><i>public: </i>writeBlock</h2>
                                        <h5>Arguments:</h5>
                                    	<div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							<td>buffer</td>
							<td>unsigned char *</td>
							<td>Memory pointer of the buffer from which contents is to be written to the block.</td>
						    </tr>	
						    <tr>
							<td>blockNum</td>
							<td>int</td>
							<td>Block number of the disk block to be written to.</td>
						    </tr>
						</table>
                                    	</div>
                                    
                                        
                                    	<h5>Return value:</h5>
                                    	<div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							<td>SUCCESS</td>
							<td>Successful writing of the block to the disk.</td>
						    </tr>
						    <tr>
							<td>E_OUTOFBOUND</td>
							<td>Block number is out of range.</td>
						    </tr>
						</table>
                                     	</div>
                                        <h5>Description:</h5>
                                        <p>Transfers the contents of the input memory buffer memory buffer to the specified disk block. Used in buffer layer to write buffer contents to disk.</p>
					<p><b>NOTE:</b> Higher layers must allocate memory for the unsigned character array of size 2048 before passing its pointer to the function. </p>
                                    </div>
                                 </li>
			 </ul>
		</div>
		<p><b>Note: </b>Excluding the first four blocks (which hold the Block Allocation Map), the rest of the occupied blocks are of three types based on the type of information stored in them- 1. Record block 2. Internal Index block 3. Leaf Index block. </p>

                        <div id="record_blk" class="detail">
                            <h2>Record block structure</h2>
                            <p> Nitcbase is a collection of relations, and each relation is a collection of records.  The DBMS must store relations in the disk and the strategy is to store each relation in a set of blocks in the disk, organized as a linked list. Each block in such a linked list will be called a record block. The block will also contain some meta data like indices of the left and right blocks in the linked list. </p>
                            <p> Records in a relation are composed of fields known as <b>attributes</b>, each of which contains one item of information. Nitcbase fixes the size of attribute as 16 bytes <span style="color: red">*</span>.
                                But the records in a relation are of variable size, the size can vary from 16 bytes (record with single attribute) to the size that the record can fit in a block. </p>
                            <p> A record block stores the actual data records. In addition to data records, each block also stores meta data in preamble/<b>header</b>. 
                            The following figure shows the record block structure for a relation with K attributes. Let L be the number of records stored in a block. (given K, L can be determined. This will be explained later.) Since each attribute requires 16 bytes of storage space, to store each record of this relation 16*K bytes must be allocated.</p>
                            <p><span style="color: red">*</span><b>Note:</b> In real-world database systems, the size of an attribute will vary depending on the type of the attribute.  For instance, an integer type attribute will require less storage space than a string type attribute.  In NITCbase, we fix the size of all attributes to the same value to simplfy the implementation.  It is a conceptually straighforward (but cumbersome from the point of implementation) task to modify the DBMS to support variable sized attributes. </p>
                            
                            <center><img class="img-fluid" src="img/record_block.png"></center>

                            <p> First four bytes(0-3) of header are used to identify the type of block(<a href="/constants.html" target="_blank">REC/IND</a>) where REC represents a record block. Next four bytes(4-7) are used for storing parent block pointer which has no significance for a record block and can be set to -1. Bytes 8-11 and 12-15 are used for storing Left and right block numbers respectively. Next four bytes are used for storing number of records currently stored in the block. Bytes 20-23 and 24-27 are used for storing #Attr (Number of attributes of the records of the relation that are stored in this block) and #Slots (Number of slots in this block) respectively. Bytes 28-31 are reserved for future use.</p>
                            <p>  Each record block is divided into <b>slots</b> of variable record size . Each slot stores a single record (and hence requires 16*K bytes for a relation with K attributes). Each block can have an arbitrary number of slots depending on the number of attributes in the relation. Number of slots (Maximum number of records, L) that fits in a block for any given relation can be calculated as:</p>

                            <b><p> \[ 
                                32+L+L*(16*K) \leq 2048 \\
                                L*(16*K + 1 ) \leq 2016 \\
                                \#Slots = L = \left \lfloor \frac {2016} {((16 * \#Attributes(K)) + 1)} \right \rfloor 
                                \]</p></b>

                            <!--center><img class="formula" src="img/num_slots_formula.png" width="50%"></center-->
                            <p> The <b>slotmap</b>, which appears at the end of the header is used for indicating whether a slot is occupied or free. Size of the slotmap is equal to the number of slots, L, that fits in the block. If a slot is free, its corresponding entry in slotmap will be 0 else it will be 1. Slotmap starts from 32<sup>nd</sup>byte of the header followed by the slots which store actual records. Some amount of space may be left unused at the end whose size is less than the size of a record.</p>

                            <div class="question">
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse1">
                                            <b>Q1.</b> Calculate the number of slots and slotmap size for a relation with 5 attributes
                                        </a>
                                    </div>
                                    <div id="collapse1" class="collapse">
                                        <div class="card-body">
                                            <ul>
                                                <li>$ \#Slots = \left \lfloor \frac{2016}{(16*5)+1} \right \rfloor = 24 \\ $ </li>
                                                <li>Since the slotmap size is equal to the number of slots in a block, slotmap size = 24 bytes. </li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse2">
                                            <b>Q2.</b> What is the maximum number of attributes possible for a relation in Nitcbase?
                                        </a>
                                    </div>
                                    <div id="collapse2" class="collapse">
                                        <div class="card-body">
                                            In Nitcbase, size of the record in any relation is bounded by the size of a block. Hence number of attributes is maximum when a record fits in a block. It is calculated as: <br>
                                            $ 16*K+1 \leq 2016 \\
                                              K = \left \lfloor \frac{2015}{16} \right \rfloor \\
                                              K = 125 \\
                                            $
                                        </div>
                                    </div>
                                </div>
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse3">
                                            <b>Q3.</b> What is the maximum number of slots possible for a record block in Nitcbase?
                                        </a>
                                    </div>
                                    <div id="collapse3" class="collapse">
                                        <div class="card-body">
                                            A record block has maximum number of slots when number of attributes of the corresponding relation is 1. Hence maximum number of slots can be calculated as 118.
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <div id="intind_blk" class="detail">
                            <h2>Internal Index Block Structure</h2>
                            <p>Nitcbase uses the <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a> data structure for indexing records in a relation.  The DBMS may maintain zero or more <b>indices</b> per relation. There are two types of nodes for a B+ tree. These are called <b>internal nodes</b> and <b>leaf nodes</b>. A disk block that stores an internal node of the B+ tree is called an Internal Index block. Each internal index block in Nitcbase stores a maximum of 100 attribute(key) values. Each of these values has an associated pair of <b>left and right child pointers</b>. Hence each internal index block is also required to store 101 child pointers (Only 101 Child pointers are required because the right child of one value is the same as the left child of the next value).</p>
                            <center><img class="img-fluid" src="img/internal_index.png"></center>
			    <p>An Internal index block is divided into two parts. The first 32 bytes stores header followed by actual attribute(key) values and child pointers arranged alternatively as shown in the figure. The header metadata is similar to that of a record block. The first four bytes of the header stores the value <a href="/constants.html" target="_blank">INDINT</a>. PBlock is the Block# of parent block in the corresponding B+ tree. LBlock and RBlock have no significance for an internal index block. #Entries field stores the actual number of attribute values (of maximum 100) stored in the block. #Attrs and #Slots fields also have no significance for an internal index block. The remaining space in the header is left unused.</p>	
                            
                        </div>

                        <div id="leafind_blk" class="detail">
                            <h2>Leaf Index Block Structure</h2>
                            <p>A leaf node in the B+ tree stores the actual indices for the records in a relation. A disk block that stores a leaf node of a B+ tree is called a <b>leaf index Block</b>. Each leaf index block in Nitcbase stores a maximum of 63 indices. An index is a 3-tuple (attribute value, block number, slot number). The size of an index in nitcbase is 32 bytes (the last 8 bytes are unused).</p>
                            <center><img class="img-fluid" src="img/leaf_node.png"></center>
                            <p>Any Leaf Index Block is also divided into a header part of 32 bytes followed by a part containing actual indices. The header is similar to that of any other block. The first four bytes of the header stores the value <a href="/constants.html" target="_blank">INDLEAF</a>. PBlock is the Block# of the parent block in the corresponding B+ tree. This entry must always contain block# of an Internal Index block. Since all leaf nodes are connected in a B+ tree, LBlock and RBlock point to left and right Leaf Index blocks respectively. #Entries stores the actual number of indices (of maximum 63) stored in the block. #Attrs and #Slots fields have no significance for a Leaf index block. The remaining space in the header is left unused.</p>
                        </div>

                        <br>
                        <br>

                        <div class="pagetitle"><h1>Catalog structures</h1></div>

                        <div class="detail" id="catalogs">
                            <p> Nitcbase maintains two catalogs in the disk for storing the meta data information about relations, attributes, indexes etc. These catalogs are: </p>
                            <ol>
                                <li>Relation Catalog</li>
                                <li>Attribute Catalog</li>
                            </ol>
                            <p> In an RDBMS, a relation refers to collection of records where each record is an n-tuple of attribute values. An attribute is a column or field in a relation. A database is a collection of relations. </p>
                            <p> <i>Nitcbase organizes these catalogs as relations. Hence the block structures used for the catalogs are <a href="#record_blk">record block structures.</a></i>
                            </p>

                        </div>


                        <div class="detail" id="relcat">
                            <h2>Relation Catalog</h2>
                            <p> Nitcbase stores first block of the Relation Catalog in Block# 4 of the disk. Relation Catalog stores meta information regarding relations in a database. Each entry in the Relation Catalog is of size 96 bytes and has the following attributes: Relation Name, #Attributes, #Records, First Block, Last Block and #Slots per Block. In each entry, RelName(byte# 0-15) stores name of the relation, #Attributes(byte# 16-31) stores number of attributes of the relation, #Records(byte# 32-47) stores the number of records currently stored in the relation and First Block (byte# 48-63) stores the block number of the first record block of the relation. Since record blocks are arranged as linked list, First Block essentially stores head of the linked list and Last Block (byte# 64-79) stores the block number of the last record block of the relation. #Slots per block (byte# 64-79) stores the number of slots a record block of that relation has. (Note that #slots can be can be calculated from #Attributes as described <a href="#record_blk">earlier</a>.)</p>

                            <center><img class="img-fluid" src="img/relation_catalog.png"></center>

                            <b>Note:</b> <i>Since the Relation Catalog is also stored in the disk like any other relation, its block structure is identical to that of any record block with 6 attributes.</i>
                            <br>
                            <br>
                            <div class="question">
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse4">
                                            <b>Q1.</b> What are the values of the header fields #Attrs, #Slots for a Relation Catalog block?
                                        </a>
                                    </div>
                                    <div id="collapse4" class="collapse">
                                        <div class="card-body">
                                            <ul>
                                                <li>
                                                    #Attrs = 6.
                                                </li>
                                                <li>
                                                    #Slots = $\left \lfloor \frac{2016}{(16*6)+1} \right \rfloor = 20 \\ $
                                                </li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse5">
                                            <b>Q2.</b> What is the minimum number of entries in the relation catalog and what relations do they correspond to?
                                        </a>
                                    </div>
                                    <div id="collapse5" class="collapse">
                                        <div class="card-body">
                                            Minimum number of entries in the relation catalog is 2 despite not creating any relation externally. They correspond to relation catalog and attribute catalog since they are also relations and should be in the disk all the time.
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <div class="detail" id="attrcat">
                            <h2>Attribute Catalog</h2>
                            <p>Attribute Catalog stores meta information regarding every attribute of every relation. Each entry of the attribute catalog has the following attributes: <i>Relation name, Attribute Name, Attribute Type, Primary flag, Root block Index</i> and <i>offset</i>, where Attribute Name is name of the attribute and Attribute Type(Integer/Float/String) is data type of the attribute, Nitcbase permits three data types for attributes. They are integer, floating point numbers and strings (of maximum size 16). The primary key flag is presently unused<span style="color: red">*</span>. Nitcbase uses <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a> for indexing. Root block Index stores the root block number of the B+ Tree if there is an index created on the attribute; and contains -1 otherwise. Offset is an integer which specifies the relative offset of the attribute in the record (0 for first attribute, 1 for second attribute etc.). </p>
                            <p><span style="color: red">*</span><b>Note:</b> At present NITCbase does not support the notion of a <a href="https://en.wikipedia.org/wiki/Primary_key" target="_blank">primary key</a>. The flag is kept in the slot for future support for primary keys.  </p>

                            <center><img class="img-fluid" src="img/attr_cat.png"></center>

                            <b>NOTE:</b> 
                                <ol>
                                    <li>Attribute catalog is also implemented internally as a relation. Hence its block structure is identical to that of any record block with 6 attributes as shown in the figure above.</li>
                                    <li>Nitcbase does not create any index for accessing the attribute catalog and relation catalog. Hence access to these catalogs will be through a sequential search through the record blocks of the respective catalog.</li>
                                </ol>


                            <div class="question">
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse6">
                                            <b>Q1.</b> What is the minimum number of entries in the attribute catalog and what relations/attributes do they correspond to?
                                        </a>
                                    </div>
                                    <div id="collapse6" class="collapse">
                                        <div class="card-body">
                                            Minimum number of entries in the attribute catalog is 12 despite not creating any relation externally. 6 out of these 12 correspond to 6 attributes of relation catalog and the rest 6 corresponds to 6 attributes of attribute catalog since they are also relations and should be in the disk all the time.
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                        </div>
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
        
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

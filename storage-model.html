<!DOCTYPE HTML>
<html>

<head>
    <title>Storage Model</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/style.css">
</head>
    
    
<body>
    <div class="header" id="top">
        <div id="title">
            <h1> <a href="index.html">Nitcbase</a></h1>
            <!--h3> Database Management System</h3-->
        </div>
        
        <div id="menubar">
            <ul id="menu">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="documentation.html"> Documentation</a></li>
                <li> <a href="roadmap.html">Roadmap</a></li>
            </ul>
        </div>
    </div>
    
    <div id="content">
        
        <div class="sidemenu">
            <ul>
                <li> <a href="#disk_model">Disk model</a></li>
                <li> <a href="#record_blk">Record block structure</a></li>
                <li> <a href="#index_blk">Index block structure</a></li>
            </ul>
        </div>
        
        <div id="main-content">
            
            <div class="pagetitle"><h1>Storage Model</h1></div>
            
            <div id="disk_model" class="detail">
                <h2>Disk Model</h2>
                <p>Nitcbase assumes that disk is a sequence of blocks and a block is a sequence of bytes. The disk consists of 8192 blocks and a block is of 2048 bytes. Hence there is a total of 16MB of storage. Disk blocks are indexed from 0 to 8191. </p>
                <p> Block# 0-3 are reserved for storing Block allocation map where as Block# 4 is for storing Database Catalog. Block allocation map tells us whether a particular block is free or occupied and requires one byte per each block. Hence a total of 8192/2048=4 blocks are required for Block allocation map. The following figure summarizes the disk structure. </p>
                <center><img src="img/disk_model.png"></center>
                
                <p> Based on type of information stored in a block, a block can be of two types- 1. Record block and 2. Index block.</p>
            </div>
            
            <div id="record_blk" class="detail">
                <h2>Record block structure</h2>
                <p> A database in Nitcbase is a collection of relations, and each relation is a collection of records.  The DBMS must store relations in the disk and the strategy is to store each relation in a set of blocks in the disk, organized as a linked list. Each block in such a linked list will be called a record block and is designed to store a fixed number of records.  The block will also contains some meta data like indices of the left and right blocks in the linked list.  Nitcbase fixes the size of a record as 256 bytes. </p>
                <p>A record block stores the actual data records. The record block is divided into slots of size 256 Bytes each. Each slot stores a single record. Each block can have a maximum of 7 slots/records. In addition to data records, each block also stores meta data in preamble/header which occupies the first 256 Bytes of the record block.</p>
                <center><img src="img/record_block.png"></center>
                <p>First four bytes(0-3) of header are used to identify the type of block(REC/IND) where REC represents a record block. Next four bytes(4-7) are used for storing parent block which has no significance for a record block and can be set to -1. Byte# 8-11 and 12-15 are used for storing Left and right block numbers respectively. Next four bytes are used for storing number of records currently stored in the block whose value can range from 0 to 7. Bytes 20-31 are reserved for future use.</p>
                <p> Slotmap is used for knowing whether a slot is occupied or free. It is of 7 bytes, one for each slot. If a slot is free, its corresponding entry in slotmap will be 0 else it will be 1. Slotmap occupies 32-38 bytes of the header. Rest of the bytes in the header i.e., 39-255 are unallocated.</p>
                <p>A Record can have a maximum of 16 attributes and an attribute can have a maximum of 16 Bytes. Each attribute is alloted a fixed size of 16 bytes and hence each record is alloted a fixed size of 256 bytes in disk.</p>
                <center><img src="img/record_struct.png"></center>
            </div>
            
            <div id="index_blk" class="detail">
                <h2>Index block structure</h2>
                <p>Nitcbase uses the B-Tree data structure for indexing records in a relation.  The DBMS maintains at least one index per relation (and possibly more on requirement).  Corresponding to each index of a relation, the DBMS mantains a B-Tree to store the indices.  Each node of a B-Tree is stored into a block in the disk.  A disk block that stores a node of a B-Tree is called an index block.   Each index block in Nitcbase is designed to store a maximum of 37 indices.  An index is a 4-tuple (attribute value, primary key, block number, slot number).  Each index in a B-Tree node also has an associated pair of left and right child block pointers.  Hence, in addition to the indices, each index block is required to store a total of 38 child pointers. (Only 38 indices are required because the right child of one index is the same as the left child of the next index).</p>
                <center><img src="img/index_block.png"></center>
                <p>An index block is divided into three parts.  The first 32 bytes contain a header, the next 1776 bytes store the indices, the following 152 bytes store the child pointers and the last 88 bytes are unused.  The header contains meta data similar to that of a record block. The first four bytes of the header stores the value IND.  PBlock is the Block# of parent block in the B-Tree. LBlock and RBlock have no significance for an index block. #Entries field stores the actual number of indices stored in the block. The remaining space in the header are left unused.</p>
                 <center><img src="img/index_struct.png"></center>
                <p>Each entry in the index block is a 4-tuple (attribute value, primary key, block number, slot number) corresponding to the particular record. Block# and slot# occupy 4 bytes each and since each attribute occupies 16 bytes.  Thus each index requires 40 bytes.  Eight bytes of unused space is maintained for future use.  Thus a total of 48 bytes are allocated for a single index entry.  Since an index block can store upto 37 indices, the total space required for storing indices is 37*48=1776.  Each child pointer requires 4 bytes of storage and  the total space for storing 38 child pointers works out to 38*4 = 152.  The remaining space in the block (88 bytes) is left unused.</p>
                <p> Note:  An index block has enough space to actually store 38 indices, but the number was limited to 37 because B-Tree algorithms are easier to implement when the maximum number of indices in a node is odd. </p>  
               
            </div>
            
        </div>
    </div>
    
</body>

</html>
<!DOCTYPE HTML>
<html>

<head>
    <title>B+ Tree Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                            <ul class="nav flex-column sidemenu">
                                <li> <a class="sec" href="#create"> B+ Create</a></li>
                                <li> <a class="sec" href="#destroy"> B+ Destroy</a></li>
                                <li> <a class="sec" href="#insert"> B+ Insert</a></li>
                                <li> <a class="sec" href="#search"> B+ search</a></li>
                            </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>B+ Tree Layer</h1>
                        </div>
                        
                        <div class="detail">
				<h5>Pre-requisite Reading : <a href="./indexing.html">Indexing in NITCbase</a></h5>
                        	<p>As you might already know, we use indexing to reduce disk access and to implement search queries faster. NITCBase uses B+ Tree for indexing an attribute in a relation. To implement B+ Tree layer you must require a thorough understanding of the Physical layer, Buffer layer and Cache layer.
                        	</p>
                        </div>
			    
<!----------------------BPLUS CONSTRUCTOR STARTS -------------------------------------------------------------------------->                        
                         <div id="create" class="detail">
                            <h2>public: BPlusTree (Constructor)</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>relid</td>
		                    			<td>int</td>
		                    			<td>Relation Id of the relation which contains the target attribute.</td>
		                			</tr>
		                			<tr>
		                    			<td>attrName</td>
		                    			<td>char[ATTR_SIZE]</td>
		                    			<td>Name of attribute with which B+ tree has to be created.</td>
		                			</tr>
		                        </table>
                            </div>
                            <h5>Return value:</h5> Nil
		                     
		            <h5>Description:</h5>
		            <p>This method creates the bplus-tree(Indexing) on the attribute of a relation specified in the arguments and also updates the object instance's member fileds with the given arguments.</p>
		                   
		            <h5><a data-toggle="collapse" href="#algo-create"><span class="fas fa-code"></span>Algorithm:</a></h5>
                             	     <div id="algo-create" class="collapse">
                            	     	<div class="code"><pre><code>BPlusTree(relId relid, char attrName[ATTR_SIZE]){
					
    //initialise the object instance member fields: relid and attrName with the given relid and attrName	
    
    //let attrCatEntry be used to store the attribute cache entry for attrName
    AttrCatEntry attrCatEntry;
    
    //get the attribute catalog entry of target attribute using OpenRelTable::getAttrCatEntry() method.
    int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatBuf);
    
	if( status != SUCCESS)
		//update member field rootBlock of the class with the status and return
	
	//let rootBlockNum be used to store the root block number of the B+ Tree
	int rootBlockNum;
	
	if(rootBlockNum != -1) //index already exists for the attribute
		//update the rootBlock member field of the class with rootBlockNum and return
	
	/******Creeating a new B+ Tree ******/
	
	//get a free leaf block
	IndLeaf rootBlock;
	
	if(rootBlock.getBlockNum()==FAILURE) //disk is full, i.e,  unable to get new block from the disk
		//update the rootBlock member field of the class with E_DISKFULL and return
	else 
		//update rootBlock member field of the class with the block number of rootBlock
		
	//update the rootBlock in the attribute cache, attrCatBuf,  using OpenRelTable::setAttrCatEnty()

	//let the relCatBuf hold the relation catalog entry corresponding to relid
	RelCatEntry relCatBuf;
	
	//load the relation catalog entry into relCatBuf using OpenRelTable::getRelCatEntry()
	
	//get the first record block of the relation, number of attributes of the relation and number of slots in the corresponding record block in variables block, numAttr and numSlots respectively using relCatBuf.
	int block;
	int numAttr;
	int numSlots;
	
	//let attrOffset hold the offset of the attribute in the relation- obtained from attrCatBuf
	int attrOffset;
	
	/******traverse all the blocks in the relation and insert them one by one into the B+ Tree.******/
	while(block!=-1) 
	{	
	        //load the the block of the relation into a RecBuffer
		RecBuffer recBlock(block);
		
		//let slotMap hold the header of the block	
		unsigned char slotMap[numSlots];
		
		//load the slot map into slotMap using RecBuffer::getSlotMap()
		
		for slot = 0 to numSlots - 1:
		{	
			if(slotMap[slot]=='1') //if there is an entry
			{				
				//let rec hold the contents of the record
				union Attribute rec[numAttr];
			
				//load the record corresponding to the slot into rec using RecordBuffer::getRecord()
				
				//let recordId hold the record id {block, slot}
				struct recId recordId;

				//insert the attribute value of the record corresponding to attrName using bPlusInsert
				status = bPlusInsert(rec[attrOffset], recordId);
			
				if(status == E_DISKFULL) //disk is full, i.e,  unable to get enough blocks to build the B+ Tree				
					//update the rootBlock member field of the class with E_DISKFULL and return				
			}
		    	else //all records in the relaton has been traversed
				break;
		}
		
		//let blockHead be used to hold the header of block.
		HeadInfo blockHead;
		
		//load the header of recBlock into blockHead using BlockBuffer::getHeader()
		
		//update the block with rblock of the header.		
	}	
}</code></pre>
					</div>
                            	     </div> 
                        </div>
<!-----------------------------------CONSTRUCTOR ENDS HERE------------------------------------------------------------------------------------>                       
                        <div id="destroy" class="details">
                        	<h2>B+ Destroy</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>block_num</td>
		                    			<td>int</td>
		                    			<td>Block no. of head of bplus tree which need to be destroyed.</td>
		                			</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                        		<td>SUCCESS</td>
		                        		<td>On successful deletion of b+ tree</td>
		                    		</tr>
		                    		<tr>
		                    		    <td>E_OUTOFBOUND</td>
		                    		    <td>If the block_num is less than 0 or greater than or equal to DISK_BLOCKS</td>
		                    		</tr>
		                    		<tr>
		                    		    <td>E_INVALIDBLOCK</td>
		                    		    <td>If the block is not an index block</td>
		                    		</tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This method deletes/frees the bplus-tree whose head block_num is given as argument.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-destroy"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-destroy" class="collapse">
                            	<div class="code"><pre><code>int bplus_destroy(int block_num){
	//all the index blocks are deleted recursively
	
	if(block_num &lt; 0 || block_num &gt;= DISK_BLOCKS){ //if the block_num is invalid
		E_OUTOFBOUND;
	}
	
	//get the block_type from header of the block
	if(block_type != INDINT || block_type != INDLEAF){ //if the block is not index block
		return E_INVALIDBLOCK;
	}
	
	if(block_type == INDLEAF){ //if the block is leaf index block
		//delete the block from the disk
	}
	else if(block_type == INDINT){ 	//if the block is internal index block
		//iterate over all the internal index entries{
			//delete all the child index blocks corresponding to each internal index block by calling
			bplus_destroy(child_block);
		//}
	}	
	
	return SUCCESS;
}</code></pre>
								</div>
                            </div>
                        </div>
<!-- -------------------------------BPLUS INSERT BEGINS HERE-------------------------------------------------------------------------------- -->                        
                        <div id="insert" class="detail">
                        	<h2>public: bPlusInsert</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	
								    <tr>
								        <td>attrval</td>
								        <td>union Attribute</td>
								        <td>value corresponding to attrName attribute of target record that need to be inserted in to bplus tree.</td>
								    </tr>
								    <tr>
								        <td>recordId</td>
								        <td>recId</td>
								        <td>The record id of target record that need to be inserted in to bplus tree.</td>
								    </tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        		    <tr>
						                <td>SUCCESS</td>
						                <td>On successful insert of the recid.</td>
						            </tr>
						            <tr>
						                <td>E_NOINDEX</td>
						                <td>If B+ tree has not been created on the given attribute.</td>
						            </tr>
						            <tr>
						                <td>E_DISKFULL</td>
						                <td>If disk space is not sufficient to insert into the B+ tree.</td>
						            </tr>
		                     	</table>
		             </div>
			    <h5>Description:</h5>
                            <p>This method inserts the <i>Index</i> of the record corresponding to the given attribute value and record id into the B+ tree.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-insert"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-insert" class="collapse">
                            	<div class="code"><pre><code>int bPlusInsert(union Attribute val,recId recordId){
	
    //let attrCatBuf be used to store the attribute cache entry for attrName
    AttrCatEntry attrCatEntry;

    //get the attribute catalog entry of target attribute using OpenRelTable::getAttrCatEntry() method.
    int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatEntry);
	
    if( status != SUCCESS)
		return status;
    
    //let blockNum be the rootBlock of AttrCatEntry 
    int blockNum;
    
    if blockNum of target attribute is -1:
	    return E_NOINDEX;
    
    //let attrType store type of attribute
    int attrType;
   
    class IndBuffer *block = NULL;
	HeadInfo blockHeader;
	
	/******Traverse the B+ Tree to reach the appropriate leaf where insertion can be done******/
    while block is not LEAF: // StaticBuffer::getStaticBlockType() can be used 
     {  
     	//load the block
        block = new IndInternal(blockNum);
        
        //load header of block into blockHeader using BlockBuffer::getHeader() method.
        
        //let nEntries be no. of entries in block (can be found from blockHeader)
        int nEntries;
        
        //iterate through all the entries, to find first entry whose attibute value >= value to be inserted.
        //NOTE: the helper function compare() can be used to compare two Union attribute values based on attrType.
        
        if no such entry is found: 
        {       
         	//update blockNum with rChild of nEntries-1'th (i.e. last) entry of the block.  
        	//delete block.
        }      
        else  
        {
         	 //update blockNum with lChild of the entry of block.
                 //delete block. 
         }
    }

    //NOTE: now blockNum is the leaf index block to which insertion of val is to be done.
    
    /******Insertion of entry in the appropriate leaf block******/
    
    //load the block 
    block = new IndLeaf(blockNum);
    
    Index indexval; //(stores Index entry to be inserted in B+ Tree)
    //update indexval with as that of recid, val.

    //load header of the block into blockHeader using BlockBuffer::getHeader() method.

    //let nEntries be no. of entries in block pointing by block(can be found from blockHeader)
    int nEntries;

    //let indices[nEntries+1] be an array of type struct Index.
    Index indices[nEntries+1];
    
    //iterate through 0 to nEntries-1 and copy all the entries in the block to the array indices. Also insert indexval at appropriate position in the indices array.
    
    if (nEntries!= 63) 
    {
    	//NOTE: leaf block has not reached max limit
    	
        //update blockHeader.numEntries as nEntries+1 and set this as header of block using BlockBuffer::setHeader() method. 
        
        //iterate through 0 to nEntries and populate the entries of block with entries in indices array using IndBuffer::setEntry() method.
        
        //delete block.
        
        return SUCCESS;
    } 
    else 
    {
    	//NOTE: leaf block is full- need a new leaf to make the entry; split the entries between the two blocks
    	
    	//obtain new leaf index block as the right block in the splitting
        class IndBuffer * newRightBlk = new IndLeaf();
        
        //assign the existing block as the left block in the splitting
        class IndBuffer * leftBlk = block;
        
        //store the block numbers of both blocks in variables newRightBlkNum and leftBlkNum using BlockBuffer::getBlockNum() method
	int newRightBlkNum;
	int leftBlkNum;
		
	if(newRightBlkNum == FAILURE) //failed to obtain an empty leaf index becauase the disk is full
	{	
		//delete the B+ tree created till now.
		//update the rootBlock of attrCatEntry as -1 using  OpenRelTable::setAttrCatEntry
		this->rootBlock = E_DISKFULL;
		return E_DISKFULL;
        }
        //let leftBlkHeader be the header of the left block(which is presently stored in blockHeader)
        struct HeadInfo leftBlkHeader = blockHeader;
		
	//let prevRblock be the right block after leftBlk
	int prevRblock = leftBlkHeader.rblock;
			
        //update number of enteries in leftBlkHeader as 32 and its rblock as newRightBlkNum using using BlockBuffer::setHeader() method.

	//let newRightBlkHeader be of type struct HeadInfo
        struct HeadInfo newRightBlkHeader;
		
	//load the header of block newRightBlkHeader in newRightBlkHeader using BlockBuffer::getHeader
		
        //update number of enteries in newRightBlkHeader as 32, its plbock as the plbock of leftBlk, its lblock as leftBlkNum and its rblock as prevRblock using BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.

     	//set the first 32 entries of leftBlk as the first 32 entries of indices array and set the first 32 entries of newRightBlk as the next 32 entries of indices array using IndBuffer::setEntry() method.

        //let parBlkNum be the pblock of leftBlk.
        int parBlkNum;
        
        delete leftBlk;
        delete newRightBlk; 
        
        //let newAttrval hold the attribute value of indices[31]; this is attribute value which needs to be inserted in the parent block
        union Attribute newAttrval;
		
	/******Traverse the internal index blocks of the B+ Tree bottom up making insertions where ever required******/

	//let done indicate whether the insertion is complete or not
        bool done = false;
        
        while(!done)
       	{
            if (parBlkNum!=-1) //parBlkNum is a valid parent block
            {
            	//load the block corresponding to parBlkNum to parblk
                class IndInternal *parblk= new IndInternal(parBlkNum);
                            
                //let parheader be of type struct HeadInfo
                struct HeadInfo parheader;
                
                //load parheader with header of parblk using BlockBuffer::getHeader() method.
                
		//let internalEntries be an array of InternalEntries of size parheader.numEntries+1
                struct InternalEntry internalEntries[parheader.numEntries+1];
                
                //iterate through 0 to parheader.nEntries-1 and copy all the entries in the parblk to the array internalEntries. Also insert an InternalEntry entry with attrVal as newAttrval, lChild as leftBlkNum and rChild as newRightBlkNum at an appropriate position in the internalEntries array.				
			
                if(parheader.numEntries!=100) //parBlkNum has not reached max limit
                {
                	//increment parheader.numEntries and update it as header of parblk BlockBuffer::setHeader() method. 
				
			//iterate through 0 to parheader.numEntries-1 and populate the enties of parblk with entries in internalEntries array using IndBuffer::setEntry() method.
				
			//delete parblk.
                    
                    	//set done to true;

                }
                else //the parent internal index is full- need a new internal index to make the entry; split the entries between the two blocks
                {
		
		    //obtain a new internal index block in dummy
                    class IndInternal* dummy = new IndInternal();
                     
                    if(dummy->getBlockNum()==FAILURE) //failed to obtain an empty leaf index becauase the disk is full
                    {
                    	//destroy the right subtree, given by newRightBlkNum, build up till now that has yet been connected to the existing B+ Tree. 
			//destroy the remaining B+ tree too which was built till now.
			//update rootBlock of attrCatEntry as -1 using OpenRelTable::setAttrCatEntry()
			this->rootBlock = E_DISKFULL;
			return E_DISKFULL;
                    }
                    
                    //assign dummy as the left block in the splitting
                    newRightBlk= (class IndInternal* )dummy;
                    
                    //assign the dummy block as the left block in the splitting
                    leftBlk= (class IndInternal* )parblk;
                    
                    //udpate newRightBlkNum with block number of newRightBlk using BlockBuffer::getBlockNum() method.
                    
                    //update leftBlkNum with parBlkNum
                    
                    //update leftBlkHeader with parheader
                    
                    //update number of enteries of leftBlkHeader as 50 using BlockBuffer::setHeader() method.
                    
                    //update number of enteries of newRightBlkHeader as 50 using BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.
                     
		    //set the first 50 entries of leftBlk as the first 50 entries of internalEntries array and set the first 50 entries of newRightBlk as the entries from 51 to 100 of indices array using IndBuffer::setEntry()
					
                    IndBuffer *childBuff;
                    struct HeadInfo childBuffHead;
                    
                    //let type be the block type of a child of any entry( say, the rchild of 50th entry) in the internalEntries array, using StaticBuffer::getStaticBlockType method.
                    int type;
                	
                     //iterate from 50 to 100:
                     {
                		//assign the rchild block of ith index in internalEntries of the appropriate type to childBuff 
                		if(type == IND_LEAF)
                			childBuff = (IndBuffer*) new IndLeaf(internalEntries[i].rChild);
			         else
			            	childBuff = (IndBuffer*) new IndInternal(internalEntries[i].rChild);
                        
                       		//update pblock field in header of the childBuff block to newRightBlkNum making use of BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.
  				delete childBuff;                    
                  
                    }

                    delete leftBlk;
                    delete newRightBlk;
                    
                    //update parBlkNum to the pblock of leftBlk

                    //update newAttrval to the attribute value of 50th entry in the internalEntries array;  

            	}
            }
            else //when parBlkNum is invalid 
            { 
		//NOTE: Need to allot a new block which would be the root of the B+ Tree
			
		//load a new internal index block to newRootBlk
                class IndInternal* newRootBlk = new IndInternal();
                
                //store the block number of newRootBlk in newRootBlkNum using BlockBuffer::getBlockNum() function.
                int newRootBlkNum;
                
                if(newRootBlkNum == FAILURE) //failed to obtain an empty internal index block becauase the disk is full
                {	
                	//destroy the right subtree, given by newRightBlkNum, build up till now that has yet been connected to the existing B+ Tree.
			//destroy the remaining B+ tree too which was built till now.
			//update the rootBlock of attrCatEntry as -1 using OpenRelTable::setAttrCatEntry()
                	this->rootBlock = E_DISKFULL;
			return E_DISKFULL;
               	}
               	
               	//let newRootHeader be the header of newRootBlk
                struct HeadInfo newRootHeader; 
                
		//update number of enteries in newRootBlk as 1 using BlockBuffer::setHeader() and BlockBuffer::getHeader() methods.
				
                //add the InternalEntry entry with lChild as leftBlkNum, attrVal as newAttrval and rChild as newRightBlkNum as the first entry to newRootBlk using IndBuffer::setEntry();

		//update the pblock both leftBlkNum and newRightBlkNum to newBlkNum using BlockBuffer::setHeader() and BlockBuffer::getHeader() methods
		/*NOTE : the type of leftBlkNum and newRightBlkNum has to be checked first (using StaticBuffer::getStaticBlockType()) before loading it into leftBlk and newRightBlk with appropriate IndLeaf or IndInternal instances */

                //update rootBlock of attrcatEntry variable (into which the attribute catalog was earlier loaded) as newBlkNum using OpenRelTable::setAttrCatEntry() method.
                
                delete newRootBlk;
                
                //set done to true.
        	}
    	}
    
       return SUCCESS;
}
				
 
}</code></pre>
                            	</div>
                            </div>
                        </div>
<!-- -------------------------------BPLUS INSERT ENDS HERE-------------------------------------------------------------------------------- -->                                                
                        <div id="search" class="detail">
                        	<h2>B+ Search<h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
								        <td>relid</td>
								        <td>int</td>
								        <td>Relation Id of Relation in which target attribute is contained.</td>
									</tr>
									<tr>
								        <td>attrname</td>
								        <td>char[ATTR_SIZE]</td>
								        <td>name of colomumn/attribute(containing b+ tree) to which search has to be made.</td>
									</tr>
									<tr>
								        <td>attrval</td>
								        <td>union Attribute</td>
								        <td>value of attribute that to be checked against the operater.</td>
								    </tr>
									<tr>
								        <td>op</td>
								        <td>int</td>
								        <td>Conditional Operator(can be one among EQ,LE,LT,GE,GT,NE corresponding to equal,lesthan equal, lessthan ,greaterthan equal, greaterthan, Not equal operators respectively).</td>
									</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>RecId (block#, slot#)</td>
						                <td>returns (block#, slot#) of the record corresponding to the next hit.</td>
						            </tr>
						            <tr>
						                <td>(-1, -1)</td>
						                <td>If no valid next hit is found.</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>If the attribute specified has an indexing, this method searches for the next hit record fallowing the condition given on attribute(based on op, Attrval). to find the next hit record fallowing bplus tree, it uses the sid(previous hit) from attribute cache, after finding the next hit updates the sid in cache.
(NOTE:previous hit in attribute cache(sid) is used only if there is b+ indexing on that attribute)</p>
                            <h5><a data-toggle="collapse" href="#algo-search"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-search" class="collapse">
                            	<div class="code"><pre><code>struct recId bplus_search(relId relid, char AttrName[ATTR_SIZE], union Attribute AttrVal, int op){
	AttrCatEntry attrcat_entry;
	
	//get the previous index id from the attribute cache (corresponds to relid, AttrName) by calling
	OpenRelTable::<a href="cache.html#getattrcatentry" target="_blank">getAttrCatEntry</a>(relid, AttrName, &amp;attrcat_entry);
	prev_indexid = OpenRelTable::<a href="cache.html#getprevindexid" target="_blank">getPrevIndexId</a>(relid, AttrName);
	
	//prev_indexid is set only if the search proccessed through leaf index blocks (search has been done before atleast once)
	//otherwise prev_indexid is unset ({-1,-1})
	
	//if prev_indexid is unset then assign block as root block and index as 0 (i.e seach from the root block)
	//if prev_indexid is set then assign block as prev_indexid's block and index as prev_indexid's index + 1
	
	//if assigned index exceeds the indices present in the leaf index block{
		//assign block as block right's block (i.e next leaf index block)
		//if(block == -1) (i.e, search is done )then return {-1,-1}
	//} 
	
	//if(block_num == root_block &amp;&amp; index == 0){
		//traverse through all the internal nodes according to the attribute value AttrVal and the operator op
		//Accordingly update block and index variables
	//}
	
	//NOTE: From Index blocks are leaf index blocks (WHY!!!)	 
	
	//Traverse through leaf index entries in the leaf index block (block) from index entry numbered as index
	
	//if no index entry in the leaf block satisfies the given condition{
		//then there are two possiblities:
		// 1. Search is Completed 
		// 2. No record in the relation with relid satisfies the given condition
		// update prev_recid in the attribute cache as {-1, -1}
		// return recid = {-1, -1}
	//} 
	
	//otherwise{
		//update prev_recid in the attribute cache as 
		//prev_recid = {block (leaf index block), index (index entry that satisfied the given conditon)}
		//get record id (recid) from the index entry
		//return record id
	//}
}</code></pre>
                            	</div>
                            </div>
                        </div>                            
                                  
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

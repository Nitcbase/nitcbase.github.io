<!DOCTYPE HTML>
<html>

<head>
    <title>B+ Tree Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                            <ul class="nav flex-column sidemenu">
                                <li> <a class="sec" href="#constructor"> BPlusTree Constructor</a></li>
                                <li> <a class="sec" href="#destroy"> bPlusDestroy()</a></li>
                                <li> <a class="sec" href="#insert"> bPlusInsert()</a></li>
                                <li> <a class="sec" href="#search"> bPlusSearch()</a></li>
                            </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>B+ Tree Layer</h1>
                        </div>
                        
                        <div class="detail">
				<h5>Pre-requisite Reading : <a href="./indexing.html">Indexing in NITCbase</a></h5>
                        	<p>As you might already know, we use indexing to reduce disk access and to implement search queries faster. NITCBase uses B+ Tree for indexing an attribute in a relation. To implement B+ Tree layer you must require a thorough understanding of the Physical layer, Buffer layer and Cache layer.
                        	</p>
				<p>NITCbase follows Object Oriented design for implementing B+ Tree. The class diagram is as shown below.</p>
                        </div>
<!-------------------------------------B+ tree class--------------------------------------------> 
			<div id="bplustree_class" class="detail">
				    <h2>class BPlusTree</h2>
                             	    <div class="code">
                                    <pre><code>class BPlusTree{
    private :
    int rootBlock, relId;
    char attrName[ATTR_SIZE];
    int bplusDestroy(int blockNum);
    
    public:
    BplusTree(int relId, char attrName[ATTR_SIZE]);
    int bplusInsert(union Attribute val, recId recordId);
    struct recId bplusSearch(union Attribute attrVal, int op);
    int getRootBlock();  
    
};</code></pre>
                                </div>
                         	<br>
				<p>The class contains three private field members: rootBlock, relId and attrName. The rootBlock field of the object will store the parent/root block number of the B+ tree, if created successfully. Otherwise, the status (<a href="../constants.html#errors" target="_blank">E_DISKFULL</a>, <a href="../constants.html#errors" target="_blank">SUCCESS</a>, <a href="../constants.html#errors" target="_blank">E_OUTOFBOUND</a>, <a href="../constants.html#errors" target="_blank">E_NOTOPEN</a>, <a href="../constants.html#errors" target="_blank">E_ATTRNOTEXIST</a>) that arises while creating the B+ tree will be stored in the rootBlock field. The relId field stores the relation Id of the relation which contains the attribute whose B+ tree has to be created, while the attrName field stores the attributeâ€™s name. Both relId and attrName have to be provided to create B+ tree for an attribute.</p>
<p>For creating B+ tree on any attribute, an instance of the class BPlusTree has to be declared. When an object is instantiated, the constructor of the class creates a new B+ tree and updates the member fields of the object. If B+ tree already exists for that attribute, the member fields of the object are updated with appropriate values. 

				</p>
                             <p>The following are the specifications for the methods in class <i>BPlusTree</i>.</p>
				<ul class="methods">
					<li>
<!----------------------BPlusTree Constructor-------------------------------------------------------------------------->                        
                         <div id="constructor" class="detail">
                            <h2>public: BPlusTree (Constructor)</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>relid</td>
		                    			<td>int</td>
		                    			<td>Relation Id of the relation which contains the target attribute.</td>
		                			</tr>
		                			<tr>
		                    			<td>attrName</td>
										<td>char[<a href="../constants.html#constant" target="_blank">ATTR_SIZE</a>]</td>
		                    			<td>Name of attribute whose B+ tree is to be created.</td>
		                			</tr>
		                        </table>
                            </div>
                            <h5>Return value:</h5> 
							<p>Nil</p>
		                     
		            <h5>Description:</h5>
		            <p>Creates a B+ Tree(Indexing) for the input attribute of the specified relation. It inserts the attribute value corresponding to <i>attrName</i> of all entries in the relation into the B+Tree using <i>bPlusInsert()</i>. If in between the insertion, the disk runs out of space, then the B+ Tree will not be created. This method also sets the object instance's member fields with the input arguments. </p>
		                   
		            <h5><a data-toggle="collapse" href="#algo-constructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
                             	     <div id="algo-constructor" class="collapse">
                            	     	<div class="code"><pre><code>BPlusTree::BPlusTree(int relid, char attrName[ATTR_SIZE])
{					
    //initialise the object instance member fields, relid and attrName, with the input relid and attrName.
    
    //let attrCatEntry be used to store the attribute cache entry for attrName.
    AttrCatEntry attrCatEntry;
    
    //get the attribute catalog entry of target attribute using<a href="cache.html#getattrcatentry" target="_blank"> OpenRelTable::getAttrCatEntry()</a> method.
    int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatBuf);
    
    if(status != <a href="../constants.html#errors" target="_blank">SUCCESS</a>)
	{
    	//update member field rootBlock of the class with the status and return.
	}
	
	//let rootBlockNum be used to store the root block number of the B+ Tree, obtained from attrCatBuf.
	int rootBlockNum;
	
	if(rootBlockNum != -1) //index already exists for the attribute.
	{
		//update the rootBlock member field of the class with rootBlockNum and return.
	}
	
	/******Creeating a new B+ Tree ******/
	
	//get a free leaf block.
	IndLeaf rootBlock;
	
	if(rootBlock.getBlockNum() == <a href="../constants.html#errors" target="_blank">FAILURE</a>) //disk is full, i.e,  unable to get new block from the disk.
	{
		//update the rootBlock member field of the class with E_DISKFULL and return.
	}

	//update rootBlock member field of the class with the block number of rootBlock.
		
	//update the rootBlock field of the attribute cache using <a href="cache.html#setattrcatentry" target="_blank">OpenRelTable::setAttrCatEntry()</a>.

	//let the relCatBuf hold the relation catalog entry corresponding to relid.
	RelCatEntry relCatBuf;
	
	//load the relation catalog entry into relCatBuf using <a href="cache.html#getrelcatentry" target="_blank">OpenRelTable::getRelCatEntry()</a>.
	
	/*get the first record block of the relation, number of attributes of the relation and number of slots
	  in a record block of the relation in variables block, numAttr and numSlots respectively from relation catalog.*/
	int block;
	int numAttr;
	int numSlots;
	
	//let attrOffset hold the offset of the attribute in the relation; obtained from attribute catalog
	int attrOffset;
	
	/******Traverse all the blocks in the relation and insert them one by one into the B+ Tree******/
	while(block != -1) {	
		
		//load the the block of the relation into recBlock using <a href="buffer.html#recbuff_constructor2" target="_blank">RecBuffer::RecBuffer()</a>.
		RecBuffer recBlock(block);
		
		//let slotMap hold the slot map of the block.
		unsigned char slotMap[numSlots];
		
		//load the slot map into slotMap using <a href="buffer.html#getslotmap" target="_blank">RecBuffer::getSlotMap()</a>.
		
		for slot = 0 to (numSlots - 1):
		{
			if(slotMap[slot] == '1') //occupied slot.
			{				
				//let rec hold the contents of the record.
				union Attribute rec[numAttr];
			
				//load the record corresponding to the slot into rec using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a>.
				
				//let recordId hold the record id {block, slot}.
				struct recId recordId;

				//insert the attribute value of the record corresponding to attrName using <a href="#insert">bPlusInsert</a>.
				status = bPlusInsert(rec[attrOffset], recordId);
			
				if(status == <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>) //disk is full, i.e,  unable to get enough blocks to build the B+ Tree.
					//update the rootBlock member field of the class with <a href="../constants.html#errors" target="_blank">E_DISKFULL</a> and return.
			}
		    else //all records in the relaton has been traversed.
				break;
		}
		
		//let blockHead be used to hold the header of block.
		HeadInfo blockHead;
		
		//load the header of recBlock into blockHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//update the block to the next block in the linked list.		
	}	
}</code></pre>
								</div>
                   			</div>
							 <p><b>NOTE:</b> 
								<ul>
									<li>Creating an object of BPlusTree for an attribute in a relation may not create a B+ Tree for that attribute. This situation arises when the disk runs out of memory during insertion of the entries of relation into the B+ Tree. In such a case, the <i>rootBlock</i> of the object instance will be set to -1. Any operation on the B+ Tree must ensure that the object instance has a valid <i>rootBlock</i>. </li>
								</ul>
							</p>
                        </div>
			<!----Constructor ends --->	
				</li>
			    
			    <li>
			
<!-----------------------------------BPlusDestroy------------------------------------------------------------------------------------>                       
                        <div id="destroy" class="details">
                        	<h2>private: bPlusDestroy</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>blockNum</td>
		                    			<td>int</td>
		                    			<td>Block number of the index block to be destroyed.</td>
		                			</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
										<td><a href="../constants.html#errors" target="_blank">SUCCESS</a></td>
		                        		<td>Successful deletion of index block.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
		                    		    <td>Input blockNum is outside the valid range of block numbers.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_INVALIDBLOCK</a></td>
		                    		    <td>Input blockNum do not correspond to an index block.</td>
		                    		</tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to delete a B+ Tree. The caller passes the root block of the B+ Tree as input to the method. The method recursively deletes the constituent index blocks, both <a href="../storage-model.html#intind_blk" target="_blank">internal</a> and <a href="../storage-model.html#leafind_blk">leaf</a> index blocks, until the full B+ Tree is deleted. This method is private and is only called in a situation where no further disk blocks can be allotted during the <a href="#constructor">creation of</a>/ <a href="#insert">insertion to</a> a B+ Tree. This means that under normal circumstances, NITCbase does not allow the deletion of a B+ Tree once created.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-destroy"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-destroy" class="collapse">
                            	<div class="code"><pre><code>int BPlusTree::bPlusDestroy(int blockNum)
{
	if blockNum lies outside the valid range [0,<a href="../constants.html#constants" target="_blank">DISK_BLOCKS</a>-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if type of the block, obtained using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a>, is <a href="../constants.html#constants" target="_blank">IND_LEAF</a>:
	{
		//let leafBlk be used to hold block of blockNum using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leafBlk(blockNum);
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
	}
	else if type of the block is <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>:
	{
		//let internalBlk be used to hold block of blockNum using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		IndInternal internalBlk(blockNum);
		
		//let internalHead be used to store header of internalBlk.
		HeadInfo internalHead;
		
		//load the header using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//let entry be used to hold an entry of the internalBlk.
		InternalEntry entry;
		
		/*iterate through all the entries of the internalBlk and destroy the lChild of the first entry and rChild
		of all entries using <a href="#destroy" target="_blank">BPlusTree::bPlusDestroy()</a>. 
		(take care not to delete overlapping children more than once)*/
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
		
	}
	else //block is not an index block.
	{
		return E_INVALIDBLOCK;
	}
		
}
</code></pre>
								</div>
                            </div>
							<p><b>NOTE:</b> 
								<ul>
									<li>The caller is responsible for updating the <i>rootBlock</i> field in the corresponding attribute catalog to -1 after deletion.</li>
									<li>The caller is also responsible for setting the <i>rootBlock</i> member field of the B+ Tree object instance to -1 after  deletion.</li>
								</ul>
							</p>
                        </div>
	    <!-----Destroy ends here----->
			    </li>
		    
			    
			    <li>
			    
<!-- -------------------------------bPlusInsert-------------------------------------------------------------------------------- -->                        
                        <div id="insert" class="detail">
                        	<h2>public: bPlusInsert</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	
								    <tr>
								        <td>val</td>
									    <td><a href="buffer.html#block_structures_attribute" target="_blank" >union Attribute</a></td>
								        <td>Attribute value corresponding to <i>attrName</i> in the target record.</td>
								    </tr>
								    <tr>
								        <td>recordId</td>
								        <td><a href="buffer.html#recid" target="_blank" >recId</a></td>
										<td>The record id of the target record whose <i>Index</i> entry is to be inserted into B+ Tree.</td>
								    </tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
										<td><a href="../constants.html#errors" target="_blank">SUCCESS</a></td>
						                <td>Successful insertion of <i>Index</i> entry into B+ tree.</td>
						            </tr>
						            <tr>
								    <td><a href="../constants.html#errors" target="_blank">E_NOINDEX</a></td>
										<td>B+ Tree does not exist for <i>attrName</i>.</td>
						            </tr>
						            <tr>
								    <td><a href="../constants.html#errors" target="_blank">E_DISKFULL</a></td>
						                <td>Disk space insufficient for insertion of <i>Index</i> entry into B+ tree.</td>
						            </tr>
		                     	</table>
		             		</div>
			    			<h5>Description:</h5>
                            <p>Inserts a <a href="buffer.html#block_structures_index" target="_blank">struct Index</a> entry corresponding to the input attribute value and record id into the B+ tree. The disk might run out of memory during the insertion of the <i>Index</i> entry in which case the entire B+ Tree is destroyed.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-insert"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-insert" class="collapse">
                            	<div class="code"><pre><code>int BPlusTree::bPlusInsert(union Attribute val,recId recordId)
{
    //let attrCatBuf store the attribute catalog cache entry for attrName.
    AttrCatEntry attrCatEntry;

    //get the attribute catalog cache entry of <i>attrName</i> using <a href="cache.html#getattrcatentry" target="_blank">OpenRelTable::getAttrCatEntry()</a>.
	int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatEntry);
	
    if(status != <a href="../constants.html#errors" target="_blank">SUCCESS</a>)
    	return status;
    
    //store the rootBlock of B+ Tree in blockNum. 
    int blockNum;
    
    if invalid blockNum: //B+ Tree does not exist for <i>attrName</i>.
	{
    	return <a href="../constants.html#errors" target="_blank">E_NOINDEX</a>;
    }
	
    //store type of attribute in attrType.
    int attrType;
   
   	/*let block be a buffer of type IndBuffer; as IndBuffer is the parent class of IndLeaf and IndInternal, 
	  block can be used to store a disk block of either type.*/
    class IndBuffer *block;
    
	//let blockHeader be used to hold the header of block.
    HeadInfo blockHeader;
	
	/******Traverse the B+ Tree to reach the appropriate leaf where insertion can be done******/
    while block is not of the type <a href="../constants.html#constant" target="_blank">IND_LEAF</a>: // <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a> can be used.
	{
	
    	//load the block using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
        block = new IndInternal(blockNum);
        
        //load header of block into blockHeader using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
        
        //store number of entries in block, obtained from blockHeader, in nEntries.
        int nEntries;
        
        /*iterate through all the entries, to find first the entry whose attibute value >= value to be inserted.
         NOTE: the helper function compare() can be used to compare two Union Attribute values based on attrType.*/
        
        if no such entry is found: 
		{      
        	//update blockNum with rChild of nEntries-1'th (i.e. last) entry of the block.  
        	
			delete block;
        }      
        else 
		{
         	//update blockNum with lChild of the entry of block.
         	
			delete block; 
         }
    }

    //NOTE: now blockNum is the leaf index block to which insertion of val is to be done.
    
    /******Insertion of entry in the appropriate leaf block******/
    
    //load the block using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
    block = new IndLeaf(blockNum);
    
	//load header of the block into blockHeader using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.

    //let indexval be used to store the Index entry to be inserted into B+ Tree.
    Index indexval;
	
    //update indexval with as that of recid, val.

    //let indices be an array of struct Index of size blockHeader.numEntries+1.
    Index indices[blockHeader.numEntries+1];
    
    /*iterate through all the entries in the block and copy them to the array indices. 
	Also insert indexval at appropriate position in the indices array.*/
    
    if (blockHeader.numEntries != 63) //leaf block has not reached max limit.
    {
        //increment blockHeader.numEntries and set this as header of block using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>. 
        
        //iterate through all the entries of indices array and populate the entries of block with them using <a href="buffer.html#indbuff_class" target="_blank">IndLeaf::setEntry()</a>.
        
        delete block;
        
        return <a href="../constants.html#errors" target="_blank">SUCCESS</a>;
    } 
    else //leaf block is full- need a new leaf to make the entry; split the entries between the two blocks.
    {
    	//obtain new leaf index block to be used as the right block in the splitting <a href="buffer.html#leafsetentry" target="_blank">IndLeaf::IndLeaf()</a>.
        class IndBuffer * newRightBlk = new IndLeaf();
        
        //assign the existing block as the left block in the splitting.
        class IndBuffer * leftBlk = block;
        
		/*store the block numbers of both blocks in variables newRightBlkNum and leftBlkNum 
		  using  <a href="buffer.html#getblocknum" target="_blank">BlockBuffer::getBlockNum()</a>.*/
        int newRightBlkNum;
        int leftBlkNum;
		
        if(newRightBlkNum == <a href="../constants.html#errors" target="_blank">FAILURE</a>) //failed to obtain an empty leaf index becauase the disk is full.
		{
				//destroy the existing B+ tree by passing <i>rootBlock</i> member field to <a href="#destroy">bPlusDestroy()</a>.
				
				//update <i>rootBlock</i> member field to <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>;
				
				//update the rootBlock of attribute catalog cache entry to -1 using <a href="cache.html#setattrcatentry" target="_blank">OpenRelTable::setAttrCatEntry()</a>.
				
				return <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>;
        }
        
		//let leftBlkHeader be the header of the left block(which is presently stored in blockHeader)
        struct HeadInfo leftBlkHeader = blockHeader;
		
		//store the block after leftBlk that appears in the linked list in prevRblock.
		int prevRblock = leftBlkHeader.rblock;
			
        /*update number of enteries in leftBlkHeader as 32 and its rblock as newRightBlkNum
		  using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>.*/

		//let newRightBlkHeader be the header of the right block.
		struct HeadInfo newRightBlkHeader;

		//load the header of newRightBlk in newRightBlkHeader using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
        /*update number of enteries in newRightBlkHeader as 32, its pblock as the pblock of leftBlk, 
		  its lblock as leftBlkNum and its rblock as prevRblock using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a> and <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>.*/

     	/*set the first 32 entries of leftBlk as the first 32 entries of indices array 
   		  and set the first 32 entries of newRightBlk as the next 32 entries of indices array using <a href="buffer.html#indbuff_class" target="_blank">IndLeaf::setEntry()</a>..*/

        //store pblock of leftBlk in parBlkNum.
        int parBlkNum;
        
        delete leftBlk;
        delete newRightBlk; 
        
        /*store the attribute value of indices[31] in newAttrval; 
		  this is attribute value which needs to be inserted in the parent block.*/
        union Attribute newAttrval;
		
		/******Traverse the internal index blocks of the B+ Tree bottom up making insertions wherever required******/

		//let done indicate whether the insertion is complete or not.
        bool done = false;
        
        while(!done)
		{
        	if (parBlkNum != -1) //parBlkNum is a valid parent block.
			{
				//load the block corresponding to parBlkNum to parblk using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
				class IndInternal *parblk= new IndInternal(parBlkNum);

				//let parheader be used to store the header of parblk.
				struct HeadInfo parheader;

				//load parheader with header of parblk using  <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.

				//let internalEntries be an array of <i>struct InternalEntries</i> of size parheader.numEntries+1.
				struct InternalEntry internalEntries[parheader.numEntries+1];

				/*iterate through all the entries of the parblk and copy them to the array internalEntries.
				  Also insert an InternalEntry entry with attrVal as newAttrval, lChild as leftBlkNum,
				  and rChild as newRightBlkNum at an appropriate position in the internalEntries array.*/

				if(parheader.numEntries != 100) //parblk has not reached max limit.
				{
					//increment parheader.numEntries and update it as header of parblk using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>. 

					//iterate through all entries in internalEntries array and populate the entries of parblk with them using <a href="buffer.html#intsetentry" target="_blank">IndInternal::setEntry()</a>.

					delete parblk;

					//set done to true;
					
				}
				else  /*the parent internal index is full- need a new internal index to make the entry; 
						split the entries between the two blocks*/
				{
					//obtain a new internal index block in dummy using <a href="buffer.html#intindbuff_constructor1" target="_blank">IndInternal::IndInternal()</a>.
			    	class IndInternal* dummy = new IndInternal();

			    	if(dummy->getBlockNum() == <a href="../constants.html#errors" target="_blank">FAILURE</a>) //failed to obtain an empty internal index becauase the disk is full.
					{
						//destroy the right subtree, given by newRightBlkNum, build up till now that has not yet been connected to the existing B+ Tree, using <a href="#destroy">bPlusDestroy()</a>.
						
						//destroy the existing B+ tree by passing <i>rootBlock</i> member field to <a href="#destroy">bPlusDestroy()</a>.
						
						//update <i>rootBlock</i> member field to <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>;
						
						//update the rootBlock of attribute cache entry to -1 using <a href="cache.html#setattrcatentry" target="_blank">OpenRelTable::setAttrCatEntry()</a>.
						
						return <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>;
			     	}

			    	//assign dummy as the left block in the splitting.
			    	newRightBlk= (class IndInternal* )dummy;

			        //assign parblk as the right block in the splitting.
			        leftBlk= (class IndInternal* )parblk;

			        //update leftBlkNum with parBlkNum.
					
					//udpate newRightBlkNum with block number of newRightBlk using <a href="buffer.html#getblocknum" target="_blank">BlockBuffer::getBlockNum()</a>.

			        //update leftBlkHeader with parheader.

			        //update number of enteries of leftBlkHeader as 50 using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>.

			        //update number of enteries of newRightBlkHeader as 50 using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a> and <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>.

			    	/*set the first 50 entries of leftBlk as the first 50 entries of internalEntries array and 
					  set the first 50 entries of newRightBlk as the entries from 51 to 100 of internalEntries array 
					  using <a href="buffer.html#intsetentry" target="_blank">IndInternal::setEntry()</a>.*/

			        IndBuffer *childBuff;
			    	struct HeadInfo childBuffHead;

			    	/*store the block type of a child of any entry (say, the rchild of 50th entry) of the 
					  internalEntries array in type, using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a>.*/
			    	int type;

			     	//iterate from 50 to 100:
					{
						//assign the rchild block of ith index in internalEntries of the appropriate type to childBuff.
						if(type == <a href="../constants.html#constants" target="_blank">IND_LEAF</a>)
							childBuff = (IndBuffer*) new IndLeaf(internalEntries[i].rChild);
						 else
							childBuff = (IndBuffer*) new IndInternal(internalEntries[i].rChild);

						/*update pblock of the childBuff block to newRightBlkNum using
						  <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a> and <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a>.*/

						delete childBuff;                    
			    	}

			    	delete leftBlk;
			    	delete newRightBlk;

			    	//update parBlkNum as the pblock of leftBlk.

			    	/*update newAttrval to the attribute value of 50th entry in the internalEntries array; 
					  this is attribute value which needs to be inserted in the parent block.*/
				}
            }		
        	else  //when parBlkNum is invalid.
			{
				//NOTE: Need to allot a new block which would be the root of the B+ Tree.

				//load a new internal index block to newRootBlk using <a href="buffer.html#intindbuff_constructor1" target="_blank">IndInternal::IndInternal()</a>.
				class IndInternal* newRootBlk = new IndInternal();

				//store the block number of newRootBlk in newRootBlkNum using <a href="buffer.html#getblocknum" target="_blank">BlockBuffer::getBlockNum()</a>.
				int newRootBlkNum;

				if(newRootBlkNum == <a href="../constants.html#errors" target="_blank">FAILURE</a>) //failed to obtain an empty internal index block becauase the disk is full.
				{
					
					//destroy the right subtree, given by newRightBlkNum, build up till now that has not yet been connected to the existing B+ Tree, using <a href="#destroy">bPlusDestroy()</a>.
						
					//destroy the existing B+ tree by passing <i>rootBlock</i> member field to <a href="#destroy">bPlusDestroy()</a>.

					//update <i>rootBlock</i> member field to <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>.

					//update the rootBlock of attribute cache entry to -1 using <a href="cache.html#setattrcatentry" target="_blank">OpenRelTable::setAttrCatEntry()</a>.

					return <a href="../constants.html#errors" target="_blank">E_DISKFULL</a>;
				}

				//let newRootHeader be the header of newRootBlk.
				struct HeadInfo newRootHeader;

				//update number of enteries in newRootBlk as 1 using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a> and <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.

				/*add the <i>struct InternalEntry</i> entry with lChild as leftBlkNum, attrVal as newAttrval,
				  and rChild as newRightBlkNum as the first entry to newRootBlk using <a href="buffer.html#intsetentry" target="_blank">IndInternal::setEntry()</a>.*/

				/*update the pblock of blocks corresponding to both leftBlkNum and newRightBlkNum to newBlkNum
				  using <a href="buffer.html#setheader" target="_blank">BlockBuffer::setHeader()</a> and <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
				  NOTE : the type of leftBlkNum and newRightBlkNum has to be checked first before 
				  loading it into leftBlk and newRightBlk with appropriate IndLeaf or IndInternal instances. */

				//update rootBlock of attribute catalog cache entry as newBlkNum using <a href="cache.html#setattrcatentry" target="_blank">OpenRelTable::setAttrCatEntry()</a>.

				delete newRootBlk;

				//set done to true.
			}
		}
	}
	return SUCCESS;		
 }</code></pre>
                            	</div>
                            </div>
							<p><b>NOTE:</b> 
								<ul>
									<li>During insertion of an entry to B+ Tree, the disk may run out of memory. In such a case, the existing B+ Tree will be destroyed, and the <i>rootBlock</i> of the object instance will be set to -1. Any operation on the B+ Tree must ensure that the object instance has a valid <i>rootBlock</i>. </li>
								</ul>
							</p>
                        </div>		
	<!---Insert ends here--->			    
			    </li>
			    
			    <li>
				
<!-- -------------------------------BPlusSearch-------------------------------------------------------------------------------- -->                                                
                        <div id="search" class="detail">
                        	<h2>public: BPlusSearch<h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
									<tr>
								        <td>attrVal</td>
										<td><a href="buffer.html#block_structures_attribute" target="_blank">union Attribute</a></td>
								        <td>Attribute that is to be checked against the operater.</td>
								    </tr>
									<tr>
								        <td>op</td>
								        <td>int</td>
								        <td>One amongst the 6 relation operators(EQ, LE, LT, GE, GT, NE corresponds to equal, less than equal, less than, greater than equal, greater than, not equal operators respectively).</td>
									</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>recordId</td>
										<td><a href="buffer.html#recid" target="_blank">Record id</a> of the first/ next block entry in the relation that satisfies <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
						            <tr>
						                <td>Invalid recordId {-1,-1}</td>
										<td>No first/ next block entry found satisfisying <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to search the first/ next record entry in the relation that satisfies the relational operation for the input attribute value. The method makes use of the <i>prevIndexid</i> field of the attribute in the <a href="cache.html" target="_blank">Attribute Catalog Cache</a> for this purpose. It holds the <a href="buffer.html#indexid" target="_blank">index id</a> of the entry in the leaf block of the B+ Tree that corresponded to a hit in the previous search. The search is resumed from the next index entry. An invalid index id means that the search is being done for the first time.</p>
                            <h5><a data-toggle="collapse" href="#algo-search"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-search" class="collapse">
                            	<div class="code"><pre><code>struct RecId BPlusTree::BPlusSearch(union Attribute attrVal, int op){
	
	//let prevIndexid be used to store previous index id for attrName.
	IndexId prevIndexid;
	
	//get the previous index id from the attribute cache using the <a href="cache.html#getprevindexid" target="_blank">OpenRelTable::getPrevIndexId()</a>.
	
	//reset the previous index id to {-1,-1} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>.
	  (this will be set to the correct index id if an entry satisfying op for given attrVal is found in the course
	   of the search.)
	
	//let attrcatEntry be used to store the attribute cache entry for attrName.
	AttrCatEntry attrcatEntry;
	
	//load the attribute cache entry using <a href="cache.html#getattrcatentry" target="_blank">OpenRelTable::getAttrCatEntry()</a>.
	
	//store root block num and attribute type of the B+ Tree in rootBlock and attrType respectively.
	int rootBlock;
	int attrType;
	
	//let block and index variables be used to locate the entry to be searched.
	int block, index;
	
	if prevIndexid=={-1,-1}:
	{
		//NOTE: an invalid prevIndexid means that the search is done for the first time.
		
		block = rootBlock;
		index = 0; //start the search from the root.
	}
	else 
	{
		/*NOTE: a valid prevIndexid points to an entry in the leaf index of the attribute's B+ Tree which had 
		  previously satisfied the op for the given attrVal.*/
		
		block = prevIndexid.block;
		index = prevIndexid.index + 1; //search is resumed from the next index.
		
		//load block into leaf using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leaf(block);
		
		//let leafHead be used to hold the header of leaf.
		HeadInfo leafHead;
		
		//load header into leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		if index exceeds the maximum number of entries present in the leaf index block: 
		//all the entries in the block has been searched; search from the beginning of the next leaf index block.
		{
					
			//update block to rblock of current block and index to 0.
			
			if(block == -1) //end of linked list reach - the search is done.
			{
				//return the recId {-1, -1};
			}	
			
		}
	}
	
	//let internalBlk be used to store an internal index block.
	IndInternal * internalBlk;
	
	//let intHead be used to store the header of the internalBlk.
	HeadInfo intHead;
	
	//let intEntry be used to store an internal entry of the internalBlk.
	InternalEntry intEntry;
	
	/*let cond be used to decide which child to search.
	  if 1 move to left child else move to right child after going through all the internal entries.*/
	int cond;
	
	/******Traverse through all the internal nodes according to value of AttrVal and the operator op******/
	while block is of type <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>: { //checked using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a>.
			
		//load the block into internalBlk using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		internalBlk = new IndInternal(block);
		
		//load header to intHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//set cond to 0(condition not met)
		
		for i from 0 to (numEntries in  block - 1):
		{
			//load entry in block corresponding to slot i into intEntry using <a href="buffer.html#intgetentry" target="_blank">IndInternal::getEntry()</a>.
		
			int flag = comparison between intEntry's attribute value and the input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
		
			/*NOTE: the B+ Tree has been constructed in such a way that if an internal index has an attribute value 
			satisying the op (except for the NE op) for the given attrVal, then there is atleast one entry in its 
			left child that also satisfies op.*/
			switch(op){
				case  EQ:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case LE:
					/*the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. 
					Values that satisfy LE condition, if any exist,  will always be found in the left-most leaf index. 
					Thus, always move to the left.*/
					cond = 1;
					break;
				case LT:
					/*the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. 
					Values that satisfy LT condition, if any exist,  will always be found in the left-most leaf index. 
					Thus, always move to the left.*/
					cond = 1;
					break;
				case GE:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case GT:
					if(flag >0) //move to the left child of the first entry that is greater than the attrVal.
						cond = 1;
					break;
				case NE:
					/*need to search the entire linked list of leaf indices of the B+ Tree, starting 
					from the leftmost leaf index. Thus, always move to the left.*/
					cond = 1;
					break;
			}
		
			if(cond == 1) //op condition met; proceed to search in the left child.
			{
				//update block to left child of intEntry;
				
				delete internalBlk;
				
				break;
			}
		}
		
		if(cond == 0) /*traversed all the entries of internalBlk without satisfying op condition; 
						proceed to search the right child.*/
		{	
			//update block to right child of intEntry;

			delete internalBlk;
		}
	}
	
	//NOTE: the block is now a leaf index block.
	
	//let leafBlk be used to store an leaf index block.
	IndLeaf * leafBlk;
	
	//let leafHead be used to store the header of the leafBlk.
	HeadInfo leafHead;
	
	//let leafEntry be used to store an index entry of the leafBlk.
	Index leafEntry;
	
	/*used to store the state of search; 
	cond = 0: not found but need to search more; cond = 1: got a right answer; cond = -1 : stop searching.*/
	cond = 0;
	
	/******Traverse through index entries in the leaf index block from the index entry numbered as index******/
	while(block !=-1) {
	
		//load the block into leafBlk using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		leafBlk = new IndLeaf(block);
		
		//load the header to leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		while (index < numEntries in leafBlk) { //numEntries can be obtained from leafHead.
			
			//load entry corresponding to block and slot into leafEntry using <a href="buffer.html#leafgetentry" target="_blank">IndLeaf::getEntry()</a>.
			
			int flag = comparison between leafEntry's attribute value and input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
			
			switch(op){
				case  EQ:
					if(flag == 0) //entry satisfying EQ condition found.
						cond = 1;
					else if(flag > 0) /*future entries will not satisfy EQ conditions as the values 
										are arranged in ascending order in the leaves.*/
						cond = -1;
					break;
				case LE:
					if(flag <= 0) //entry satisfying LE condition found.
						cond = 1;
					else /*future entries will not satisfy LE conditions as the values are arranged in
						   ascending order in the leaves.*/
						cond = -1;
					break;
				case LT:
					if(flag < 0) //entry satisfying LT condition found.
						cond = 1;
					else /*future entries will not satisfy LT conditions as the values are arranged in 
						   ascending order in the leaves.*/
						cond = -1;
					break;
				case GE:
					if(flag >= 0) //entry satisfying GE condition found.
						cond = 1;
					break;
				case GT:
					if(flag > 0) //entry satisfying GT condition found.
						cond = 1;
					break;
				case NE:
					if(flag != 0) //entry satisfying NE condition found.
						cond = 1;
					break;
			}
			if(cond == 1){ //an entry satisying op for the given attrVal found.
			
				//set previous index id to {block, index} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>.
				
				delete leafBlk;
				
				//return the recId {leafEntry.block, leafEntry.slot}.
			}
			else if(cond == -1){ //no entry satisfies op for the given attrVal.
				
				delete leafBlk;
				
				//return the recId {-1,-1}.
			}
			
			//search next index.
			++index;
		}
		
		if(op!=NE) 
		/*only for NE do we have to check the entire linked list;
		for all the other op it is guaranteed that the block being searched will have an entry,if it exists, 
		satisying that op.*/
			break;
		
		//block = next block in the linked list, i.e., the rblock in the leafHead.
		
		delete leafBlk;
		
		//update index to 0.
	}
	
	delete leafBlk;
	
	//no entry satisying the op was found; return the recId {-1,-1}
}</code></pre>
                            	</div>
                            </div>
                        </div>                            
            
		<!--------Search rnds here--->		    
			    </li>
				</ul>

			</div>
			
			    
			    
	                          
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

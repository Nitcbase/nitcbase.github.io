<!DOCTYPE HTML>
<html>

<head>
    <title>B+ Tree Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                            <ul class="nav flex-column sidemenu">
                                <li> <a class="sec" href="#create"> B+ Create</a></li>
                                <li> <a class="sec" href="#destroy"> B+ Destroy</a></li>
                                <li> <a class="sec" href="#insert"> B+ Insert</a></li>
                                <li> <a class="sec" href="#search"> B+ search</a></li>
                            </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>B+ Tree Layer</h1>
                        </div>
                        
                        <div class="detail">
				<h5>Pre-requisite Reading : <a href="./indexing.html">Indexing in NITCbase</a></h5>
                        	<p>As you might already know, we use indexing to reduce disk access and to implement search queries faster. NITCBase uses B+ Tree for indexing an attribute in a relation. To implement B+ Tree layer you must require a thorough understanding of the Physical layer, Buffer layer and Cache layer.
                        	</p>
                        </div>
                        
                         <div id="create" class="detail">
                            <h2>B+ Create</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>relid</td>
		                    			<td>int</td>
		                    			<td>Relation Id of Relation in which target attribute is contained.</td>
		                			</tr>
		                			<tr>
		                    			<td>attrname</td>
		                    			<td>char[ATTR_SIZE]</td>
		                    			<td>name of attribute to which bplus tree has to be created.</td>
		                			</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                        		<td>SUCCESS</td>
		                        		<td>On successul creation of tree</td>
		                    		</tr>
		                    		<tr>
		                        		<td>E_DISKFULL</td>
		                        		<td>If there is no enough space in disk to create the tree</td>
		                    		</tr>
		                     	</table>
		                     </div>
		                     
		                     <h5>Description:</h5>
		                     <p>This method create the bplus-tree(Indexing) on the attribute of a relation specified in the arguments.</p>
		                     
		                     <h5><a data-toggle="collapse" href="#algo-create"><span class="fas fa-code"></span>Algorithm:</a></h5>
                             <div id="algo-create" class="collapse">
                            	<div class="code"><pre><code>int bplus_create(relId relid, char attrName[ATTR_SIZE]){
	/*get the root block from the attribute cache correponding to the
	  relation with Id relid and the attribute with attribute name attrName*/
	  
	if(root_block != -1){ //Index already exists for the attribute
		return SUCCESS;
	}
	
	//get the free leaf index for the root block
	leaf_buffer = Buffer::<a href="buffer.html#getfreeindleaf" target="_blank">getFreeIndLeaf</a>();
	if(leaf_buffer == NULL){ //disk is full (i.e unable to get new record block from the disk)
		return E_DISKFULL;
	}
	
	//get the root block number corresponding to the leaf_buffer (free leaf index) from the buffer
	root_block = leaf_buffer->getBlockNum();
	
	/*update the root block in the attribute cache correponding to the
	  relation with Id relid and the attribute with attribute name attrName*/
	  
	//Iterate over all the records of the relation with Id relid{
		//insert the index entries for each record in the bplus tree
		flag = bplus_insert(relid, attrName, attrval, recid); //where the recid is record id corresponding to the record
		if(flag == E_DISKFULL){ //unable to insert the record in bplus tree since disk is full
			//destroy all the index blocks created so far corresponding to the record
			bplus_destroy(root_block);
			return E_DISKFULL;
		}
	//}
	
	return SUCCESS;        
}</code></pre>
								</div>
                            </div> 
                        </div>
                        
                        <div id="destroy" class="details">
                        	<h2>B+ Destroy</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>blockNum</td>
		                    			<td>int</td>
		                    			<td>Block number of the index block which is to be destroyed.</td>
		                			</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
										<td><a href="../constants.html#errors" target="_blank">SUCCESS</a></td>
		                        		<td>Successful deletion of index block.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
		                    		    <td>Input blockNum is outside the valid range of block numbers.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_INVALIDBLOCK</a></td>
		                    		    <td>Input blockNum do not correspond to an index block.</td>
		                    		</tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to delete a B+ Tree. The caller passes the root block of the B+ Tree as input to the method. The method recursively deletes the constituent index blocks, both <a href="../storage-model.html#intind_blk" target="_blank">internal</a> and <a href="../storage-model.html#leafind_blk">leaf</a> index blocks, until the full B+ Tree is deleted. This method is private and is only called in a situation where no further disk blocks can be allotted during the <a href="#create">creation of</a>/ <a href="#insert">insertion to</a> a B+ Tree. This means that under normal circumstances, NITCbase does not allow the deletion of a B+ Tree once created.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-destroy"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-destroy" class="collapse">
                            	<div class="code"><pre><code>int BplusTree::bplusDestroy(int blockNum){

	if blockNum lies outside the valid range [0,<a href="../constants.html#constants" target="_blank">DISK_BLOCKS</a>-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if type of the block obtained using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a> is <a href="../constants.html#constants" target="_blank">IND_LEAF</a>:
	{
		//let leafBlk be used to hold block of blockNum using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leafBlk(blockNum);
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
	}
	else if type of the block is <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>:
	{
		//let internalBlk be used to hold block of blockNum using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		IndInternal internalBlk(blockNum);
		
		//let internalHead be used to store header of internalBlk.
		HeadInfo internalHead;
		
		//load the header using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//let entry be used to hold an entry of the internalBlk.
		InternalEntry entry;
		
		/*iterate through all the entries of the internalBlk and destroy the lChild of the first entry and rChild of all entries using <a href="#destroy" target="_blank">BplusTree::bplusDestroy()</a>. (take care not to delete overlapping children more than once)*/
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
		
	}
	else //block is not an index block.
	{
		return E_INVALIDBLOCK;
	}
		
}
</code></pre>
								</div>
                            </div>
							<p><b>NOTE:</b> 
								<ul>
									<li>The caller is responsible for updating the <i>rootBlock</i> field in the corresponding attribute catalog to -1 after deletion.</li>
									<li>The caller is also responsible for setting the <i>rootBlock</i> member field of the B+ Tree object instance to -1 after  deletion.</li>
								</ul>
							</p>
                        </div>
                        
                        <div id="insert" class="detail">
                        	<h2>B+ Insert</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
								        <td>relid</td>
								        <td>int</td>
								        <td>Relation Id of Relation containing the target bplus tree.</td>
								    </tr>
								    <tr>
								        <td>attrName</td>
								        <td>char[ATTR_SIZE]</td>
								        <td>Name of attribute corresponding to target bplus tree.</td>
								    </tr>
								    <tr>
								        <td>attrval</td>
								        <td>union Attribute</td>
								        <td>value corresponding to attrName attribute of target record that need to be inserted in to bplus tree.</td>
								    </tr>
								    <tr>
								        <td>recid</td>
								        <td>RecId</td>
								        <td>RecId of target record that need to be inserted in to bplus tree.</td>
								    </tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>SUCCESS</td>
						                <td>On successful insert of the recid.</td>
						            </tr>
						            <tr>
						                <td>E_NOINDEX</td>
						                <td>If B+ tree has not been created on the given attribute.</td>
						            </tr>
						            <tr>
						                <td>E_DISKFULL</td>
						                <td>If disk space is not sufficient to insert into the B+ tree.</td>
						            </tr>
		                     	</table>
		                   	</div>
							<h5>Description:</h5>
                            <p>This method inserts the <i>Index</i> of the record into bplus tree corresponding to the attribute of a relation as specified in the arguments.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-insert"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-insert" class="collapse">
                            	<div class="code"><pre><code>int bplus_insert(int relid,char attrname[ATTR_SIZE],union Attribute val,recId rec_id){
    //get the AttrCatEntry of target attribute using <a href="cache.html#getattrcatentry" target="_blank">getAttrCatEntry</a>() of cache layer.
    //let root_block_num be the root_block of AttrCatEntry 
    //if root_block_num of target attribute is -1, return E_NOINDEX
    //let attr_type be int (storing type of AttrCatEntry)
    class IndBuffer *head=Buffer::<a href="buffer.html#getindblk" target="_blank">getIndBuffer</a>(root_block_num);
    /* while head is not LEAF:
          let header be of type struct HeadInfo 
          update header with HeadInfo of head using <a href="buffer.html#getheader" target="_blank">getHeader</a>() method of blockbuffer class.
          
          let nEntries be no. of entries in head block(can be found from header)
          
          iterating through 0 to nEntries-1, to get the offset i, such that 'i' is the min. offset satisfying
          i'th entry value &gt;= val  //helper function compare() can be used to compare two Union attribute values, based on attr_type.

          if no such offset is found:
              update root_block_num with value of rchild of nEntries-1'th(last) entry of head.
              free the head object
              head=Buffer::<a href="buffer.html#getindblk" target="_blank">getIndBuffer</a>(root_block_num);
          else:
              update root_block_num with value of lchild of i'th entry of head.
              Delete head. (calls destructor)
              head=Buffer::<a href="buffer.html#getindblk" target="_blank">getIndBuffer</a>(root_block_num);
    */

    //now head is the leaf block to which we need to insert Index into.
    
    /*let indexval be of type struct Index(Index which need to be inserted in to b+ tree)
    update indexval with as that of recid, val.*/

    //update header with HeadInfo of block pointed by head using <a href="buffer.html#getheader" target="_blank">getHeader</a>() method of blockbuffer class.
    //let nEntries be no. of entries in block pointing by head(can be found from header)

    //let indices[nEntries+1] be an array of type struct Index.

    //iterate through 0 to nEntries-1:
        //update the i'th entry of indices with ith entry in head, using head-&gt;<a href="buffer.html#leafgetentry" target="_blank">getEntry</a>() method.

    //do linear search on indices to know the position of val in leaf.
    //insert indexval appropriately into indices array.

    /*
    if nEntries!= 63 ( max. no of entries in leaf)
        //iterate through 0 to nEntries-1:
           //set the i'th entry of head with ith entry in indices array, using head-&gt;<a href="buffer.html#leafsetentry" target="_blank">setEntry</a>() method.

        update header.num_entries=nEntries+1
        set Headinfo of head with as that of header, using head-&gt;<a href="buffer.html#setheader" target="_blank">setHeader</a>() method.
        Delete head. (calls destructor)
        return SUCCESS.
    else:
        class IndBuffer* new_blk=Buffer::<a href="buffer.html#getfreeindleaf" target="_blank">getFreeIndLeaf</a>();
        let newblkheader be of type struct HeadInfo 
        update newblkheader with HeadInfo of new_blk using <a href="buffer.html#getheader" target="_blank">getHeader</a>() method of blockbuffer class.

        iterate through 0 to 31:
            set first 32 entries of indices in to 32 entries of head,
            set next 32 entries of indices in to 32 entries of new_blk
        
        let par_block(int) be the pblock in header.
        
        update header.num_entries=32
        set Headinfo of head with as that of header, using head-&gt;<a href="buffer.html#setheader" target="_blank">setHeader</a>() method.

        update newblkheader.num_entries=32, newblkheader.pblock=par_block
        set Headinfo of new_blk with as that of newblkheader, using new_blk-&gt;<a href="buffer.html#setheader" target="_blank">setHeader</a>() method.

        let new_attrval be of type union Attribute. (which need to be inserted in to parent)
        update new_attrval with attrval of indices[31] (i.e 32nd entry)

        delete head;
        delete new_blk; // delete calls destructor.
        
        int child_block=root_block_num;

        // let done be a bool with value false.
        while(!done):
            if par_block!=-1
                class IndBuffer *parblk=Buffer::<a href="buffer.html#getindblk" target="_blank">getIndBuffer</a>(par_block);
                let parheader be of type struct HeadInfo 
                update parheader with HeadInfo of head using <a href="buffer.html#getheader" target="_blank">getHeader</a>() method of blockbuffer class.

                struct InternalEntries internal_entries[parheader.num_entries+1];
                //iterate through 0 to parheader.num_entries-1:
                    //update the i'th entry of internal_entries with ith entry in parblk, using parblk-&gt;<a href="buffer.html#intgetentry" target="_blank">getEntry</a>() method.


                get the offset of head in par_block, iterating through the internal_entries of par_block (by checking the entry which contain lblock as child_block)
                let tar_ind (int) be the offset of child_block.

                iterating iter from parheader.num_entries to tar_ind+1 (in decreamenting order):
                    internal_entries[iter]=internal_entries[iter-1];
                
                //update the internal_entries[tar_ind] with lchild:child_block,rchild:new_blocknum,attrval=new_attrval
                (update the rchild,lchild of entries adjacent to tar_ind approriately).

                if(parheader.num_entries!=100) //par_block not full
                    update the InternalEntries in parblk with as that of internal_entries array.(using <a href="buffer.html#intsetentry" target="_blank">setEntry</a>() of IndBuffer class)
                    update parheader accordingly and copy this to parblk HeadInfo (using parblk-&gt;<a href="buffer.html#setheader" target="_blank">setHeader</a>() method of blockbuffer class.
                    delete parblk
                    done=true;
                else
                    class IndBuffer* new_blk=Buffer::<a href="buffer.html#getfreeindinternal" target="_blank">getFreeIndInternal</a>();
                    newblkheader=new_blk-&gt;<a href="buffer.html#getheader" target="_blank">getHeader</a>();
                    new_blocknum=new_blk-&gt;getblocknum();
                    
                    iterating through 0 to 50:
                        update parblk,bew_blk such that first 50 entries of internal_entries get into parblk, next 50 into new_blk
                        (use <a href="buffer.html#intsetentry" target="_blank">setEntry</a>() of IndBuffer class)
                    update parheader,newblkheader appropriately
                    update HeadInfo of parblk,new_blk with parheader,newblkheader using <a href="buffer.html#setheader" target="_blank">setHeader</a>() of BlockBuffer class.
                    iterating through 2nd 50 entries of internal_entries
                        update pblock field(in Header) of all child blocks with new_blocknum
                        (load each child using Buffer::<a href="buffer.html#getindblk" target="_blank">getIndBuffer</a>(childblock), update HeadInfo of each block using <a href="buffer.html#setheader" target="_blank">setHeader</a>() of BlockBuffer class)
                    
                    delete parblk,delete new_blk;
                    child_block=par_block,par_block=parheader.pblock;
                    new_attrval=internal_entries[50].attrval;
            else //if par_block==-1
                class IndBuffer* new_head=Buffer::<a href="buffer.html#getfreeindinternal" target="_blank">getFreeIndInternal</a>(); //if fails..delete indexing
                struct HeadInfo newhead_header=new_blk-&gt;<a href="buffer.html#getheader" target="_blank">getHeader</a>();
                int new_hblk_num=new_head-&gt;getblocknum();

                add only entry to new_head with lblock:child_block, rblock:new_blocknum, attrval:new_attrval
                update Headinfo of new_head appropriately (using <a href="buffer.html#setheader" target="_blank">setHeader</a>() of blockBufferclass)
                similarly update headers of child_block, new_blocknum with pblock=new_hblk_num

                get the attribute catalog entry of attribute attr_name(using OpenRelTable::<a href="cache.html#getattrcatentry" target="_blank">getAttrCatEntry</a>(relid,attr_offset,&amp;attrib_cat))
                update root_block of AttrCatEntry with new_hblk_num
                set the attribute catalog entry of attribute attr_name(using OpenRelTable::<a href="cache.html#getattrcatentry" target="_blank">getAttrCatEntry</a>(relid,attr_offset,&amp;attrib_cat)) with updated one.

                delete new_head;
                done=true;
    */
   return SUCCESS;
}</code></pre>
                            	</div>
                            </div>
                        </div>
                        
                        <div id="search" class="detail">
                        	<h2>B+ Search<h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
									<tr>
								        <td>attrVal</td>
										<td><a href="buffer.html#block_structures_attribute" target="_blank">union Attribute</a></td>
								        <td>Attribute that is to be checked against the operater.</td>
								    </tr>
									<tr>
								        <td>op</td>
								        <td>int</td>
								        <td>One amongst the 6 relation operators(EQ, LE, LT, GE, GT, NE corresponds to equal, less than equal, less than, greater than equal, greater than, not equal operators respectively).</td>
									</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td><a href="buffer.html#recid" target="_blank">RecId</a></td>
										<td>Record id of the first/ next block entry in the relation that satisfies <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
						            <tr>
						                <td>Invalid RecId {-1,-1}</td>
										<td>No first/ next block entry found satisfisying <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to search the first/ next record entry in the relation that satisfies the relational operation for the input attribute value. The method makes use of the <i>prevIndexid</i> field of the attribute in the <a href="cache.html" target="_blank">Attribute Catalog Cache</a> for this purpose. It holds the index id of the entry in the leaf block of the B+ Tree that corresponded to a hit in the previous search. The search is resumed from the next index entry. An invalid index id means that the search is being done for the first time.</p>
                            <h5><a data-toggle="collapse" href="#algo-search"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-search" class="collapse">
                            	<div class="code"><pre><code>struct RecId BplusTree::bplusSearch(union Attribute attrVal, int op){
	
	//let prevIndexid be used to store previous index id for attrName.
	IndexId prevIndexid;
	
	//get the previous index id from the attribute cache using the <a href="cache.html#getprevindexid" target="_blank">OpenRelTable::getPrevIndexId()</a>.
	
	//reset the previous index id to {-1,-1} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>; this will be set to the correct index id if an entry satisfying op for given attrVal is found in the course of the search.
	
	//let attrcatEntry be used to store the attribute cache entry for attrName.
	AttrCatEntry attrcatEntry;
	
	//get the attribute cache using <a href="cache.html#getattrcatentry" target="_blank">OpenRelTable::getAttrCatEntry()</a>.
	
	//store root block num and attribute type of the B+ Tree in rootBlock and attrType respectively.
	int rootBlock;
	int attrType;
	
	
	//let block and index variables be used to locate the entry to be searched.
	int block, index;
	
	if prevIndexid=={-1,-1}:
	{
		//NOTE: an invalid prevIndexid means that the search is done for the first time.
		
		block = rootBlock;
		index = 0; //start the search from the root.
		
		if(block == -1) //B+ Tree does not exist for attrName in the relation.
		{
			//return the recId {-1,-1};
		}
	}
	else 
	{
		//NOTE: a valid prevIndexid points to an entry in an leaf index of the attribute's B+ Tree which had previously satisfied the op for the given attrVal.
		
		block = prevIndexid.block;
		index = prevIndexid.index + 1; //search is resumed from the next index.
		
		//load block into leaf using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leaf(block);
		
		//let leafHead be used to hold the header of leaf.
		HeadInfo leafHead;
		
		//load header into leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		if index exceeds the maximum number of entries present in the leaf index block: //all the entries in the block has been searched; search from the beginning of the next leaf index block.
		{
					
			//update block to rblock of current block and index to 0.
			
			if(block == -1) //end of linked list reach - the search is done.
			{
				//return the recId {-1, -1};
			}	
			
		}
	}
	
	//let internalBlk be used to store an internal index block.
	IndInternal * internalBlk;
	
	//let intHead be used to store the header of the internalBlk.
	HeadInfo intHead;
	
	//let intEntry be used to store an internal entry of the internalBlk.
	InternalEntry intEntry;
	
	//let cond be used to decide which child to search; if 1 move to left child else move to right child after going through all the internal entries.
	int cond;
	
	/******Traverse through all the internal nodes according to value of AttrVal and the operator op******/
	while(block is of type <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>) { //checked using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a>.
			
		//load the block into internalBlk using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		internalBlk = new IndInternal(block);
		
		//load header to intHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//set cond to 0(condition not met)
		
		for i from 0 to (numEntries in  block - 1):
		{
			//load entry in block corresponding to slot i into intEntry using <a href="buffer.html#intgetentry" target="_blank">IndInternal::getEntry()</a>.
		
			int flag = comparison between intEntry's attribute value and the input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
		
			//NOTE: the B+ Tree has been constructed in such a way that if an internal index has an attribute value satisying the op (except for the NE op) for the given attrVal, then there is atleast one entry in its left child that also satisfies op.
			switch(op){
				case  EQ:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case LE:
					//the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. Values that satisfy LE condition, if any exist,  will always be found in the left-most leaf index. Thus, always move to the left.
					cond = 1;
					break;
				case LT:
					//the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. Values that satisfy LT condition, if any exist,  will always be found in the left-most leaf index. Thus, always move to the left.
					cond = 1;
					break;
				case GE:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case GT:
					if(flag >0) //move to the left child of the first entry that is greater than the attrVal.
						cond = 1;
					break;
				case NE:
					//need to search the entire linked list of leaf indices of the B+ Tree, starting from the leftmost leaf index. Thus, always move to the left.
					cond = 1;
					break;
			}
		
			if(cond == 1) //op condition met; proceed to search in the left child.
			{
				//update block to left child of intEntry;
				
				delete internalBlk;
				
				break;
			}
		}
		
		if(cond == 0) //traversed all the entries of internalBlk without satisfying op condition; proceed to search the right child.
		{	
			//update block to right child of intEntry;

			delete internalBlk;
		}
	}
	
	//NOTE: the block is now a leaf index block.
	
	//let leafBlk be used to store an leaf index block.
	IndLeaf * leafBlk;
	
	//let leafHead be used to store the header of the leafBlk.
	HeadInfo leafHead;
	
	//let leafEntry be used to store an index entry of the leafBlk.
	Index leafEntry;
	
	//used to store the state of search; cond = 0: not found but need to search more; cond=1: got a right answer; cond =-1 : stop searching.
	cond = 0;
	
	/******Traverse through index entries in the leaf index block from the index entry numbered as index******/
	while(block !=-1) {
	
		//load the block into leafBlk using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		leafBlk = new IndLeaf(block);
		
		//load the header to leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		while (index < numEntries in leafBlk) { //numEntries can be obtained from leafHead.
			
			//load entry corresponding to block and slot into leafEntry using <a href="buffer.html#leafgetentry" target="_blank">IndLeaf::getEntry()</a>.
			
			int flag = comparison between leafEntry's attribute value and input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
			
			switch(op){
				case  EQ:
					if(flag ==0) //entry satisfying EQ condition found.
						cond = 1;
					else if(flag > 0) //future entries will not satisfy EQ conditions as the values are arranged in ascending order in the leaves.
						cond = -1;
					break;
				case LE:
					if(flag <=0) //entry satisfying LE condition found.
						cond = 1;
					else //future entries will not satisfy LE conditions as the values are arranged in ascending order in the leaves.
						cond = -1;
					break;
				case LT:
					if(flag <0) //entry satisfying LT condition found.
						cond = 1;
					else //future entries will not satisfy LT conditions as the values are arranged in ascending order in the leaves.
						cond = -1;
					break;
				case GE:
					if(flag >=0) //entry satisfying GE condition found.
						cond = 1;
					break;
				case GT:
					if(flag >0) //entry satisfying GT condition found.
						cond = 1;
					break;
				case NE:
					if(flag !=0) //entry satisfying NE condition found.
						cond = 1;
					break;
			}
			if(cond == 1){ //an entry satisying op for the given attrVal found.
			
				//set previous index id to {block, index} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>.
				
				delete leafBlk;
				
				//return the recId {leafEntry.block, leafEntry.slot}.
			}
			else if(cond == -1){ //no entry satisfies op for the given attrVal
				
				delete leafBlk;
				
				//return the recId {-1,-1}.
			}
			
			//search next index.
			++index;
		}
		
		if(op!=NE) //only for NE do we have to check the entire linked list; for all the other op it is guaranteed that the block being searched will have an entry,if it exists, satisying that op.
			break;
		
		//block = next block in the linked list, i.e., the rblock in the leafHead.
		
		delete leafBlk;
		
		//update index to 0.
	}
	
	delete leafBlk;
	
	//no entry satisying the op was found
	//return the recId {-1,-1};
}</code></pre>
                            	</div>
                            </div>
                        </div>                            
                                  
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

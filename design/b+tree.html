<!DOCTYPE HTML>
<html>

<head>
    <title>B+ Tree Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                            <ul class="nav flex-column sidemenu">
                                <li> <a class="sec" href="#create"> B+ Create</a></li>
                                <li> <a class="sec" href="#destroy"> B+ Destroy</a></li>
                                <li> <a class="sec" href="#insert"> B+ Insert</a></li>
                                <li> <a class="sec" href="#search"> B+ search</a></li>
                            </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>B+ Tree Layer</h1>
                        </div>
                        
                        <div class="detail">
				<h5>Pre-requisite Reading : <a href="./indexing.html">Indexing in NITCbase</a></h5>
                        	<p>As you might already know, we use indexing to reduce disk access and to implement search queries faster. NITCBase uses B+ Tree for indexing an attribute in a relation. To implement B+ Tree layer you must require a thorough understanding of the Physical layer, Buffer layer and Cache layer.
                        	</p>
                        </div>
			    
<!----------------------BPLUS CONSTRUCTOR STARTS -------------------------------------------------------------------------->                        
                         <div id="create" class="detail">
                            <h2>public: BPlusTree (Constructor)</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>relid</td>
		                    			<td>int</td>
		                    			<td>Relation Id of the relation which contains the target attribute.</td>
		                			</tr>
		                			<tr>
		                    			<td>attrName</td>
		                    			<td>char[ATTR_SIZE]</td>
		                    			<td>Name of attribute with which B+ tree has to be created.</td>
		                			</tr>
		                        </table>
                            </div>
                            <h5>Return value:</h5> Nil
		                     
		            <h5>Description:</h5>
		            <p>This method creates the bplus-tree(Indexing) on the attribute of a relation specified in the arguments and also updates the object instance's member fileds with the given arguments.</p>
		                   
		            <h5><a data-toggle="collapse" href="#algo-create"><span class="fas fa-code"></span>Algorithm:</a></h5>
                             	     <div id="algo-create" class="collapse">
                            	     	<div class="code"><pre><code>BPlusTree(relId relid, char attrName[ATTR_SIZE]){
					
    //initialise the object instance member fields: relid and attrName with the given relid and attrName	
    
    //let attrCatEntry be used to store the attribute cache entry for attrName
    AttrCatEntry attrCatEntry;
    
    //get the attribute catalog entry of target attribute using OpenRelTable::getAttrCatEntry() method.
    int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatBuf);
    
    if( status != SUCCESS)
    	//update member field rootBlock of the class with the status and return
	
	//let rootBlockNum be used to store the root block number of the B+ Tree
	int rootBlockNum;
	
	if(rootBlockNum != -1) //index already exists for the attribute
		//update the rootBlock member field of the class with rootBlockNum and return
	
	/******Creeating a new B+ Tree ******/
	
	//get a free leaf block
	IndLeaf rootBlock;
	
	if(rootBlock.getBlockNum()==FAILURE) //disk is full, i.e,  unable to get new block from the disk
		//update the rootBlock member field of the class with E_DISKFULL and return
	else 
		//update rootBlock member field of the class with the block number of rootBlock
		
	//update the rootBlock in the attribute cache, attrCatBuf,  using OpenRelTable::setAttrCatEnty()

	//let the relCatBuf hold the relation catalog entry corresponding to relid
	RelCatEntry relCatBuf;
	
	//load the relation catalog entry into relCatBuf using OpenRelTable::getRelCatEntry()
	
	//get the first record block of the relation, number of attributes of the relation and number of slots in the corresponding record block in variables block, numAttr and numSlots respectively using relCatBuf.
	int block;
	int numAttr;
	int numSlots;
	
	//let attrOffset hold the offset of the attribute in the relation- obtained from attrCatBuf
	int attrOffset;
	
	/******traverse all the blocks in the relation and insert them one by one into the B+ Tree.******/
	while(block!=-1) {	
		//load the the block of the relation into a RecBuffer
		RecBuffer recBlock(block);
		
		//let slotMap hold the header of the block	
		unsigned char slotMap[numSlots];
		
		//load the slot map into slotMap using RecBuffer::getSlotMap()
		
		for slot = 0 to numSlots - 1:{	
			if(slotMap[slot]=='1') //if there is an entry {				
				//let rec hold the contents of the record
				union Attribute rec[numAttr];
			
				//load the record corresponding to the slot into rec using RecordBuffer::getRecord()
				
				//let recordId hold the record id {block, slot}
				struct recId recordId;

				//insert the attribute value of the record corresponding to attrName using bPlusInsert
				status = bPlusInsert(rec[attrOffset], recordId);
			
				if(status == E_DISKFULL) //disk is full, i.e,  unable to get enough blocks to build the B+ Tree				
					//update the rootBlock member field of the class with E_DISKFULL and return				
			}
		    	else //all records in the relaton has been traversed
				break;
		}
		
		//let blockHead be used to hold the header of block.
		HeadInfo blockHead;
		
		//load the header of recBlock into blockHead using BlockBuffer::getHeader()
		
		//update the block with rblock of the header.		
	}	
}</code></pre>
					</div>
                            	     </div> 
                        </div>
<!-----------------------------------BPlusDestroy------------------------------------------------------------------------------------>                       
                        <div id="destroy" class="details">
                        	<h2>private: BPlusDestroy</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
		                    			<td>blockNum</td>
		                    			<td>int</td>
		                    			<td>Block number of the index block which is to be destroyed.</td>
		                			</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
										<td><a href="../constants.html#errors" target="_blank">SUCCESS</a></td>
		                        		<td>Successful deletion of index block.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
		                    		    <td>Input blockNum is outside the valid range of block numbers.</td>
		                    		</tr>
		                    		<tr>
										<td><a href="../constants.html#errors" target="_blank">E_INVALIDBLOCK</a></td>
		                    		    <td>Input blockNum do not correspond to an index block.</td>
		                    		</tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to delete a B+ Tree. The caller passes the root block of the B+ Tree as input to the method. The method recursively deletes the constituent index blocks, both <a href="../storage-model.html#intind_blk" target="_blank">internal</a> and <a href="../storage-model.html#leafind_blk">leaf</a> index blocks, until the full B+ Tree is deleted. This method is private and is only called in a situation where no further disk blocks can be allotted during the <a href="#create">creation of</a>/ <a href="#insert">insertion to</a> a B+ Tree. This means that under normal circumstances, NITCbase does not allow the deletion of a B+ Tree once created.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-destroy"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-destroy" class="collapse">
                            	<div class="code"><pre><code>int BPlusTree::BPlusDestroy(int blockNum){

	if blockNum lies outside the valid range [0,<a href="../constants.html#constants" target="_blank">DISK_BLOCKS</a>-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if type of the block obtained using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a> is <a href="../constants.html#constants" target="_blank">IND_LEAF</a>:
	{
		//let leafBlk be used to hold block of blockNum using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leafBlk(blockNum);
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
	}
	else if type of the block is <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>:
	{
		//let internalBlk be used to hold block of blockNum using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		IndInternal internalBlk(blockNum);
		
		//let internalHead be used to store header of internalBlk.
		HeadInfo internalHead;
		
		//load the header using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//let entry be used to hold an entry of the internalBlk.
		InternalEntry entry;
		
		/*iterate through all the entries of the internalBlk and destroy the lChild of the first entry and rChild
		of all entries using <a href="#destroy" target="_blank">BPlusTree::BPlusDestroy()</a>. 
		(take care not to delete overlapping children more than once)*/
		
		//release the block using <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
		
		return SUCCESS;
		
	}
	else //block is not an index block.
	{
		return E_INVALIDBLOCK;
	}
		
}
</code></pre>
								</div>
                            </div>
							<p><b>NOTE:</b> 
								<ul>
									<li>The caller is responsible for updating the <i>rootBlock</i> field in the corresponding attribute catalog to -1 after deletion.</li>
									<li>The caller is also responsible for setting the <i>rootBlock</i> member field of the B+ Tree object instance to -1 after  deletion.</li>
								</ul>
							</p>
                        </div>
<!-- -------------------------------BPLUS INSERT BEGINS HERE-------------------------------------------------------------------------------- -->                        
                        <div id="insert" class="detail">
                        	<h2>public: bPlusInsert</h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	
								    <tr>
								        <td>attrval</td>
								        <td>union Attribute</td>
								        <td>value corresponding to attrName attribute of target record that need to be inserted in to bplus tree.</td>
								    </tr>
								    <tr>
								        <td>recordId</td>
								        <td>recId</td>
								        <td>The record id of target record that need to be inserted in to bplus tree.</td>
								    </tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        		    <tr>
						                <td>SUCCESS</td>
						                <td>On successful insert of the recid.</td>
						            </tr>
						            <tr>
						                <td>E_NOINDEX</td>
						                <td>If B+ tree has not been created on the given attribute.</td>
						            </tr>
						            <tr>
						                <td>E_DISKFULL</td>
						                <td>If disk space is not sufficient to insert into the B+ tree.</td>
						            </tr>
		                     	</table>
		             </div>
			    <h5>Description:</h5>
                            <p>This method inserts the <i>Index</i> of the record corresponding to the given attribute value and record id into the B+ tree.</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-insert"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-insert" class="collapse">
                            	<div class="code"><pre><code>int bPlusInsert(union Attribute val,recId recordId){
	
    //let attrCatBuf be used to store the attribute cache entry for attrName
    AttrCatEntry attrCatEntry;

    //get the attribute catalog entry of target attribute using OpenRelTable::getAttrCatEntry() method.
    int status = OpenRelTable::getAttrCatEntry(relid, attrName, &attrCatEntry);
	
    if( status != SUCCESS)
    	return status;
    
    //let blockNum be the rootBlock of AttrCatEntry 
    int blockNum;
    
    if blockNum of target attribute is -1:
    	return E_NOINDEX;
    
    //let attrType store type of attribute
    int attrType;
   
    class IndBuffer *block = NULL;
    
    HeadInfo blockHeader;
	
	/******Traverse the B+ Tree to reach the appropriate leaf where insertion can be done******/
    while block is not LEAF: { // StaticBuffer::getStaticBlockType() can be used 
    	//load the block
        block = new IndInternal(blockNum);
        
        //load header of block into blockHeader using BlockBuffer::getHeader() method.
        
        //let nEntries be no. of entries in block (can be found from blockHeader)
        int nEntries;
        
        //iterate through all the entries, to find first entry whose attibute value >= value to be inserted.
        //NOTE: the helper function compare() can be used to compare two Union attribute values based on attrType.
        
        if no such entry is found: {      
        	//update blockNum with rChild of nEntries-1'th (i.e. last) entry of the block.  
        	//delete block.
        }      
        else {
         	 //update blockNum with lChild of the entry of block.
                 //delete block. 
         }
    }

    //NOTE: now blockNum is the leaf index block to which insertion of val is to be done.
    
    /******Insertion of entry in the appropriate leaf block******/
    
    //load the block 
    block = new IndLeaf(blockNum);
    
    Index indexval; //(stores Index entry to be inserted in B+ Tree)
    //update indexval with as that of recid, val.

    //load header of the block into blockHeader using BlockBuffer::getHeader() method.

    //let nEntries be no. of entries in block pointing by block(can be found from blockHeader)
    int nEntries;

    //let indices[nEntries+1] be an array of type struct Index.
    Index indices[nEntries+1];
    
    //iterate through 0 to nEntries-1 and copy all the entries in the block to the array indices. Also insert indexval at appropriate position in the indices array.
    
    if (nEntries!= 63){
    	//NOTE: leaf block has not reached max limit
    	
        //update blockHeader.numEntries as nEntries+1 and set this as header of block using BlockBuffer::setHeader() method. 
        
        //iterate through 0 to nEntries and populate the entries of block with entries in indices array using IndBuffer::setEntry() method.
        
        //delete block.
        
        return SUCCESS;
    } 
    else {
    	//NOTE: leaf block is full- need a new leaf to make the entry; split the entries between the two blocks
    	
    	//obtain new leaf index block as the right block in the splitting
        class IndBuffer * newRightBlk = new IndLeaf();
        
        //assign the existing block as the left block in the splitting
        class IndBuffer * leftBlk = block;
        
	//store the block numbers of both blocks in variables newRightBlkNum and leftBlkNum using BlockBuffer::getBlockNum() method
        int newRightBlkNum;
        int leftBlkNum;
		
        if(newRightBlkNum == FAILURE){ //failed to obtain an empty leaf index becauase the disk is full
 		//delete the B+ tree created till now.
		//update the rootBlock of attrCatEntry as -1 using  OpenRelTable::setAttrCatEntry
		this->rootBlock = E_DISKFULL;
		return E_DISKFULL;
        }
        //let leftBlkHeader be the header of the left block(which is presently stored in blockHeader)
        struct HeadInfo leftBlkHeader = blockHeader;
		
	//let prevRblock be the right block after leftBlk
	int prevRblock = leftBlkHeader.rblock;
			
        //update number of enteries in leftBlkHeader as 32 and its rblock as newRightBlkNum using using BlockBuffer::setHeader() method.

	//let newRightBlkHeader be of type struct HeadInfo
        struct HeadInfo newRightBlkHeader;
		
	//load the header of block newRightBlkHeader in newRightBlkHeader using BlockBuffer::getHeader
		
        //update number of enteries in newRightBlkHeader as 32, its plbock as the plbock of leftBlk, its lblock as leftBlkNum and its rblock as prevRblock using BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.

     	//set the first 32 entries of leftBlk as the first 32 entries of indices array and set the first 32 entries of newRightBlk as the next 32 entries of indices array using IndBuffer::setEntry() method.

        //let parBlkNum be the pblock of leftBlk.
        int parBlkNum;
        
        delete leftBlk;
        delete newRightBlk; 
        
        //let newAttrval hold the attribute value of indices[31]; this is attribute value which needs to be inserted in the parent block
        union Attribute newAttrval;
		
	/******Traverse the internal index blocks of the B+ Tree bottom up making insertions where ever required******/

	//let done indicate whether the insertion is complete or not
        bool done = false;
        
        while(!done){
        	if (parBlkNum!=-1){ //parBlkNum is a valid parent block
			//load the block corresponding to parBlkNum to parblk
			class IndInternal *parblk= new IndInternal(parBlkNum);

			//let parheader be of type struct HeadInfo
			struct HeadInfo parheader;

			//load parheader with header of parblk using BlockBuffer::getHeader() method.

			//let internalEntries be an array of InternalEntries of size parheader.numEntries+1
			struct InternalEntry internalEntries[parheader.numEntries+1];

			//iterate through 0 to parheader.nEntries-1 and copy all the entries in the parblk to the array internalEntries. Also insert an InternalEntry entry with attrVal as newAttrval, lChild as leftBlkNum and rChild as newRightBlkNum at an appropriate position in the internalEntries array.				

			if(parheader.numEntries!=100){ //parBlkNum has not reached max limit	
				//increment parheader.numEntries and update it as header of parblk BlockBuffer::setHeader() method. 

				//iterate through 0 to parheader.numEntries-1 and populate the enties of parblk with entries in internalEntries array using IndBuffer::setEntry() method.

				//delete parblk.

				//set done to true;

			}
			else { //the parent internal index is full- need a new internal index to make the entry; split the entries between the two blocks
				//obtain a new internal index block in dummy
			    	class IndInternal* dummy = new IndInternal();

			    	if(dummy->getBlockNum()==FAILURE){ //failed to obtain an empty leaf index becauase the disk is full
					//destroy the right subtree, given by newRightBlkNum, build up till now that has yet been connected to the existing B+ Tree. 
					//destroy the remaining B+ tree too which was built till now.
					//update rootBlock of attrCatEntry as -1 using OpenRelTable::setAttrCatEntry()
					this->rootBlock = E_DISKFULL;
					return E_DISKFULL;
			     	}

			    	//assign dummy as the left block in the splitting
			    	newRightBlk= (class IndInternal* )dummy;

			        //assign the dummy block as the left block in the splitting
			        leftBlk= (class IndInternal* )parblk;

			        //udpate newRightBlkNum with block number of newRightBlk using BlockBuffer::getBlockNum() method.

			        //update leftBlkNum with parBlkNum

			        //update leftBlkHeader with parheader

			        //update number of enteries of leftBlkHeader as 50 using BlockBuffer::setHeader() method.

			        //update number of enteries of newRightBlkHeader as 50 using BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.

			    	//set the first 50 entries of leftBlk as the first 50 entries of internalEntries array and set the first 50 entries of newRightBlk as the entries from 51 to 100 of indices array using IndBuffer::setEntry()

			        IndBuffer *childBuff;
			    	struct HeadInfo childBuffHead;

			    	//let type be the block type of a child of any entry( say, the rchild of 50th entry) in the internalEntries array, using StaticBuffer::getStaticBlockType method.
			    	int type;

			     	//iterate from 50 to 100:{
					//assign the rchild block of ith index in internalEntries of the appropriate type to childBuff 
					if(type == IND_LEAF)
						childBuff = (IndBuffer*) new IndLeaf(internalEntries[i].rChild);
					 else
						childBuff = (IndBuffer*) new IndInternal(internalEntries[i].rChild);

					//update pblock field in header of the childBuff block to newRightBlkNum making use of BlockBuffer::getHeader() and BlockBuffer::setHeader() methods.
					delete childBuff;                    
			    	}

			    	delete leftBlk;
			    	delete newRightBlk;

			    	//update parBlkNum to the pblock of leftBlk

			    	//update newAttrval to the attribute value of 50th entry in the internalEntries array;  
	
			}
                }		
        	else { //when parBlkNum is invalid          	 
			//NOTE: Need to allot a new block which would be the root of the B+ Tree

			//load a new internal index block to newRootBlk
			class IndInternal* newRootBlk = new IndInternal();

			//store the block number of newRootBlk in newRootBlkNum using BlockBuffer::getBlockNum() function.
			int newRootBlkNum;

			if(newRootBlkNum == FAILURE){ //failed to obtain an empty internal index block becauase the disk is full	
				//destroy the right subtree, given by newRightBlkNum, build up till now that has yet been connected to the existing B+ Tree.
				//destroy the remaining B+ tree too which was built till now.
				//update the rootBlock of attrCatEntry as -1 using OpenRelTable::setAttrCatEntry()
				this->rootBlock = E_DISKFULL;
				return E_DISKFULL;
			}

			//let newRootHeader be the header of newRootBlk
			struct HeadInfo newRootHeader; 

			//update number of enteries in newRootBlk as 1 using BlockBuffer::setHeader() and BlockBuffer::getHeader() methods.

			//add the InternalEntry entry with lChild as leftBlkNum, attrVal as newAttrval and rChild as newRightBlkNum as the first entry to newRootBlk using IndBuffer::setEntry();

			//update the pblock both leftBlkNum and newRightBlkNum to newBlkNum using BlockBuffer::setHeader() and BlockBuffer::getHeader() methods
			/*NOTE : the type of leftBlkNum and newRightBlkNum has to be checked first (using StaticBuffer::getStaticBlockType()) before loading it into leftBlk and newRightBlk with appropriate IndLeaf or IndInternal instances */

			//update rootBlock of attrcatEntry variable (into which the attribute catalog was earlier loaded) as newBlkNum using OpenRelTable::setAttrCatEntry() method.

			delete newRootBlk;

			//set done to true.
        	}
        }
        return SUCCESS;
}
				
 
}</code></pre>
                            	</div>
                            </div>
                        </div>
<!-- -------------------------------BPlusSearch-------------------------------------------------------------------------------- -->                                                
                        <div id="search" class="detail">
                        	<h2>public: BPlusSearch<h2>
                        	<h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
									<tr>
								        <td>attrVal</td>
										<td><a href="buffer.html#block_structures_attribute" target="_blank">union Attribute</a></td>
								        <td>Attribute that is to be checked against the operater.</td>
								    </tr>
									<tr>
								        <td>op</td>
								        <td>int</td>
								        <td>One amongst the 6 relation operators(EQ, LE, LT, GE, GT, NE corresponds to equal, less than equal, less than, greater than equal, greater than, not equal operators respectively).</td>
									</tr>
		                        </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>recordId</td>
										<td><a href="buffer.html#recid" target="_blank">Record id</a> of the first/ next block entry in the relation that satisfies <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
						            <tr>
						                <td>Invalid recordId {-1,-1}</td>
										<td>No first/ next block entry found satisfisying <i>op</i> for <i>attrVal</i>.</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>Used to search the first/ next record entry in the relation that satisfies the relational operation for the input attribute value. The method makes use of the <i>prevIndexid</i> field of the attribute in the <a href="cache.html" target="_blank">Attribute Catalog Cache</a> for this purpose. It holds the <a href="buffer.html#indexid" target="_blank">index id</a> of the entry in the leaf block of the B+ Tree that corresponded to a hit in the previous search. The search is resumed from the next index entry. An invalid index id means that the search is being done for the first time.</p>
                            <h5><a data-toggle="collapse" href="#algo-search"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-search" class="collapse">
                            	<div class="code"><pre><code>struct RecId BPlusTree::BPlusSearch(union Attribute attrVal, int op){
	
	//let prevIndexid be used to store previous index id for attrName.
	IndexId prevIndexid;
	
	//get the previous index id from the attribute cache using the <a href="cache.html#getprevindexid" target="_blank">OpenRelTable::getPrevIndexId()</a>.
	
	//reset the previous index id to {-1,-1} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>.
	  (this will be set to the correct index id if an entry satisfying op for given attrVal is found in the course
	   of the search.)
	
	//let attrcatEntry be used to store the attribute cache entry for attrName.
	AttrCatEntry attrcatEntry;
	
	//load the attribute cache entry using <a href="cache.html#getattrcatentry" target="_blank">OpenRelTable::getAttrCatEntry()</a>.
	
	//store root block num and attribute type of the B+ Tree in rootBlock and attrType respectively.
	int rootBlock;
	int attrType;
	
	//let block and index variables be used to locate the entry to be searched.
	int block, index;
	
	if prevIndexid=={-1,-1}:
	{
		//NOTE: an invalid prevIndexid means that the search is done for the first time.
		
		block = rootBlock;
		index = 0; //start the search from the root.
	}
	else 
	{
		/*NOTE: a valid prevIndexid points to an entry in the leaf index of the attribute's B+ Tree which had 
		  previously satisfied the op for the given attrVal.*/
		
		block = prevIndexid.block;
		index = prevIndexid.index + 1; //search is resumed from the next index.
		
		//load block into leaf using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		IndLeaf leaf(block);
		
		//let leafHead be used to hold the header of leaf.
		HeadInfo leafHead;
		
		//load header into leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		if index exceeds the maximum number of entries present in the leaf index block: 
		//all the entries in the block has been searched; search from the beginning of the next leaf index block.
		{
					
			//update block to rblock of current block and index to 0.
			
			if(block == -1) //end of linked list reach - the search is done.
			{
				//return the recId {-1, -1};
			}	
			
		}
	}
	
	//let internalBlk be used to store an internal index block.
	IndInternal * internalBlk;
	
	//let intHead be used to store the header of the internalBlk.
	HeadInfo intHead;
	
	//let intEntry be used to store an internal entry of the internalBlk.
	InternalEntry intEntry;
	
	/*let cond be used to decide which child to search.
	  if 1 move to left child else move to right child after going through all the internal entries.*/
	int cond;
	
	/******Traverse through all the internal nodes according to value of AttrVal and the operator op******/
	while block is of type <a href="../constants.html#constants" target="_blank">IND_INTERNAL</a>: { //checked using <a href="buffer.html#getstaticblocktype" target="_blank">StaticBuffer::getStaticBlockType()</a>.
			
		//load the block into internalBlk using <a href="buffer.html#intindbuff_constructor2" target="_blank">IndInternal::IndInternal()</a>.
		internalBlk = new IndInternal(block);
		
		//load header to intHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		//set cond to 0(condition not met)
		
		for i from 0 to (numEntries in  block - 1):
		{
			//load entry in block corresponding to slot i into intEntry using <a href="buffer.html#intgetentry" target="_blank">IndInternal::getEntry()</a>.
		
			int flag = comparison between intEntry's attribute value and the input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
		
			/*NOTE: the B+ Tree has been constructed in such a way that if an internal index has an attribute value 
			satisying the op (except for the NE op) for the given attrVal, then there is atleast one entry in its 
			left child that also satisfies op.*/
			switch(op){
				case  EQ:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case LE:
					/*the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. 
					Values that satisfy LE condition, if any exist,  will always be found in the left-most leaf index. 
					Thus, always move to the left.*/
					cond = 1;
					break;
				case LT:
					/*the attribute values are arranged in ascending order in the leaf indices of the B+ Tree. 
					Values that satisfy LT condition, if any exist,  will always be found in the left-most leaf index. 
					Thus, always move to the left.*/
					cond = 1;
					break;
				case GE:
					if(flag >=0) //move to the left child of the first entry that is greater than or equal to attrVal.
						cond = 1;
					break;
				case GT:
					if(flag >0) //move to the left child of the first entry that is greater than the attrVal.
						cond = 1;
					break;
				case NE:
					/*need to search the entire linked list of leaf indices of the B+ Tree, starting 
					from the leftmost leaf index. Thus, always move to the left.*/
					cond = 1;
					break;
			}
		
			if(cond == 1) //op condition met; proceed to search in the left child.
			{
				//update block to left child of intEntry;
				
				delete internalBlk;
				
				break;
			}
		}
		
		if(cond == 0) /*traversed all the entries of internalBlk without satisfying op condition; 
						proceed to search the right child.*/
		{	
			//update block to right child of intEntry;

			delete internalBlk;
		}
	}
	
	//NOTE: the block is now a leaf index block.
	
	//let leafBlk be used to store an leaf index block.
	IndLeaf * leafBlk;
	
	//let leafHead be used to store the header of the leafBlk.
	HeadInfo leafHead;
	
	//let leafEntry be used to store an index entry of the leafBlk.
	Index leafEntry;
	
	/*used to store the state of search; 
	cond = 0: not found but need to search more; cond = 1: got a right answer; cond = -1 : stop searching.*/
	cond = 0;
	
	/******Traverse through index entries in the leaf index block from the index entry numbered as index******/
	while(block !=-1) {
	
		//load the block into leafBlk using <a href="buffer.html#leafindbuff_constructor2" target="_blank">IndLeaf::IndLeaf()</a>.
		leafBlk = new IndLeaf(block);
		
		//load the header to leafHead using <a href="buffer.html#getheader" target="_blank">BlockBuffer::getHeader()</a>.
		
		while (index < numEntries in leafBlk) { //numEntries can be obtained from leafHead.
			
			//load entry corresponding to block and slot into leafEntry using <a href="buffer.html#leafgetentry" target="_blank">IndLeaf::getEntry()</a>.
			
			int flag = comparison between leafEntry's attribute value and input attrVal using <a href="buffer.html#compare" target="_blank">compare()</a>.
			
			switch(op){
				case  EQ:
					if(flag == 0) //entry satisfying EQ condition found.
						cond = 1;
					else if(flag > 0) /*future entries will not satisfy EQ conditions as the values 
										are arranged in ascending order in the leaves.*/
						cond = -1;
					break;
				case LE:
					if(flag <= 0) //entry satisfying LE condition found.
						cond = 1;
					else /*future entries will not satisfy LE conditions as the values are arranged in
						   ascending order in the leaves.*/
						cond = -1;
					break;
				case LT:
					if(flag < 0) //entry satisfying LT condition found.
						cond = 1;
					else /*future entries will not satisfy LT conditions as the values are arranged in 
						   ascending order in the leaves.*/
						cond = -1;
					break;
				case GE:
					if(flag >= 0) //entry satisfying GE condition found.
						cond = 1;
					break;
				case GT:
					if(flag > 0) //entry satisfying GT condition found.
						cond = 1;
					break;
				case NE:
					if(flag != 0) //entry satisfying NE condition found.
						cond = 1;
					break;
			}
			if(cond == 1){ //an entry satisying op for the given attrVal found.
			
				//set previous index id to {block, index} using <a href="cache.html#setprevindexid" target="_blank">OpenRelTable::setPrevIndexId()</a>.
				
				delete leafBlk;
				
				//return the recId {leafEntry.block, leafEntry.slot}.
			}
			else if(cond == -1){ //no entry satisfies op for the given attrVal.
				
				delete leafBlk;
				
				//return the recId {-1,-1}.
			}
			
			//search next index.
			++index;
		}
		
		if(op!=NE) 
		/*only for NE do we have to check the entire linked list;
		for all the other op it is guaranteed that the block being searched will have an entry,if it exists, 
		satisying that op.*/
			break;
		
		//block = next block in the linked list, i.e., the rblock in the leafHead.
		
		delete leafBlk;
		
		//update index to 0.
	}
	
	delete leafBlk;
	
	//no entry satisying the op was found; return the recId {-1,-1}
}</code></pre>
                            	</div>
                            </div>
                        </div>                            
                                  
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

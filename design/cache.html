<!DOCTYPE HTML>
<html>

<head>
    <title>Cache Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                            <ul class="nav flex-column sidemenu">
                                <li> <a class="sec" href="#layout"> Layout</a></li>
                                <li> <a class="sec" href="#relation_cache"> Relation Cache</a></li>
                                <li> <a class="sec" href="#attribute_cache"> Attribute Cache</a></li>
                                <li> <a class="sec" href="#openrel_table"> Open Relation Table</a></li>
                                <br>
                                Public Methods:
                                <ul >
                                    <li><a href="#constructor">openRelTable()</a></li>
                                    <li><a href="#destructor">~openRelTable()</a></li>
                                    <li><a href="#openrel">openRel()</a></li>
                                    <li><a href="#closerel">closeRel()</a></li>
                                    <li><a href="#getrelid">getRelId()</a></li>
                                    <li><a href="#getrelcatentry">getRelCatEntry()</a></li>
                                    <li><a href="#setrelcatentry">setrelCatEntry()</a></li>
                                    <li><a href="#getprevrecid">getPrevRecId()</a></li>
                                    <li><a href="#setprevrecid">setPrevRecId()</a></li>
                                    <li><a href="#getattrcatentry">getAttrCatEntry()</a></li>
                                    <li><a href="#setattrcatentry">setAttrCatEntry()</a></li>
                                    <li><a href="#getprevindexid">getPrevIndexId()</a></li>
                                    <li><a href="#setprevindexid">setPrevIndexId()</a></li>
                                </ul>
                                
                            </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>Cache Layer</h1>
                        </div>
                        
                         <div id="layout" class="detail">
                            <h2>Layout</h2>
                             <p> The job of this module is to cache the  <a href="../storage-model.html#relcat">relation catalog</a> and  <a href="../storage-model.html#attrcat">attribute catalog</a> of opened relations in memory. Some meta data related to open relations is also managed by the cache layer.  Since catalog information is frequently required by any query processing module, caching reduces the number of disk accesses for accessing the catalogs. The cache layer provides a clean interface to for catalog access, hiding from the higher layers how the catalogs are stored and maintained internally. The following diagram summarizes the design of this module showing its private and public methods. </p>
                            <center><img class="img-fluid" src="/img/cache_class_new.png"></center>
                        </div>
                <!----------------Relation catalog structues--------------------------------------------------------------->        
                        <div id="relation_cache" class="detail">
                        <h2>Relation Catalog Cache Structures</h2>
                            <p><a href="../storage-model.html#relcat">Relation catalog</a> stores metadata coresponding to all relations in the system. In addition to storing this information in the disk, The relation catalog entries of every open relation is cached in the main memory for easy access to this information and to achieves good performance. This is called Relation Cache. A maximum of MAXOPEN = 12 relations are cached at the same time. Each cached relation catalog entry is stored as a <i>RelCatEntry</i> structure as shown below:</p>
                		<div id="rel_cat_entry" class="subsec">
						<h4>RelCatEntry </h4>
							<p></p>
					<div class="code"><pre><code>typedef struct RelCatEntry {
						    char rel_name[ATTR_SIZE];
						    int num_attr;
						    int num_rec;
						    int first_blk;          //Head of linked list of blocks
						    int num_slots_blk;      //Number of slots in a block
						} RelCatEntry ;</code></pre>
					</div>
              			</div>
				<div id="rel_cache_entry" class="subsec">
					<h4>RelCacheEntry</h4>
							<p></p>
					<div class="code"><pre><code>typedef struct RelCacheEntry {
						    RelCatEntry entry;
						    bool dirty;
						    RecId recId;
						    RecId searchIndex;
						} RelCacheEntry ;</code></pre>
					</div>
              			</div>
						
		      </div>
		
	<!----------------Attribute catalog structues--------------------------------------------------------------->
                        <div id="attribute_cache" class="detail">
                            <h2>Attribute Catalog Cache Structures</h2>
                            <p>The <a href="../storage-model.html#attrcat">Attribute catalog</a>, analogous to the relation catalog stores meta information for every attribute in every relation of the system. In addition to storing this catalog in the disk, the attribute catalog information of all open relations is also cached in the main memory for performance reasons and easy access. For each opened relation, NITCbase maintains an attribute cache. The Attribute cache of an open relation is a list of Attribute catalog entries, where each entry corresponds to an attribute of the relation. (Thus for each open relation there is an Attribute cache and for each attribute of an open relation, there is an entry in the corresponding attribute cache). Since at most MAXOPEN=12 relations can be opened at a time, there are at most MAXOPEN Attribute Caches exist at a time. </p>
                                
                            <p>Each entry in the Attribute Cache of a relation contains all the fields from the attribute catalog entry of the corresponding attribute, and some extra fields for storing meta-data as explained below. Since a relation can have a variable number of attributes (though the maximum number of attributes for a relation is bounded in Nitcbase by 125 - <b>why?</b>), Each Attribute cache is stored in the memory as a linked list of <i>Attribute Cache entries</i>.</p>
                            <div id = "attr_cat_entry" class= "subec">
				    <h4>AttrCatEntry</h4>
				    <p></p>
				    <div class="code"><pre><code>     typedef struct AttrCatEntry {
					char rel_name[ATTR_SIZE];
					char attr_name[ATTR_SIZE];
					int attr_type;     // can be INT/FLOAT/STR
					bool primary_flag; // Currently unused
					int root_block;    // root block# of the B+ tree if exists, else -1
					int offset;        // offset of the attribute in the relation
				    } AttrCatEntry ;</code></pre></div>
			    </div>
			<div id = "attr_cache_entry" class= "subec">
			    <h4>AttrCacheEntry</h4>
			    <p></p>
			    <div class="code"><pre><code>
				    typedef struct AttributeCacheEntry {
					AttrCatEntry attrcat_entry;
					bool dirty;
					<a href="buffer.html#misc">recId</a> recid;
					<a href="buffer.html#misc">IndexId</a> prev_indid;   /*IMPORTANT: see explanation below  */
					struct AttributeCacheEntry *next;
				    } AttributeCacheEntry;</code></pre></div>
				</div>
				<!--
                          	<p>As already stated, AttributeCacheEntry also stores some in memory information which will not be committed back to disk. They are:</p>
                           	<ol>
                           		<li><i>dirty</i>: Indicates whether the attribute catalog entry is modified.</li>
                    			<li><i>recid</i>: Stores the record id (block#, slot#) of the attribute catalog entry in the disk. This is useful to commit the catalog entry to disk when it is modified.</li>
                                <li><i>prev_indid</i>: This entry is valid only if there is an index created on the attribute. It stores the block# and index# of the B+ tree <a href="../storage-model.html#leafind_blk">leaf node</a> corresponding to the <b>last (previous) search hit</b> on the attribute. <a href="b+tree.html#search">B+ search algorithm</a> uses this information to search for the next hit starting from the previous hit. The entries are initialized to (-1, -1) when the relation is open. The RST option of <a href="blockaccess.html#search">ba_search</a> also sets this to (-1, -1). When every record of the relation has been searched, <a href="b+tree.html#search">B+ search</a> sets the value to (-1, -1). </li>
                    		</ol> 
                        </div> -->
  <!--------------------Open Relation Table Structures------------------------------------------------------------------------------------------------------>                      
                        <div id="openrel_table_struct" class="detail">
                            <h2>Open Relation Table Structures</h2>
                            <p></p>
                            <div id = "open_rel_table_metainfo" class= "subec">
				    <h4>OpenRelTableMetaInfo</h4>
				    <p></p>
				    <div class="code"><pre><code>     typedef struct OpenRelTableMetaInfo {
					bool freee;
					char rel_name[ATTR_SIZE];
				    } OpenRelTableMetaInfo ;</code></pre></div>
			    </div>
			</div>
<!-----------------------------------class RelCacheTable----------------------------------------------------------------------------------->
			<div id="rel_cache_table_class" class="details">
				<h2>class RelCacheTable</h2>
				<p></p>
				<div class="code">
					<pre><code>class RelCacheTable{
private:
	//fields
	RelCacheEntry* relCache[MAXOPEN];
	//methods
	RelCacheEntry* RecordtoRelCacheEntry(union Attribute record[RELCAT_SIZE]);
	union Attribute* RelCacheEntrytoRecord(RelCacheEntry relCacheEntry);
public:
	//methods
	int getRelCatEntry(int relId, RelCatEntry *relCatBuf);
	int setRelCatEntry(int relId, RelCatEntry *relCatBuf);
	int getSearchIndex(int relId, RecId *searchIndex);
	int setSearchIndex(int relId, RecId *searchIndex);

					};</code></pre>
				</div>
				<ul class="methods">
	     <!----------------------recordToRelCacheEntry--------------------------->
					<li>
						<div class="detail" id="rectorelcache">
					    	<h2><i>private</i> recordToRelCacheEntry</h2>
					    	<h5>Arguments:</h5>
					    	<div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							<td>record</td>
							<td>union Attribute[RELCAT_SIZE]</td>
							<td>Record which has to be converted to struct RelCacheEntry</td>
						    </tr>
							</table>
						    </div>

					    <h5>Return value:</h5>
					    <div class="table-responsive">
							<table class="table table-bordered table-hover">
								<tr>
									<td>RelCacheEntry</td>
									<td>RelCacheEntry*</td>
									<td>Pointer to struct RelCacheEntry created using the given record.</td>
								</tr>
							</table>
						     </div>
					    <h5>Description:</h5>
					    <p>This is an utility function that converts the array of <a href="buffer.html#block_structures">union Attribute</a> (record) to <a href="#relation_cache">RelCacheEntry</a> structure. The details of the implementation are left to you.</p>
						</div>	
					</li>
	<!--------RelCacheEntryToRecord--------------------------------------------------------------->
					<li>
						<div class="detail" id="relcachetorec">
                            			<h2><i>private</i> relCacheEntrytoRecord</h2>
                            			<h5>Arguments:</h5>
                            			<div class="table-responsive">
		                        	<table class="table table-bordered table-hover">
		                            		<tr>
								<td>relCacheEntry</td>
							        <td>RelCacheEntry</td>
							        <td>struct RelCacheEntry which has to be converted to record.</td>
						    	</tr>
		                        	</table>
		                   		 </div>
                            
                            		<h5>Return value:</h5>
                            		<div class="table-responsive">
		                        	<table class="table table-bordered table-hover">
		                        		<tr>
								<td>record</td>
						                <td>union Attribute *</td>
						                <td>record (array of union Attribute) created using the given RelCacheEntry.</td>
						        </tr>
		                     		</table>
		                     	</div>

                            	<h5>Description:</h5>
                            	<p>This is an utility function that converts <a href="#relation_cache">RelCacheEntry</a> structure to the array of <a href="buffer.html#block_structures">union Attribute</a> (record). The details of the implementation are left to you.</p>
                        	</div>
					</li>
	<!--------getRelCatEntry--------------------------------------------------------------->
					<li>
						<div id="getrelcatentry" class="detail">
                            <h2><i>public:</i> getRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation.</td>
                                    </tr>
                                    <tr>
                                        <td>relCatBuf</td>
                                        <td>RelCatEntry *</td>
                                        <td>pointer to the buffer of type RelCatEntry into which the relation catalog entry is to be copied from the relation cache.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>On successful copy of the relation catalog entry corresponding to the relation with id relId</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relId is out of the range 0-MAX_OPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relId</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method gives the Relation catalog(struct RelCatEntry) of specified relation in cache(RelCacheTable).</p>

                            <h5><a data-toggle="collapse" href="#algo-getrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getrelcatentry" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::getRelCatEntry(int relId, RelCatEntry *relCatBuf){
	if(relId&lt; 0 || relId&gt;= MAX_OPEN){	//check relation id (relId) lies in the range
		return E_OUTOFBOUND;
	}
	if(relCache[relId] == NULL){ //slot corresponding to the relId in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relation catalog in the relation cache to the relCatBuf
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
                        </div>
					</li>
	<!--------setRelCatEntry--------------------------------------------------------------->
					<li>
						<div id="setrelcatentry" class="detail">
                            <h2><i>public:</i> setRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation.</td>
                                    </tr>
                                    <tr>
                                        <td>relCatBuf</td>
                                        <td>RelCatEntry *</td>
                                        <td>pointer to the buffer of type RelCatEntry from which the relation catalog entry is to be copied into the relation cache. <br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class=retval>
                                <h5>Return value:</h5>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <tr>
                                            <td>SUCCESS</td>
                                            <td>On successful copy of the relation catalog entry corresponding to the relation with id relId</td>
                                        </tr>
                                        <tr>
                                            <td>E_OUTOFBOUND</td>
                                            <td>If the relId is out of the range 0-MAX_OPEN</td>
                                        </tr>
                                        <tr>
                                            <td>E_NOTOPEN</td>
                                            <td>If there is no open relation  corresponding to the id given by relId</td>
                                        </tr>

                                    </table>
                                </div>
                            </div>

                            <h5>Description:</h5>
                            <p>This method sets the Relation catalog(struct RelcatEntry) of specified relation in cache(RelCacheTable).</p>

                            <h5><a data-toggle="collapse" href="#algo-setrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setrelcatentry" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::setRelCatEntry(int relId, RelCatEntry *relCatBuf){
	if(relId&lt; 0 || relId&gt;= MAX_OPEN){	//check relation id (relId) lies in the range
		return E_OUTOFBOUND;
	}
	if(relCache[relId] == NULL){ //slot corresponding to the relId in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relCatBuf to the relation catalog in the relation cache
	//set the dirty flag corresponding to the relation with Id relId in the relation cache
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
                        </div>
					</li>
	<!--------getSearchIndex--------------------------------------------------------------->
					<li>
						<div id="getsearchindex0" class="detail">
                            <h2><i>public:</i> getSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>searchIndex</td>
                                        <td>recId *</td>
                                        <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair).<br> The record id field of the previous hit stored in the meta information of the relation cache is to be copied into searchIndex.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If record id of previous hit is copied to searchIndex. It means that the id pointed by searchIndex is valid.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relId is out of the range 0-MAX_OPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation corresponding to the id given by relId</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method gives the value of <i>searchIndex</i> field corresponding to the specified relation in cache.(note: this is used to track the record found in previous search and next search can start searching afer previously found record)</p>

                            <h5><a data-toggle="collapse" href="#algo-getprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getprevrecid" class="collapse">
                                <div class="code"><pre><code>int relCacheTable::getSearchIndex(relId relid, recId *recidbuff_ptr){
	if(relId&lt; 0 || relId&gt;= MAX_OPEN){//check whether relation id (relId) lies in the range
		return E_OUTOFBOUND;
	}
	if(relCache[relId] == NULL){ //slot corresponding to the relId in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation in the relation cache to the searchIndex*/
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
                        </div>
					</li>
	<!--------setsearchIndex--------------------------------------------------------------->
					<li>
						<div id="setsearchindex0" class="detail">
                            <h2><i>public:</i> setSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>searchIndex</td>
                                        <td>recId *</td>
                                        <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair).<br> The searchIndex field corresponding to the previous hit is to be stored to the meta information of the relation cache from  searchIndex.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If the record id is successfully copied into the Relation Catalog Cache.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relId is out of the range 0-MAX_OPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relId</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method sets the value of <i>searchIndex</i> field corresponding to the specified relation in cache.</p>

                            <h5><a data-toggle="collapse" href="#algo-setprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setprevrecid" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::setSearchIndex(int relId, recId *searchIndex){
	if(relId&lt; 0 || relId&gt;= MAX_OPEN){	//check relation id (relId) lies in the range
		return E_OUTOFBOUND;
	}
	if(relCache[relid] == NULL){ //slot corresponding to the relId in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation from the searchIndex to the relation cache*/
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
                        </div>
					</li>
	<!----------------------------------------------------------------------->
					
				</ul>
			</div>
<!-----------------------------------class AttrCacheTable----------------------------------------------------------------------------------->

			<div id="attr_cache_table_class" class="details">
				<h2>class AttrCacheTable</h2>
				<p></p>
				<div class="code">
					<pre><code>class AttrCacheTable{

					};</code></pre>
				</div>
				<ul class="methods">
	     <!----------------------RecordToAttrCacheEntry--------------------------->
					<li>
						
					</li>
         <!-------------------------------AttrCacheEntryToRecord------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------getAttrCatEntry1------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------getAttrCatEntry2------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------setAttrCatEntry1------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------setAttrCatEntry2------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------getSearchIndex1------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------getSearchIndex2----------------------------------------------------------->
					<li>
					</li>
         <!-------------------------------setSearchIndex1------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------setSearchIndex2------------------------------------------------------------>
					<li>
					</li>
	<!----------------------------------------------------------------------->
				</ul>
			</div>
<!---------------------------------------------------------------------------------------------------------->
            
<!-----------------------------------class OpenRelTable----------------------------------------------------------------------------------->

			<div id="open_rel_table_class" class="details">
				<h2>class OpenRelTable</h2>
				<p></p>
				<div class="code">
					<pre><code>class OpenRelTable{

					};</code></pre>
				</div>
				<ul class="methods">
	     <!----------------------Constructor--------------------------->
					<li>
						
					</li>
         <!-------------------------------Destructor------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------getRelId------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------openRel------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------closeRel------------------------------------------------------------>
					<li>
					</li>
         <!-------------------------------deleteRel------------------------------------------------------------>
					<li>
					</li>
				</ul>
			</div>
<!---------------------------------------------------------------------------------------------------------->
                                  
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>	
	
<!------PREV CODE TO BE DELETED FROM HERE 
			<div id = "openrel_table" class="detail">
                        	<h2>Open Relation Table</h2>
                        	<p>Cache layer stores the catalog caches in a tabular structure called Open Relation Table. Open relation table consists of a total of MAXOPEN=12 entries. Each entry corresponds to an open relation. The index to the entry in the open relation table is considered as the relation identifier (relId). Any layer that wishes to access the catalog information of an open relation needs to supply relId as an argument for the access functions of cache layer (access functions are described below). Each entry in the Open Relation Table has the following fields:</p>
                        	<ol>
                                <li><i>relcat_entry</i>: cached <a href="#relation_cache">relation catalog entry</a> of the relation</li>
                                <li><i>free</i>: Indicates whether the entry is free or occupied.</li>
                                <li><i>dirty</i>: Indicates whether <a href="#relation_cache">relation catalog entry</a> is modified.</li>
                                <li><i>rec_id</i>: Stores the <a href="buffer.html#misc">record id</a> (block#, slot#) of the relation catalog entry in the disk. This is useful to commit the catalog entry to the disk if it is modified.</li>
                                <li><i>prev_recid</i>: It stores the block# and slot# of the <a href="../storage-model.html#record_blk">record block</a> corresponding to the <b>last (previous) search hit</b> on the relation. <a href="blockaccess.html#linear_search">Linear search algorithm</a> of the block access layer uses this information to search for the next hit, starting from the previous hit. The entries are initialized to (-1, -1) when the relation is open. The RST option of <a href="blockaccess.html#search">ba_search</a> also sets this to (-1, -1). When every record of the relation has been searched, <a href="blockaccess.html#linear_search">Linear search algorithm</a> sets the value to (-1, -1). </li>
                                <li><i>attr_list</i>: Head of the linked list storing the <a href="#attribute_cache">attribute catalog cache</a> of the corresponding relation.</li>
                			</ol>
                        	<center><img class="img-fluid" src="/img/openreltable.png"></center>
                        	<p>The above figure shows the structure of Open relation table.</p>
                            <p>Relation catalog and the attribute catalog are the only two "default" relations in Nitcbase. <b>The catalogs (which store meta-information about other relations) are themselves treated as relations by Nitcbase</b>.  Hence both the relation catalog and the attribute catalog contain entries corresponding to themselves.  The relation catalog entry for <a href="../storage-model.html#relcat"><i>Relation Catalog</i></a> has <i>Relname="relcat"</i>.   The relation catalog entry for the <a href="../storage-model.html#attrcat"><i>attribute catalog</i></a> has <i>Relname="attrcat"</i>.  The attribute catalog will contain default entries corresponding each attribute of the relation catalog and each attribute of the attribute catalog.  The relation catalog and the attribute catalog are always open, with predefined relation ids as 0 and 1 respectively. Consequently, the first and the second entries of the open relation table corresponds to the Relation Catalog and the Attribute Catalog respectively.</p>
                			<p>Open Relation Table is a static class<span style="color: dodgerblue">*</span>. <b>This means that there exists only a single static object of the class at any point of time</b>. The actual table (data) is private to the class and access to the information is provided through public methods which define interface to the cache layer. Since all interfaces are static, they can be called on the class name instead of calling on an instance (as the object is allocated statically). The class structure of the open relation table showing its public interfaces is shown below.</p>
                            <p><b><span style="color: dodgerblue">*</span>Implementation note:</b>  In the case of the class <i>OpenRelTable</i>, only a single instance of this class needs to be created when NITCbase is running. One of the ways of implementing such a class is to declare all member fields and methods of the class <b>static</b>. By doing so, memory will be allocated <a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">statically</a> for all variables of the class and any access to the member fields of the class will refer to the same statically allocated memory for the member field.  As the methods of the class are <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank">static</a>, C++ allows them to  be accessed using  the semantics <i>classname::methodname()</i>  (instead of <i>objectinstance->methodname()</i> as in the case of methods that are not declared statically).  Static methods in a class are allowed to access only static members of the class. Since the class is static, you need to create only a single object  of the class whose sole purpose is to run the <a href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)">constructor</a> and the <a href="https://en.wikipedia.org/wiki/Destructor_(computer_programming)">destructor</a>.</p>
                            
                            <div class="code">
                                <pre><code>typedef struct OpenRelTableEntry{
	RelCatEntry relcat_entry;
	struct AttributeCacheEntry *attr_list_head;
	bool free, dirty;
	recId rec_id, prev_recid;
}OpenRelTableEntry;


class OpenRelTable{
private:
	static OpenRelTableEntry rel_table[MAXOPEN];
	static relId getFreeOpenRelTableEntry();
	
public:	
    void openRelTable();
    void ~openRelTable();
	static relId OpenRel(char rel_name[ATTR_SIZE]);
	static int CloseRel(relId rel_id);
	static int getRelCatEntry(relId rel_id, RelCatEntry *relcat_buf);
	static int setRelCatEntry(relId rel_id, RelCatEntry *relcat_buf);
	static recId getPrevRecId(relId rel_id); /*CHANGE INTERFACE HERE*/
	static int setPrevRecId(relId rel_id, recId rid);
	static int getAttrCatEntry(relId rel_id, char attr_name[ATTR_SIZE], AttrCatEntry *attrcat_buf);
	static int getAttrCatEntry(relId rel_id, int attr_offset, AttrCatEntry *attrcat_buf);
	static int setAttrCatEntry(relId rel_id, char attr_name[ATTR_SIZE], AttrCatEntry *attrcat_buf);
	static int setAttrCatEntry(relId rel_id, int attr_offset, AttrCatEntry *attrcat_buf);
	static IndexId getPrevIndexId(relId rel_id, char attr_name[ATTR_SIZE]);
	static IndexId getPrevIndexId(relId rel_id, int attr_offset);
	static int setPrevIndexId(relId rel_id, char attr_name[ATTR_SIZE], IndexId prev_indid);
	static int setPrevIndexId(relId rel_id, int attr_offset, IndexId prev_indid);
	static relId getRelId(char rel_name[ATTR_SIZE]);
};</code></pre>
                            </div>
                            
                        </div>
                        
                        
                        <div class="pagetitle" id="methods">
                            <h1>Methods of Cache Layer</h1>
                        </div>
                        
                        <div class="detail" id="constructor">
                            <h2>openRelTable (Constructor)</h2>
                            <h5>Arguments:</h5>
                            <p>Nil</p>
                            <h5>Return type:</h5>
                            <p>void</p>
                            <h5>Description:</h5>
                            <p>It initializes the open relation table. It also opens <a href="../storage-model.html#relcat">relation catalog</a> and <a href="../storage-model.html#attrcat">attribute catalog</a> with relId 0 and 1 respectively. </p>
                            <p><b>Note:</b> Since the first block numbers of relation catalog and attribute catalog are known to us (they are fixed), we can directly fetch the entries from the disk blocks and populate the table.</p>
                            <h5><a data-toggle="collapse" href="#algo-constructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-constructor" class="collapse">
                                <div class="code">
                                    <pre><code>OpenRelTable::OpenRelTable(){
	
	//Initialize all open relation table entries as free and set the dirty flag to false. 
	
	/************Loading the relation catalog entries***********/
    
	//Let <i>block_num</i> and <i>slot_num</i> be the block and slot numbers of the relation catalog
	RecBuffer *buffer = Buffer::<a href="buffer.html#getrecblk">getRecBlock</a>(block_num);
	//let <i>relcat_rec</i> be an array of type <a href="buffer.html#block_structures">union Attribute</a>
	//get the record corresponding to relation catalog into relcat_rec
	buffer->getRecord(relcat_rec,slot_num); 
	// Now copy the fields from the record to the 0<sup>th</sup> entry of the open relation table. 
	// since the default relation id of relation catalog is 0
	
	//Let <i>block_num</i> and <i>slot_num</i> be the block and slot numbers of the attribute catalog
	//let <i>attrcat_rec</i> be an array of type union Attribute
	//get the record corresponding to attribute catalog into attrcat_rec
	buffer->getRecord(attrcat_rec,slot_num); 
	// Now copy the fields from the record to the 1<sup>st</sup> entry of the open relation table. 
	// since the default relation id of attribute catalog is 1
	
	//Set the prev_recid field in both the entries to (-1, -1)
	//Set the free bit to false for both the entries.
	
	delete buffer;
	
	/************Loading the attribute catalog entries***********/
	
	//Let block_num be the first block number of the attribute catalog
	RecBuffer *buffer = Buffer::<a href="buffer.html#getrecblk">getRecBlock</a>(block_num);
	//First 5 slots in this block corresponds to the attribute catalog entries of the relation catalog
	// get the records from all the slots using getRecBlock of Buffer layer
	// and arrange them as a linked list by filling all the fields of AttributeCacheEntry. (Attribute cache of relation catalog)
	
	// Next 6 slots in this block corresponds to the attribute catalog entries of the relation catalog
	// get the records from all the slots using getRecBlock of Buffer layer
	// and arrange them as a linked list by filling all the fields of AttributeCacheEntry. (Attribute cache of attribute catalog)
	
	//Set the prev_indid of all attributes to (-1, -1).
	
	delete buffer;
		
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="detail" id="destructor">
                            <h2>~openRelTable (Destructor)</h2>
                            <h5>Arguments:</h5>
                            <p>Nil</p>                            
                            <h5>Return type:</h5>
                            <p>void</p>
                            <h5>Description:</h5>
                            <p>This closes all opened relations except the relation catalog and the attribute catalog. Entries corresponding to the relation catalog and attribute catalog will be committed back to the disk in the respective block and slot if they are marked as dirty.</p>
                            <h5><a data-toggle="collapse" href="#algo-destructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-destructor" class="collapse">
                                <div class="code">
                                    <pre><code>OpenRelTable::~OpenRelTable(){

	// Close all the opened relations except relation catalog and attribute catalog
	// using openRelTable::close() method.
	
	// Iterate over the linked list (Attribute Cache) of both the catalogs
	//     Commit the entry to the disk if it is dirty
	//     free the node from the list
	
	// Commit the relCatEntry of relation catalog and attribute catalog to
	// the disk if they are dirty.
	
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="detail" id="rectorelcat">
                            <h2><i>private</i> recordtoRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>record</td>
								        <td>union Attribute[RELCAT_SIZE]</td>
								        <td></td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>RelCatEntry</td>
						                <td></td>
						            </tr>
		                     	</table>
		                     </div>
                            <h5>Description:</h5>
                            <p>This is an utility function that converts the array of <a href="buffer.html#block_structures">union Attribute</a> (record) to <a href="#relation_cache">RelCatEntry</a> structure. The details of the implementation are left to you.</p>
                        </div>
                        
                        <div class="detail" id="rectoattrcat">
                            <h2><i>private</i> recordtoAttrCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>record</td>
								        <td>union Attribute[ATTRCAT_SIZE]</td>
								        <td></td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>AttrCatEntry</td>
						                <td></td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This is an utility function that converts the array of <a href="buffer.html#block_structures">union Attribute</a> (record) to <a href="#attribute_cache">AttrCatEntry</a> structure. The details of the implementation are left to you.</p>
                        </div>
                        
                        <div class="detail" id="relcattorec">
                            <h2><i>private</i> relCatEntrytoRecord</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>relcat_entry</td>
								        <td>RelCatEntry</td>
								        <td></td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>union Attribute *</td>
						                <td></td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This is an utility function that converts <a href="#relation_cache">RelCatEntry</a> structure to the array of <a href="buffer.html#block_structures">union Attribute</a> (record). The details of the implementation are left to you.</p>
                        </div>
                        
                        <div class="detail" id="attrcattorec">
                            <h2><i>private</i> attrCatEntrytoRecord</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>attrcat_entry</td>
								        <td>AttrCatEntry</td>
								        <td></td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>union Attribute *</td>
						                <td></td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This is an utility function that converts <a href="#attribute_cache">AttrCatEntry</a> structure to the array of <a href="buffer.html#block_structures">union Attribute</a> (record). The details of the implementation are left to you.</p>
                        </div>
                        
                        <div class="detail" id="getfreeentry">
                            <h2><i>private</i> getFreeOpenrelTableEntry</h2>
                            <h5>Arguments:</h5>
                            <p>Nil</p>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>int</td>
						                <td>the index to a free entry in the open relation table</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>It searches for the free entry in the open relation table and returns it.  The details of the implementation are left to you. </p>
                        </div>
                        
                        <div id="openrel" class="detail">
                            <h2><i>public:</i> OpenRel</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>relName</td>
								        <td>char[ATTR_SIZE]</td>
								        <td>Name of Relation that has to be opened in cache.</td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>relId</td>
						                <td>Returns the relId on succesful opening of the relation</td>
						            </tr>
						            <tr>
						                <td>E_RELNOTEXIST</td>
						                <td>If the relation with name relName does not exist in the disk</td>
						            </tr>
						            <tr>
						                <td>E_CACHEFULL</td>
						                <td>If there are no free slots in the Open Relation table.</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This method Opens the relation specified as name in cache/OpenRelTable.</p>

							<h5><a data-toggle="collapse" href="#algo-openrel"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-openrel" class="collapse">
                                <div class="code"><pre><code>relId OpenRelTable::OpenRel(char relName[ATTR_SIZE]){

	//check if the relation with relation name <i>relName</i> already opened
	relid = OpenRelTable::getRelId(relName);
	if(relid != E_NOTOPEN){
		return relid;
	}
	
	//find a free slot in the relation cache
	//if free slot is not found in the relation cache
		return E_CACHEFULL;
	
	//search for the relation catalog entry with relation name <i>relName</i> in the <a href="buffer.html#relcat">relation catalog</a> 
	relcat_recid = <a href="blockaccess.html#linear_search" target="_blank">linear_search</a>(RELCAT_RELID, "<span style="color: deeppink">relation_name</span>", relName, EQ);
    //Note: The name of the 0<sup>th</sup> attribute in the relation catalog is <span style="color: deeppink">relation_name</span>
	if(relcat_recid == {-1, -1}){ //if relation is not found in the relation catalog
		return E_RELNOTEXIST;
	}
	
	//Iterate over all the attributes corresponding to the relation with relation name=<i>relName</i>{
            //search for the attributes with relation name <i>relName</i> in the attribute catalog 
            //using <a href="blockaccess.html#linear_search" target="_blank">linear_search</a> of the block access layer.

            //get the attribute catalog record corresponding to attrcat_recid from the <a href="buffer.html#attrcat">attribute catalog</a>
            rec_buffer = Buffer::<a href="buffer.html#getrecblk" target="_blank">getRecBlock</a>(attrcat_recid.block);
            rec_buffer-><a href="buffer.html#getrecord" target="_blank">getRecord</a>(attrcat_record, attrcat_recid.slot);

            //since attribute cache is implemented as a linked list
            //Create a new node of the type <a href="#attribute_cache">AttributeCacheEntry</a> for the attribute
            /*Convert the attribute catalog entry from the record structure
              to the structure AttrCatEntry using <a href="#rectoattrcat">RecordtoAttrCatEntry</a>()
              and assign it to attrcat_entry field of the created new node.*/
            //initialize the meta information of the attribute cache entry node as follows
            // set the dirty flag in AttributeCacheEntry to false
            // set the <a href="buffer.html#misc">prev_indid</a> to (-1, -1)
            // set the recid to the id returned by linear_search.

            //Add the node to the attribute cache linked list.
	//}
	AttrCacheEntry *attrlist_head = head of the linked list of Attribute Cache entries.

	//get the relation catalog entry with relation name <i>relName</i> from the relation catalog
	rec_buffer = Buffer::<a href="buffer.html#getrecblk" target="_blank">getRecBlock</a>(relcat_recid.block); //(recid of the relation record = relcat_recid)
	rec_buffer->getRecord(&amp;relcat_entry, relcat_recid.slot);
    /*Convert the relation catalog entry from the record structure
		  to the structure RelCatEntry using <a href="#rectorelcat">RecordtoRelCatEntry</a>() */
													    
	//initialize the meta information of the relation cache node as follows
    //set the free flag to false and <a href="buffer.html#misc">prev_recid</a> to (-1, -1)
    //set the recid to the value returned by linear search (relcat_recid)
    //set the attribute cache head to the attr_list_head field.
	
	
	return relid;
}</code></pre></div>

                            </div>
                        </div>
                        
                        <div id="closerel" class="detail">
                            <h2><i>public:</i> CloseRel</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                            <tr>
								        <td>relid</td>
								        <td>int</td>
								        <td>Relation Id of Relation that has to be closed from cache.</td>
								    </tr>
		                        </table>
		                    </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
		                        <table class="table table-bordered table-hover">
		                        	<tr>
						                <td>SUCCESS</td>
						                <td>On successful closing of the relation with id relid</td>
						            </tr>
						            <tr>
						                <td>E_OUTOFBOUND</td>
						                <td>If the relid is out of the range 0-MAXOPEN</td>
						            </tr>
						            <tr>
						                <td>E_NOTOPEN</td>
						                <td>If there is no open relation exist corresponding to the id given by relid</td>
						            </tr>
		                     	</table>
		                     </div>

                            <h5>Description:</h5>
                            <p>This method closes the relation specified as name in cache/OpenRelTable.</p>

							<h5><a data-toggle="collapse" href="#algo-closerel"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div class="collapse" id="algo-closerel">
                                <div class="code"><pre><code>int OpenRelTable::CloseRel(relId relid){

	if(<i>relid</i>&lt; 0 || <i>relid</i>&gt;= MAXOPEN){	//check whether relation id (<i>relid</i>) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[<i>relid</i>].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache of the relation{
		//if the attribute catalog entry is modified (i.e, dirty flag is set){
			//The following code commits the attribute catalog entry into the disk
			/*We can extract the (block_num, slot_num) of the attribute catalog entry
			using meta information in the attribute cache*/
			rec_buffer= Buffer::<a href="buffer.html#getrecblk" target="_blank">getRecBlock</a>(block_num);	

			/*Convert the cached attribute catalog entry from the structure AttrCatEntry 
			  to the format of the record structure*/
			record = <a href="#attrcattorec">AttrCatEntrytoRecord</a>(attrcat_entry);

			//commit the attribute catalog entry to the disk (buffer)
			rec_buffer-><a href="buffer.html#setrecord" target="_blank">setRecord</a>(record, slot_num); 
		//}
		//free the attribute catlog node in the attribute cache linked list
	//}
	
	//if the relation catalog entry in the relation cache of the relation is modified{
		//commit the relation catalog entry to the disk
		/*We can extract the (block_num, slot_num) of the relation catalog entry
		  using meta information in the relation cache*/
		rec_buffer= Buffer::getRecBlock(block_num);	

		/*Convert the cached relation catalog entry from the structure RelCatEntry 
		  to the format of the record structure*/
		record = <a href="#relcattorec">RelCatEntrytoRecord</a>(relcat_entry);

		//commit the relation catalog entry to the disk(buffer)
		buffer->setRecord(record, slot_num); 
	//}
	return SUCCESS;
}</code></pre></div>

                                </div>
                        </div>
                        
                        <div id="getrelid" class="detail">
                            <h2><i>public:</i> getRelId</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relName</td>
                                        <td>char[ATTR_SIZE]</td>
                                        <td>Name of the Relation.</td>
                                    </tr>
                                </table>
                            </div>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>Returns the relId corresponding to the relation with name relName, if it is already open</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If the relation with name relName is not open</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This methods gives the Relation Id of the specified relation in cache(OpenRelTable).</p>
                            
                            <h5><a data-toggle="collapse" href="#algo-getrelid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getrelid" class="collapse">
                                <div class="code"><pre><code>relId OpenRelTable::getRelId(char relName[ATTR_SIZE]){
	//Iterate over the relation cache{
		//if relation with relation name relName is opened in the relation cache
			return relid //return corresponding relid
	//}
	return E_NOTOPEN;
}</code></pre></div>                            
                            
                            </div>
                            
                        </div>

                        <div id="getrelcatentry" class="detail">
                            <h2><i>public:</i> getRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation.</td>
                                    </tr>
                                    <tr>
                                        <td>relcat_buf</td>
                                        <td>RelCatEntry *</td>
                                        <td>pointer to the buffer of type RelCatEntry into which the relation catalog entry is to be copied from the relation cache.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>On successful copy of the relation catalog entry corresponding to the relation with id relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method gives the Relation catalog(struct RelcatEntry) of specified relation in cache(OpenRelTable).</p>

                            <h5><a data-toggle="collapse" href="#algo-getrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getrelcatentry" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::getRelCatEntry(relId relid, RelCatEntry *relcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relation catalog in the relation cache to the relcat_buf
	return SUCCESS;
}</code></pre>
                                </div> 
                                
                            </div>
                        </div>

                        <div id="setrelcatentry" class="detail">
                            <h2><i>public:</i> setRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation.</td>
                                    </tr>
                                    <tr>
                                        <td>relcat_buf</td>
                                        <td>RelCatEntry *</td>
                                        <td>pointer to the buffer of type RelCatEntry from which the relation catalog entry is to be copied into the relation cache. <br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class=retval>
                                <h5>Return value:</h5>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <tr>
                                            <td>SUCCESS</td>
                                            <td>On successful copy of the relation catalog entry corresponding to the relation with id relid</td>
                                        </tr>
                                        <tr>
                                            <td>E_OUTOFBOUND</td>
                                            <td>If the relid is out of the range 0-MAXOPEN</td>
                                        </tr>
                                        <tr>
                                            <td>E_NOTOPEN</td>
                                            <td>If there is no open relation exist corresponding to the id given by relid</td>
                                        </tr>

                                    </table>
                                </div>
                            </div>

                            <h5>Description:</h5>
                            <p>This method sets the Relation catalog(struct RelcatEntry) of specified relation in cache(OpenRelTable).</p>

                            <h5><a data-toggle="collapse" href="#algo-setrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setrelcatentry" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::setRelCatEntry(relId relid, RelCatEntry *relcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//copy the relcat_buf to the relation catalog in the relation cache
	//set the dirty flag corresponding to the relation with Id relid in the relation cache
	return SUCCESS;
}</code></pre>
                                </div> 
                                
                            </div>
                        </div>

                        <div id="getprevrecid" class="detail">
                            <h2><i>public:</i> getPrevRecId</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>recidbuff_ptr</td>
                                        <td>recId *</td>
                                        <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair).<br> The record id field of the previous hit stored in the meta information of the relation cache is to be copied into recid_ptr.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If record id of previous hit is copied to recid. It means that the id pointed by recid is valid.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method gives the value of <i>prevrecid</i> field corresponding to the specified relation in cache.(note: this is used to track the record found in previous search and next search can start searching afer previously found record)</p>

                            <h5><a data-toggle="collapse" href="#algo-getprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getprevrecid" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::getPrevRecId(relId relid, recId *recidbuff_ptr){
	if(relid&lt; 0 || relid&gt;= MAXOPEN){//check whether relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation in the relation cache to the recidbuff_ptr*/
	return SUCCESS;
}</code></pre>
                                </div> 
                                
                            </div>
                        </div>

                        <div id="setprevrecid" class="detail">
                            <h2><i>public:</i> setPrevRecId</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>recidbuff_ptr</td>
                                        <td>recId *</td>
                                        <td>pointer to buffer of type recId (recId is a structure carrying a (block_num, slot_num) pair).<br> The record id field of the previous hit is to be stored to the meta information of the relation cache from  recid_ptr.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If the record id is successfully copied into the Relation Catalog Cache.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method sets the value of <i>prevrecid</i> field corresponding to the specified relation in cache.</p>

                            <h5><a data-toggle="collapse" href="#algo-setprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setprevrecid" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::setPrevRecId(relId rel_id, recId *recidbuff_ptr){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	/*copy the previous record id of the relation from the recidbuff_ptr to the relation cache*/
	return SUCCESS;
}</code></pre>
                                </div>
                                
                            </div>
                        </div>

                        <div id="getattrcatentry" class="detail">
                            <h2><i>public:</i> getAttrCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>attrName/attr_offset</td>
                                        <td>char[ATTR_SIZE] / int</td>
                                        <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                    </tr>
                                    <tr>
                                        <td>attrcat_buf</td>
                                        <td>AttrCatEntry *</td>
                                        <td>pointer to the buffer of type AttrCatEntry where the attribute catalog entry is to be copied.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>On successful copy of the attribute catalog entry corresponding to the relation with id relid and attribute with name attrName or having offset attr_offset</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_ATTRNOTEXIST</td>
                                        <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This methods gives the Attribute catalog entry(AttrCatEntry) corresponding to attribute present in a relation as specified in arguments.</p>

                            <h5><a data-toggle="collapse" href="#algo-getattrcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getattrcatentry" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::getAttrCatEntry(relId relid, char attr_name[ATTR_SIZE/int attr_offset, AttrCatEntry *attrcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			//copy the attribute catalog in the attribute cache to the attrcat_buf
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                                </div> 
                                
                            </div>
                        </div>

                        <div id="setattrcatentry" class="detail">
                            <h2><i>public:</i> setAttrCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>attrName/attr_offset</td>
                                        <td>char[ATTR_SIZE] / int</td>
                                        <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                    </tr>
                                    <tr>
                                        <td>attrcat_buf</td>
                                        <td>AttrCatEntry *</td>
                                        <td>pointer to the buffer of type AttrCatEntry from where the attribute catalog entry is to be copied to the Attribute catalog cache.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover ">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>On successful copy of the attribute catalog entry into the cache corresponding to the relation with id relid and attribute with name attrName or having offset attr_offset</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_ATTRNOTEXIST</td>
                                        <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This methods sets the Attribute catalog entry(AttrCatEntry) corresponding to attribute present in a relation as specified in arguments.</p>

                            <h5><a data-toggle="collapse" href="#algo-setattrcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div class="collapse" id="algo-setattrcatentry">
                                <div class="code"><pre><code>int OpenRelTable::setAttrCatEntry(relId relid, char attr_name[ATTR_SIZE/int attr_offset, AttrCatEntry *attrcat_buf){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			//copy the attrcat_buf to the corresponding attibute node in the attribute cache
			//set the dirty flag corresponding to the attribute in the attribute cache
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                                </div> 
                                
                            </div>
                        </div>

                         <div id="getprevindexid" class="detail">
                            <h2><i>public:</i> getPrevIndexId</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>attrName/attr_offset</td>
                                        <td>char[ATTR_SIZE] / int</td>
                                        <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                    </tr>
                                    <tr>
                                        <td>indid</td>
                                        <td>IndexId *</td>
                                        <td>pointer to buffer of type IndexId where the index id is to be copied.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                             </div>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>
                                <h5>Return value:</h5>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <tr>
                                            <td>SUCCESS</td>
                                            <td>If index id of previous hit is copied to indid. It means that the id pointed by indid is valid.</td>
                                        </tr>
                                        <tr>
                                            <td>E_OUTOFBOUND</td>
                                            <td>If the relid is out of the range 0-MAXOPEN</td>
                                        </tr>
                                        <tr>
                                            <td>E_NOTOPEN</td>
                                            <td>If there is no open relation exist corresponding to the id given by relid</td>
                                        </tr>
                                        <tr>
                                            <td>E_ATTRNOTEXIST</td>
                                            <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                        </tr>

                                    </table>
                                </div>

                            <h5>Description:</h5>
                            <p>This method gives the value of <i>sid</i> field of an attribute present in the relation as speified in arguments.<br>(note: this is used to track the record found in previous search and next search can start searching afer previously found record)</p>

                            <h5><a data-toggle="collapse" href="#algo-getprevindexid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getprevindexid" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::getPrevIndexId(relId relid, char attr_name[ATTR_SIZE/int attr_offset, IndexId *indid){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			/*copy the previous index id (in meta informatiom) corresponding to 
			  the attribute in the attribute cache to the indid*/
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                                </div> 
                                
                             </div>
                        </div>

                        <div id="setprevindexid" class="detail">
                            <h2><i>public:</i> setPrevIndexId</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relid</td>
                                        <td>int</td>
                                        <td>Relation Id of the Relation</td>
                                    </tr>
                                    <tr>
                                        <td>attrName/attr_offset</td>
                                        <td>char[ATTR_SIZE] / int</td>
                                        <td>Name of attribute / offset of target attribute (this is an overloaded funtion).</td>
                                    </tr>
                                    <tr>
                                        <td>indid</td>
                                        <td>IndexId *</td>
                                        <td>pointer to buffer of type IndexId from where the index id is to be copied into the Attribute catalog cache.<br>WARNING: The caller should have allocated memory to the pointer.</td>
                                    </tr>
                                </table>
                            </div>
                            <p><b>Note:</b>This method is overloaded in type of the second argument</p>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>SUCCESS</td>
                                        <td>If index id pointed by indid is successfully copied to the Attribute catalog cache.</td>
                                    </tr>
                                    <tr>
                                        <td>E_OUTOFBOUND</td>
                                        <td>If the relid is out of the range 0-MAXOPEN</td>
                                    </tr>
                                    <tr>
                                        <td>E_NOTOPEN</td>
                                        <td>If there is no open relation exist corresponding to the id given by relid</td>
                                    </tr>
                                    <tr>
                                        <td>E_ATTRNOTEXIST</td>
                                        <td>If there is no attribute with name attrname or having offset attr_offset</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>This method sets the value of <i>sid</i> field of an attribute present in the relation as speified in arguments.</p>

                            <h5><a data-toggle="collapse" href="#algo-setprevindexid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setprevindexid" class="collapse">
                                <div class="code"><pre><code>int OpenRelTable::setPrevIndexId(relId relid, char attr_name[ATTR_SIZE/int attr_offset, IndexId *indid){
	if(rel_id&lt; 0 || rel_id&gt;= MAXOPEN){	//check relation id (relid) lies in the range
		return E_OUTOFBOUND;
	}
	if(Rel_Table[relid].free){ //slot corresponding to the relid in the relation is free
		return E_NOTOPEN;
	}
	
	//Iterate over all the attributes in the attribute cache corresponding to the relation with Id relid{
		//if the attrName/attr_offset of the attribute equals to the given attrName/attr_offset{
			/*copy the indid to the previous index id (in meta informatiom)
			  corresponding to the attribute in the attribute cache*/
			return SUCCESS;
		//}
	//}
	return E_ATTRNOTEXIST;
}</code></pre>
                                </div>
                                
                            </div>
                        </div>
                        ------------------------------------------------------------------>


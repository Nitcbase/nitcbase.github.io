<!DOCTYPE HTML>
<html>

<head>
    <title>Cache Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            	<li> <a class="sec" href="#layout"> Layout</a></li>
				
				<li> <a class="sec" href="#relid"> RelID</a></li>
				
				<li> <a class="sec" data-toggle="collapse" href="#relcache_structures_card" role="button" aria-expanded="false" aria-controls="relcache_structures_card"> RelCache table structures</a></li>
				<div class="collapse" id="relcache_structures_card"><div class="card card-body">
                            	<ul>
					<li><a href="#relation_cache">structure details</a> </li>
                                	<li><a href="#rel_cat_entry">RelCatEntry</a> </li>
                                 	<li><a href="#rel_cache_entry">RelCacheEntry</a> </li>
                            	</ul>
                                </div></div>
				
				<li> <a class="sec" data-toggle="collapse" href="#attrcache_structures_card" role="button" aria-expanded="false" aria-controls="attrcache_structures_card"> AttrCache table structures</a></li>
				<div class="collapse" id="attrcache_structures_card"><div class="card card-body">
                            	<ul>
					<li><a href="#attribute_cache">structure details</a> </li>
                                	<li><a href="#attr_cat_entry">AttrCatEntry</a> </li>
                                 	<li><a href="#attr_cache_entry">AttrCacheEntry</a> </li>
                            	</ul>
                                </div></div>
				
				<li> <a class="sec" href="#openrel_table_struct"> OpenRelTable Structure</a></li>
				
				<li> <a class="sec" data-toggle="collapse" href="#RelCacheTable_card" role="button" aria-expanded="false" aria-controls="RelCacheTable_card"> class RelCacheTable</a></li>
				<div class="collapse" id="RelCacheTable_card"><div class="card card-body">
                            	<ul>
					<li><a href="#rel_cache_table_class">class RelCacheTable</a> </li>
                                	<li><a href="#getrelcatentry">getRelCatEntry()</a> </li>
                                 	<li><a href="#setrelcatentry">setRelCatEntry()</a> </li>
					<li><a href="#getsearchindex0">getSearchIndex()</a> </li>
					<li><a href="#setsearchindex0">setSearchIndex()</a> </li>
					<li><a href="#rectorelcache">recordToRelCacheEntry()</a> </li>
					<li><a href="#relcachetorec">relCacheEntryToRecord()</a> </li>
                            	</ul>
                                </div></div>
				
				<li> <a class="sec" data-toggle="collapse" href="#AttrCacheTable_card" role="button" aria-expanded="false" aria-controls="AttrCacheTable_card"> class AttrCacheTable</a></li>
				<div class="collapse" id="AttrCacheTable_card"><div class="card card-body">
                            	<ul>
					<li><a href="#attr_cache_table_class">class AttrCacheTable</a> </li>
                                	<li><a href="#getattrcatentry">getAttrCatEntry()</a> </li>
                                 	<li><a href="#setattrcatentry">setAttrCatEntry()</a> </li>
					<li><a href="#getsearchindex1">getSearchIndex()</a> </li>
					<li><a href="#setsearchindex1">setSearchIndex()</a> </li>
					<li><a href="#rectoattrcache">recordToAttrCacheEntry()</a> </li>
					<li><a href="#attrcachetorec">attrCacheEntryToRecord()</a> </li>
                            	</ul>
                                </div></div>
				
				<li> <a class="sec" data-toggle="collapse" href="#OpenRelTable_card" role="button" aria-expanded="false" aria-controls="OpenRelTable_card"> class OpenRelTable</a></li>
				<div class="collapse" id="OpenRelTable_card"><div class="card card-body">
                            	<ul>
					<li><a href="#open_rel_table_class">class OpenRelTable</a> </li>
                                	<li><a href="#open_rel_table_constructor">OpenRelTable Constructor</a> </li>
                                 	<li><a href="#open_rel_table_destructor">~OpenRelTable Destructor</a> </li>
					<li><a href="#getrelid">getRelId()</a> </li>
					<li><a href="#openrel">openRel()</a> </li>
					<li><a href="#closerel">closeRel()</a> </li>
					<li><a href="#deleterel">deleteRel()</a> </li>
					<li><a href="#get_free_open_rel_table_entry">getFreeOpenRelTableEntry()</a> </li>
                            	</ul>
                                </div></div>

                          
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>Cache Layer</h1>
                        </div>
			    <div id="prerequisite" class=detail>
				<h5>Pre-requisite Reading:</h5>
					<ul>
						<li> <a href="../storage-model.html" target="_blank">Physical Layer</a></li>
						<li> <a href="buffer.html" target="_blank">Buffer Layer</a></li>
					</ul>
					<br>
					<br>
								
											    
			    </div>
                        
                         <div id="layout" class="detail">
                            	<h2>Layout</h2>
                             	<p>Almost all operations on a relation require access to its corresponding <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> and <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog</a> entries. NITCbase stores these catalogs as relations in the disk. To prevent multiple reads and write backs of the catalog blocks, the <i>Cache Layer</i> caches the catalog blocks along with some extra metadata associated with the relation that allows faster and easier processing of operations such as search. The <i>Cache Layer</i>, thus, provides an interface for catalog access to the higher layers by hiding the storage and maintenance details of the catalogs. <i>Cache Layer</i> can cache a maximum of <a href="/constants.html#constants" target="_blank">MAX_OPEN</a> number of relations at any given time. NITCbase requires that the relation be first loaded to cache memory before any operation is performed on it. </p>
				<p>Three tables are used by NITCbase for caching Catalogs- the <i>Relation Cache Table</i> for Relation Catalog entries, the <i>Attribute Cache Table</i> for Attribute Catalog entries and the <i>Open Relation Table</i> for operations that include both Relation and Attribute Catalogs. </p>
				<p>NITCbase follows an Object-Oriented design for Cache Layer. The class diagram is as shown below. </p> 
                            <center><img class="img-fluid" src="/img/cache_class_new.png"></center>
				 
                        </div>
		<!----------------relId--------------------------------------------------------------->        	    
			<div id="relid" class="detail">
                            	<h2>relId</h2>
                             	<p>Any relation that is stored in the cache memory will have an entry in each of the three tables- <i>Relation Cache Table</i>, <i>Attribute Cache Table</i>, and <i>Open Relation Table</i>. An <i>open relation</i> is a relation that has been loaded to the cache memory while a <i>closed relation</i> is one that is not loaded to the cache memory. NITCbase is designed in such a way that the entries in all the three tables will be stored at the same index. This common index is called the <i>relId</i> of the relation. All further operations on the relation require this <i>relId</i>. </p> 
                        </div>
                <!----------------Relation Cache Table Structues--------------------------------------------------------------->        
                        <div id="relation_cache" class="detail">
                        <h2>Relation Cache Table Structures</h2>
                            <p>The <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> block in the disk stores metadata coresponding to all the relations in the database. In addition to this, the Relation Catalog entry of every open relation is loaded to the cache memory for easy access and for better performance. This is implemented using <i>Relation Cache Table</i>. Each entry in the <i>Relation Cache Table</i> stores all the attribute values of the relation's entry from the Relation Catalog block along with some additional meta-data.
			    </p>
			    <p>NITCbase caches Relation Catalog using two structures: <i>RelCatEntry</i> and <i>RelCacheEntry</i>.</p>
                		<div id="rel_cat_entry" class="subsec">
						<h4>RelCatEntry </h4>
						<p>The structure <i>RelCatEntry</i> stores in its data fields all the attribute values in the relation's record entry from the <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> block. </p>
<div class="code"><pre><code>typedef struct RelCatEntry{

	char relName[ATTR_SIZE];
	int numAttrs;
	int numRecs;
	int firstBlk;          
	int lastBlk;
	int numSlotsPerBlk;      

} RelCatEntry;</code></pre>
					</div>
              			</div>
				<div id="rel_cache_entry" class="subsec">
					<h4>RelCacheEntry</h4>
					<p>The structure <i>RelCacheEntry</i> stores the <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> entry of the relation along with some additonal information used during runtime.</p>

<div class="code"><pre><code>typedef struct RelCacheEntry {

	RelCatEntry relCatEntry;
	bool dirty;
	RecId recId;
	RecId searchIndex;

} RelCacheEntry;</code></pre>
					</div>
					<p> The RelCacheEntry data field details are as follows:
						<ul>

							<li><i>relCatEntry</i>: Stores the relation's cached <a href="#rel_cat_entry">Relation Catalog entry</a>.</li>
							<li><i>dirty</i>: Indicates whether the Relation Catalog entry has been modified. The Relation Catalog entries with the set dirty bit are written back to disk when an open relation is closed in the cache memory.</li>
							<li><i>recId</i>: Stores the <a href="buffer.html#recid" target="_blank"> record id</a> {blockNum, slotNum} of the relation's entry in the Relation Catalog block on the disk. This is useful during the write back of the catalog entry to disk if it had been modified.</li>
							<li><i>searchIndex</i>: Stores the <a href="buffer.html#recid" target="_blank"> record id</a> {blockNum, slotNum} of the <a href="../storage-model.html#record_blk" target="_blank">record block</a> corresponding to the <b>last (previous) search hit</b> in the relation. <a href="blockaccess.html#linear_search" target="_blank">Linear search algorithm</a> of the <a href="blockaccess.html" target="_blank">Block Access Layer</a> starts searching for the next hit from the previous hit location. The entries are initialized to {-1, -1} each time the relation is loaded to the cache memory. When every record of the relation has been searched, the linear search algorithm resets the searchIndex value to {-1, -1}. </li> 

						</ul>
					</p>
              			</div>
						
		      </div>
		
	<!----------------Attribute Cache Table Structures--------------------------------------------------------------->
                        <div id="attribute_cache" class="detail">
                            	<h2>Attribute Cache Table Structures</h2>
                            	<p>The <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog</a> blocks, analogous to the Relation Catalog block, stores the meta information of the attributes of all the relations in the database. 
				    In addition to this, the Attribute Catalog entries of every <i>open relation</i> is also loaded to the cache memory.
				    This is implemented using <i>Attribute Cache Table</i>.
				    Each entry in the <i>Attribute Cache Table</i> stores the entries corresponding to each attribute 
				    of the relation in the form a linked list along with some additional meta-data.</p>
				<p>NITCbase caches Attribute Catalog using two structures: <i>AttrCatEntry</i> and <i>AttrCacheEntry</i>.</p>
                            
                            	<div id = "attr_cat_entry" class= "subec">
				    <h4>AttrCatEntry</h4>
				    <p>The structure <i>AttrCatEntry</i> stores in its data fields all the attribute values in the record entry corresponding to one of the relation's attribute from an <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog</a> block. </p>
				    <div class="code"><pre><code>     
typedef struct AttrCatEntry {

	char relName[ATTR_SIZE];
	char attrName[ATTR_SIZE];
	int attrType;
	bool primaryFlag;
	int rootBlock;
	int offset;

} AttrCatEntry;</code></pre></div>
			    </div>
				
			<div id = "attr_cache_entry" class= "subec">
			    <h4>AttrCacheEntry</h4>
			    <p>The structure <i>AttrCacheEntry</i> stores the <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog</a> entry of an attribute of the relation along with some additonal information used during runtime.
				 Since a relation can have variable number of attributes, a linked list of <i>struct AttributeCacheEntry</i> elements is maintained to cache all the Attribute Catalog entries together.</p>
			    <div class="code"><pre><code>
typedef struct AttributeCacheEntry {

	AttrCatEntry attrCatEntry;
	bool dirty;
	RecId recid;
	IndexId searchIndex;
	struct AttributeCacheEntry *next;

} AttributeCacheEntry;
			</code></pre></div>
				<p> The AttrCacheEntry data field details are as follows:
					<ul>

						<li><i>attrCatEntry</i>: Stores the cached <a href="#attr_cat_entry">Attribute Catalog entry</a> corresponding to an attribute of the relation.</li>
						<li><i>dirty</i>: Indicates whether the Attribute Catalog entry has been modified. The Attribute Catalog entries with the set dirty bit are written back to disk when an open relation is closed in the cache memory.</li>
						<li><i>recId</i>: Stores the <a href="buffer.html#recid" target="_blank"> record id</a> {blockNum, slotNum} of the record entry corresponding to the relation's attribute in the 
							Attribute Catalog block on the disk. This is useful during the write back of the catalog entry to disk if it had been modified.</li>
						<li><i>searchIndex</i>: Stores the <a href="buffer.html#indexid" target="_blank"> index id</a> {blockNum, indexNum} of the <a href="../storage-model.html#leafind_blk" target="_blank">leaf index block</a> corresponding to the <b>last (previous) search hit</b> for the attribute. This entry is used only if there is a <a href="b+tree.html" target="_blank">B+ Tree</a> created on the attribute. <a href="b+tree.html#search" target="_blank">B+ Tree search algorithm</a> of the <a href="b+tree.html" target="_blank">B+ Tree Layer</a> starts searching from the previous hit location for the next hit. The entries are initialized to {-1, -1} each time the relation is opened in the cache memory. When every Index Leaf Block entry of the B+ Tree has been searched,  B+ Tree search resets the searchIndex value to {-1, -1}. </li>
						<li><i>next</i>: Gives the pointer to the next <i>AttrCacheEntry</i> element in the linked list.</li>  
					</ul> 
				</p>
				</div>
				</div>
				
  <!--------------------Open Relation Table Structure------------------------------------------------------------------------------------------------------>                      
                        <div id="openrel_table_struct" class="detail">
                            <h2>Open Relation Table Structure</h2>
                            <p>A relation must have an entry in the Open Relation Table for its Relation Catalog and Attribute Catalog entries to be cached in the  Relation Cache Table and Attribute Cache Table, respectively. </p>
                            <div id = "open_rel_table_metainfo" class= "subec">
				    <h4>OpenRelTableMetaInfo</h4>
				    <p>The struct <i>OpenRelTableMetaInfo</i> stores whether the given entry in the OpenRelTable, the Relation Cache Table, and Attribute Cache Table is occupied and also stores the name of the relation if occupied.</p>
				    <div class="code"><pre><code>typedef struct OpenRelTableMetaInfo{
				    
	bool free;
	char rel_name[ATTR_SIZE];
	
} OpenRelTableMetaInfo;</code></pre></div>
			    </div>
			</div>
<!-----------------------------------------Layer Diagram-------------------------------------->	
	<div id="layer_diagram" class="detail">
	<p>The following diagram summarizes the design of this module.</p>
	<center><img class="img-fluid" src="/img/cacheLayerTables.png"></center>
	</div>
<!-----------------------------------class RelCacheTable----------------------------------------------------------------------------------->
			<div id="rel_cache_table_class" class="details">
				<h2>class RelCacheTable</h2>
				<p>The <i>class RelCacheTable</i> is used to cache Relation Catalog entries of all the open relations in NITCbase. 
					The first two entries of the <i>Relation Cache Table</i> corresponding to <a href="/constants.html#constants" target="_blank">RELCAT_RELID</a> and <a href="/constants.html#constants" target="_blank">ATTRCAT_RELID</a> are reserved for storing the entries of Relation Catalog relation and Attribute Catalog relation, respectively. These are loaded into the cache by the <a href="#open_rel_table_constructor">OpenRelTable constructor</a> at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the <a href="#open_rel_table_destructor">OpenRelTable destructor</a> at shutdown.
					The class contains a private member field, <i>relCache</i>, 
					which is an array of pointers to <a href="#rel_cache_entry">struct RelCacheEntry</a> 
					with size <a href="/constants.html#constants" target="_blank">MAX_OPEN</a>.
				For each relation opened, an entry is made in the array <i>relCache</i>,
					at the index corresponding to the <a href="#relid">relation id</a> of the relation.
				This entry points to the <i>struct RelCacheEntry</i> that stores all the attribute values of the relation's entry from the Relation Catalog block
					 along with other meta-data of the relation. 
					
			</p>
				
				<p>The class provides public methods <i>getRelCatEntry()</i> and <i>setRelCatEntry()</i> to retrieve and update the <a href="rel_cat_entry">Relation Catalog Entry</a> of a relation in the Relation Cache Table. The class also provides public methods <i>getSearchIndex()</i> and <i>setSearchIndex()</i> for retrieving and updating the <i>searchIndex</i> field of <a href="#rel_cache_entry">Relation Cache Entry</a>.
				    The private method <i>recordToRelCacheEntry()</i> is used to convert a record (implemented as an array of <a href="buffer.html#block_structures_attribute" target="_blank">union Attribute</a>) to <i>RelCacheEntry</i> structure. This function is called by the friend class, <a href="#open_rel_table_class">OpenRelTable</a>, while opening a relation.
				    Similarly, the private method <i>relCacheEntryToRecord()</i> is used to convert <i>RelCacheEntry</i> structure in to a record. This function is also called from the friend class, <i>OpenRelTable</i>, while closing a relation.
			    	</p>
				
				<p>RelCacheTable is a <b>static class</b>, i.e., all member fields and methods are declared static. Memory is allocated <a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">statically</a> for all member fields of the class. This class uses <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank">static methods</a> to access the static member fields.
				   C++ allows static methods to be accessed using the semantics class_name::function_name(). The class definition of RelCacheTable is as given below:
				</p>
				<p><b>Note:</b> The class <i>OpenRelTable</i> is a friend class to <i>RelCacheTable</i> class. This allows all methods in <i>OpenRelTable</i> to access the private fields and methods of the <i>RelCacheTable</i> class.</p>

				<div class="code">
					<pre><code>class RelCacheTable{
					
friend class OpenRelTable;
	
public:
	//methods
	static int getRelCatEntry(int relId, RelCatEntry *relCatBuf);
	static int setRelCatEntry(int relId, RelCatEntry *relCatBuf);
	static int getSearchIndex(int relId, RecId *searchIndex);
	static int setSearchIndex(int relId, RecId *searchIndex);

private:
	//field
	static RelCacheEntry* relCache[MAX_OPEN];

	//methods
	static void RecordToRelCacheEntry(union Attribute record[RELCAT_SIZE], RelCacheEntry* relCacheEntry);
	static void RelCacheEntryToRecord(union Attribute record[RELCAT_SIZE], RelCacheEntry* relCacheEntry);
	
};</code></pre>
				</div>
<p>The following are the specifications for the methods in <i>class RelCacheTable</i>.</p>
				
				<ul class="methods">
	     
	<!--------getRelCatEntry--------------------------------------------------------------->
					<li>
						<div id="getrelcatentry" class="detail">
                            <h2><i>public:</i> getRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td> The relation id of the relation in the Relation Cache Table.</td>
                                    </tr>
                                    <tr>
                                        <td>relCatBuf</td>
					<td><a href="#rel_cat_entry">RelCatEntry</a>*</td>
                                    	<td>Pointer to struct RelCatEntry to which the Relation Catalog entry corresponding to input relId is to be copied.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully copied the Relation Catalog entry.</td>
                                    </tr>
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
                                        <td>Input relId is outside the valid set of possible relation ids.</td>
                                    </tr>
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
                                        <td>Entry corresponding to input relId is free in the Relation Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>Gives the Relation Catalog Entry corresponding to the specified relation from Relation Cache Table.</p>
<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RelCatEntry</i> before calling the function.</p>
                            <h5><a data-toggle="collapse" href="#algo-getrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getrelcatentry" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::getRelCatEntry(int relId, RelCatEntry *relCatBuf){

	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Relation Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	//copy the corresponding Relation Catalog entry in the Relation Cache Table to relCatBuf.
	
	return SUCCESS;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
				
                        </div>
					</li>
	<!--------setRelCatEntry--------------------------------------------------------------->
					<li>
						<div id="setrelcatentry" class="detail">
                            <h2><i>public:</i> setRelCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Relation Cache Table.</td>
                                    </tr>
                                    <tr>
                                        <td>relCatBuf</td>
                                        <td><a href="#rel_cat_entry">RelCatEntry</a>*</td>
                                        <td>Pointer to struct RelCatEntry using which the Relation Catalog entry corresponding to input relId is to be updated.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class=retval>
                                <h5>Return value:</h5>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <tr>
                                            <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                            <td>Successfully updated the Relation Catalog entry.</td>
                                        </tr>
                                        <tr>
                                            <td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
                                            <td>Input relId is outside the valid set of possible relation ids.</td>
                                        </tr>
                                        <tr>
                                            <td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
                                            <td>Entry corresponding to input relId is free in the Relation Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
                                        </tr>

                                    </table>
                                </div>
                            </div>

                            <h5>Description:</h5>
                            <p>Sets the Relation Catalog entry corresponding to the specified relation in the Relation Cache Table.</p>
<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RelCatEntry</i> before calling the function.</p>
                            <h5><a data-toggle="collapse" href="#algo-setrelcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setrelcatentry" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::setRelCatEntry(int relId, RelCatEntry *relCatBuf){
				
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Relation Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	//copy the relCatBuf to the corresponding Relation Catalog entry in the Relation Cache Table.
	
	//set the dirty flag of the corresponding Relation Cache entry in the Relation Cache Table.
	
	return SUCCESS;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
			
                        </div>
					</li>
	<!--------getSearchIndex--------------------------------------------------------------->
					<li>
						<div id="getsearchindex0" class="detail">
                            <h2><i>public:</i> getSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Relation Cache Table.</td>
                                    </tr>
                                    <tr>
                                        <td>searchIndex</td>
					    <td><a href="#recid" target="_blank">RecId</a>*</td>
                                        <td>Pointer to struct RecId to which the searchIndex field of the Relation Cache entry corresponding to input relId is to be copied.</td>
                                    </tr>
                                </table>
                            </div>

                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully copied the searchIndex field.</td>
                                    </tr>
                                    <tr>
					    <td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
					    <td>Input relId is outside the valid set of possible relation ids.</td>
					</tr>
					<tr>
					    <td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
					    <td>Entry corresponding to input relId is free in the Relation Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
			<p>Gives the value of <a href="#rel_cache_entry"><i>searchIndex</i></a> field of the given relation from Relation Cache Table. This is used by the <a href="blockaccess.html#linear_search" target="_blank">linear search algorithm</a> to find the location of the previous hit so that the search can be resumed from the next record.</p>
<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RecId</i> before calling the function.</p>
                            <h5><a data-toggle="collapse" href="#algo-getprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getprevrecid" class="collapse">
                                <div class="code"><pre><code>int relCacheTable::getSearchIndex(relId relid, recId *recidbuff_ptr){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Relation Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// copy the searchIndex field of the Relation Cache entry corresponding to input relId to searchIndex variable.
	
	return SUCCESS;
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
			
                        </div>
					</li>
	<!--------setsearchIndex--------------------------------------------------------------->
					<li>
						<div id="setsearchindex0" class="detail">
                            <h2><i>public:</i> setSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Relation Cache Table.</td>
                                    </tr>
                                    <tr>
                                        <td>searchIndex</td>
                                        <td><a href="#recid" target="_blank">RecId</a>*</td>
					    <td>Pointer to struct RecId using which the searchIndex field of the Relation Cache entry corresponding to input relId is to be updated.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully updated the searchIndex field.</td>
                                    </tr>
                                    <tr>
					<td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
                                        <td>Input relId is outside the valid set of possible relation ids.</td>
                                    </tr>
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
                                        <td>Entry corresponding to input relId is free in the Relation Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
                                    </tr>

                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>Sets the value of <a href="#rel_cache_entry"><i>searchIndex</i></a> field of the given relation in Relation Cache Table. This is used by the <a href="blockaccess.html#linear_search" target="_blank">linear search algorithm</a> to set the location of the previous hit so that the search can be resumed from the next record.</p>
<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RecId</i> before calling the function.</p>
                            <h5><a data-toggle="collapse" href="#algo-setprevrecid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setprevrecid" class="collapse">
                                <div class="code"><pre><code>int RelCacheTable::setSearchIndex(int relId, recId *searchIndex){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Relation Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// copy the searchIndex variable to the searchIndex field of the Relation Cache entry corresponding to input relId.
	
	return SUCCESS;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
			
                        </div>
					</li>
	<!----------------------recordToRelCacheEntry--------------------------->
					<li>
						<div class="detail" id="rectorelcache">
					    	<h2><i>private:</i> recordToRelCacheEntry</h2>
					    	<h5>Arguments:</h5>
					    	<div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							<td>record</td>
							<td><a href="buffer.html#block_structures target="_blank"" target="_blank">union Attribute</a>[<a href="/constants.html#constants" target="_blank">RELCAT_SIZE</a>]</td>
							<td>Record which is to be converted to a Relation Cache Entry.</td>
						    </tr>
							<tr>
									<td>RelCacheEntry</td>
									<td><a href="#rel_cache_entry">RelCacheEntry</a>*</td>
									<td>Pointer to struct RelCacheEntry to which the contents of the input record is to be copied.</td>
								</tr>
							</table>
						    </div>

					    <h5>Return value:</h5>
					    void
					    <h5>Description:</h5>
					<p>A utility function that converts a record, implemented as an array of <a href="buffer.html#block_structures"  target="_blank">union Attribute</a>, to <a href="#rel_cache_entry">RelCacheEntry</a> structure. The record content is used to populate the relCatEntry field. The dirty, recId, and searchIndex fields are initialised with default values of false, {-1, -1}, and {-1, -1}, respectively. This function can be used to convert a record in a Relation Catalog block to the corresponding Relation Cache entry when caching a relation in Relation Cache Table. The details of the implementation are left to you.</p>
					<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RelCacheEntry</i> and array of <i>union Attribute</i> before calling the function.</p>
					</div>	
					</li>
	<!--------RelCacheEntryToRecord--------------------------------------------------------------->
					<li>
						<div class="detail" id="relcachetorec">
                            			<h2><i>private:</i> relCacheEntryToRecord</h2>
                            			<h5>Arguments:</h5>
                            			<div class="table-responsive">
		                        	<table class="table table-bordered table-hover">
							<tr>
								<td>record</td>
						                <td><a href="buffer.html#block_structures target="_blank"" target="_blank">union Attribute</a>[<a href="/constants.html#constants" target="_blank">RELCAT_SIZE</a>]</td>
						                <td>The record to which the contents of the input Relation Cache Entry is to be copied.</td>
						        </tr>
		                            		<tr>
								<td>relCacheEntry</td>
							        <td><a href="#rel_cache_entry">RelCacheEntry</a>*</td>
							        <td>Pointer to struct RelCacheEntry which is to be converted to a record.</td>
						    	</tr>
		                        	</table>
		                   		 </div>
                            
                            		<h5>Return value:</h5>
                            		void

                            	<h5>Description:</h5>
				<p>A utility function that converts <a href="#relation_cache">RelCacheEntry</a> structure to a record, implemented as an array of <a href="buffer.html#block_structures"  target="_blank">union Attribute</a>. The record is populated with the contents of the relCatEntry field. The dirty, recId, and searchIndex fields are used only during runtime and are not written to the disk. This function can be used to convert the Relation Cache entry to the corresponding record that can be written back to Relation Catalog block when closing a relation in the cache memory. The details of the implementation are left to you.</p>
				<p><b>NOTE:</b> The caller should allocate memory for the <i>struct RelCacheEntry</i> and array of <i>union Attribute</i> before calling the function.</p>
                        	</div>
					</li>
	<!----------------------------------------------------------------------->
					
				</ul>
			</div>
<!-----------------------------------class AttrCacheTable----------------------------------------------------------------------------------->

			<div id="attr_cache_table_class" class="details">
				<h2>class AttrCacheTable</h2>
				<p>The <i>class AttrCacheTable</i> is used to cache Attribute Catalog entries of the attributes of open relations in NITCbase. 
					The first two entries of the <i>Attribute Cache Table</i> corresponding to <a href="/constants.html#constants" target="_blank">RELCAT_RELID</a> and <a href="/constants.html#constants" target="_blank">ATTRCAT_RELID</a> are reserved for storing the entries of Relation Catalog relation and Attribute Catalog relation, respectively. These are loaded into the cache by the <a href="#open_rel_table_constructor">OpenRelTable constructor</a> at the start of the session. These relations remain in the cache memory throughout the session and can only be closed by the <a href="#open_rel_table_destructor">OpenRelTable destructor</a> at shutdown.
					The class contains a private member field, <i>attrCache</i>, 
					which is an array of pointers to <a href="#attr_cache_entry">struct AttrCacheEntry</a> 
					with size <a href="/constants.html#constants" target="_blank">MAX_OPEN</a>.
				For each relation opened, an entry is made in the array <i>attrCache</i>,
					at the index given by relation id of the relation.
				This entry is the head of the linked list of <i>struct AttrCacheEntry</i> elements.
					A linked list is used because a relation can have variable number of attributes 
					(though the maximum number of attributes for a relation is bounded in Nitcbase by 125 - <b>why?</b>). 
					Each element in the linked list corresponds to an attribute of the relation.
				
			</p>	
			<p>The class provides public overloaded methods <i>getAttrCatEntry()</i> and <i>setAttrCatEntry()</i> to retrieve and update the <a href="#attr_cat_entry">Attribute Catalog Entry</a> of a relation's attribute in the Attribute Cache Table. The class also provides overloaded public methods <i>getSearchIndex()</i> and <i>setSearchIndex()</i> for retrieving and updating the <i>searchIndex</i> field of <a href="#attr_cache_entry">Attribute Cache Entry</a>.</i> 
			    The private method <i>recordToAttrCacheEntry()</i> is used to convert a record (implemented as an array of <a href="buffer.html#block_structures" target="_blank">union Attribute</a>) to AttrCacheEntry structure. This function is called by the friend class, <a href="#open_rel_table_class">OpenRelTable</a>, while opening a relation.
			    Similarly, the private method <i>attrCacheEntryToRecord()</i> is used to convert <i>AttrCacheEntry</i> structure in to a record. This function is also called from the friend class, <i>OpenRelTable</i>, while closing a relation.
			</p>
			<p>AttrCacheTable is a <b>static class</b>, i.e., all member fields and methods are declared static. Memory is allocated <a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">statically</a> for all member fields of the class. This class uses <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank">static methods</a> to access the static member fields.
			   C++ allows static methods to be accessed using the semantics class_name::function_name(). The class definition of AttrCacheTable is as given below:
			</p>
		<p><b>Note:</b> The class <i>OpenRelTable</i> is a friend class to <i>AttrCacheTable</i> class. This allows all methods in <i>OpenRelTable</i> to access the private fields and methods of the <i>AttrCacheTable</i> class.</p>
				<div class="code">
<pre><code>class AttrCacheTable{

friend class OpenRelTable;
	
public:
	//methods
	static int getAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf);
	static int getAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf);
	static int setAttrCatEntry(int relId, char attrName[ATTR_SIZE], AttrCatEntry *attrCatBuf);
	static int setAttrCatEntry(int relId, int attrOffset, AttrCatEntry *attrCatBuf);
	static int getSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex);
	static int getSearchIndex(int relId, int attrOffset, IndexId *searchIndex);
	static int setSearchIndex(int relId, char attrName[ATTR_SIZE], IndexId *searchIndex);
	static int setSearchIndex(int relId, int attrOffset, IndexId *searchIndex);

private:
	//field
	static AttrCacheEntry* attrCache[MAX_OPEN];
	
	//methods
	static void recordToAttrCacheEntry(union Attribute record[ATTRCAT_SIZE], AttrCatEntry *attrCatEntry);
	static void attrCacheEntryToRecord(union Attribute record[ATTRCAT_SIZE], AttrCatEntry *attrCatEntry);
	
};</code></pre>
				</div>	
	
<p>The following are the specifications for the methods in <i>class AttrCacheTable</i>.</p>
				<ul class="methods">
	     <!-------------------------------getAttrCatEntry------------------------------------------------------------>
					<li>
					    <div id="getattrcatentry" class="detail">
					    <h2><i>public:</i> getAttrCatEntry</h2>
					    <h5>Arguments:</h5>
					    <div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							<td>relId</td>
							<td>int</td>
							<td>The relation id of the relation in the Attribute Cache Table.</td>
						    </tr>
						    <tr>
							<td>attrName / attrOffset</td>
							<td>char[<a href="/constants.html#constants" target="_blank">ATTR_SIZE<a>] / int</td>
							<td>The name/offset of the target attribute.</td>
						    </tr>
						    <tr>
							<td>attrCatBuf</td>
							<td><a href="#attr_cat_entry">AttrCatEntry</a>*</td>
							<td>Pointer to <i>struct AttrCatEntry</i> to which the Attribute Catalog entry corresponding to the input relid and attribute is to be copied.</td>
						    </tr>
						</table>
					    </div>
					    <h5>Return value:</h5>
					    <div class="table-responsive">
						<table class="table table-bordered table-hover">
						    <tr>
							    <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
							<td>Successfully copied the Attribute Catalog entry.</td>
						    </tr>
						     <tr>
							<td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
							<td>Input relId is outside the valid set of possible relation ids.</td>
						    </tr>
						    <tr>
							<td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
							<td>Entry corresponding to input relId is free in the Attribute Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
						    </tr>
						    <tr>
							    <td><a href="/constants.html#errors" target="_blank">E_ATTRNOTEXIST</a></td>
							<td>No attribute with the input attribute name or offset exists.</td>
						    </tr>

						</table>
					    </div>
					    <h5>Description:</h5>
					    <p>Gives the Attribute Catalog entry corresponding to the given attribute of the specified relation in the Attribute Cache Table.</p>
					<p><b>NOTE: </b>
				    <ul><li>This method is overloaded in type of the second argument.
				        <li>The caller should allocate memory for the <i>struct AttrCatEntry</i> before calling the function.
				</ul></p>
				    <h5><a data-toggle="collapse" href="#algo-getattrcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
				    <div id="algo-getattrcatentry" class="collapse">
					<div class="code"><pre><code>int AttrCacheTable::getAttrCatEntry(int relId, char attrName[ATTR_SIZE]/int attrOffset, AttrCatEntry *attrCatBuf){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Attribute Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// iterate over all the attributes in the Attribute Cache Table corresponding to the relation with relId.
	{
		// if the attrName/offset field of the Attribute Catalog entry is equal to the input attrName/attrOffset:
		{
			// copy that Attribute Catalog entry in the Attribute Cache Table to attrCatBuf.
			
			return SUCCESS;
		}
	}
	
	return E_ATTRNOTEXIST;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
</div>
					</li>
         <!-------------------------------setAttrCatEntry------------------------------------------------------------>
					<li>
						<div id="setattrcatentry" class="detail">
                            <h2><i>public:</i> setAttrCatEntry</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Attribute Cache Table.</td>
                                    </tr>
                                    <tr>
					<td>attrName / attrOffset</td>
					<td>char[<a href="/constants.html#constants" target="_blank">ATTR_SIZE<a>] / int</td>
					<td>The name/offset of the target attribute.</td>
				    </tr>
                                    <tr>
                                        <td>attrCatBuf</td>
				        <td><a href="#attr_cat_entry">AttrCatEntry</a>*</td>
                                        <td>Pointer to <i>struct AttrCatEntry</i> using which the Attribute Catalog entry corresponding to input relId and attribute is to be updated.</td>
                                    </tr>
                                </table>
                            </div>
                            
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover ">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully updated the Attribute Catalog entry.</td>
                                    </tr>
                                   <tr>
					<td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
					<td>Input relId is outside the valid set of possible relation ids.</td>
				    </tr>
				    <tr>
					<td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
					<td>Entry corresponding to input relId is free in the Attribute Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
				    </tr>
				    <tr>
					    <td><a href="/constants.html#errors" target="_blank">E_ATTRNOTEXIST</a></td>
					<td>No attribute with the input attribute name or offset exists.</td>
				    </tr>

                                </table>
                            </div>
					
                            	<h5>Description:</h5>
                            	<p>Sets the Attribute Catalog entry corresponding to the given attribute of the specified relation in the Attribute Cache Table.</p>
				<p><b>NOTE: </b>
				    <ul><li>This method is overloaded in type of the second argument
				        <li>The caller should allocate memory to the pointer to <i>struct AttrCatEntry</i> before calling the function.
				</ul></p>
                            <h5><a data-toggle="collapse" href="#algo-setattrcatentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div class="collapse" id="algo-setattrcatentry">
                                <div class="code"><pre><code>int AttrCacheTable::setAttrCatEntry(relId relId, char attrName[ATTR_SIZE]/int attrOffset, AttrCatEntry *attrCatBuf){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Attribute Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// iterate over all the attributes in the Attribute Cache Table corresponding to the relation with relId.
	{
		// if the attrName/offset field of the Attribute Catalog entry is equal to the input attrName/attrOffset:
		{
			// copy the attrCatBuf to the corresponding Attribute Catalog entry in the Attribute Cache Table.
			
			// set the dirty flag of the corresponding Attribute Cache entry in the Attribute Cache Table.
			
			return SUCCESS;
		}
	}
	
	return E_ATTRNOTEXIST;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
</div>
					</li>
         <!-------------------------------getSearchIndex------------------------------------------------------------>
					<li>
						<div id="getsearchindex1" class="detail">
                            <h2><i>public:</i> getSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Attribute Cache Table.</td>
                                    </tr>
                                    <tr>
					<td>attrName / attrOffset</td>
					<td>char[<a href="/constants.html#constants" target="_blank">ATTR_SIZE<a>] / int</td>
					<td>The name/offset of the target attribute.</td>
				    </tr>
                                    <tr>
                                        <td>searchIndex</td>
                                        <td><a href="buffer.html#indexid" target="_blank">IndexId</a>*</td>
                                        <td>Pointer to <i>struct IndexId</i> to which the searchIndex field of the Attribute Cache entry corresponding to the input relid and attribute is to be copied. </td>
                                    </tr>
                                </table>
                             </div>
                                <h5>Return value:</h5>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover ">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully copied the searchIndex field.</td>
                                    </tr>
                                     <tr>
					<td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
					<td>Input relId is outside the valid set of possible relation ids.</td>
				    </tr>
				    <tr>
					<td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
					<td>Entry corresponding to input relId is free in the Attribute Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
				    </tr>
				    <tr>
					    <td><a href="/constants.html#errors" target="_blank">E_ATTRNOTEXIST</a></td>
					<td>No attribute with the input attribute name or offset exists.</td>
				    </tr>

                                </table>
                                </div>

                            	<h5>Description:</h5>
				<p>Gives the value of <a href="#rel_cache_entry"><i>searchIndex</i></a> field of the given attribute in the specified relation from Attribute Cache Table. This is used by the <a href="b+tree.html#search" target="_blank">B+ Tree search algorithm</a> to find the location of the previous hit so that the search can be resumed from the next leaf index entry.</p>
				
				<p><b>NOTE: </b>
				    <ul><li>This method is overloaded in type of the second argument
				        <li>The caller should allocate memory for the <i>struct IndexId</i> before calling the function.
				</ul></p>
                            <h5><a data-toggle="collapse" href="#algo-getsearchindexid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-getsearchindexid" class="collapse">
                                <div class="code"><pre><code>int AttrCacheTable::getSearchIndex(int relId, char attrName[ATTR_SIZE]/int attrOffset, IndexId *searchIndex){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Attribute Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// iterate over all the attributes in the Attribute Cache Table corresponding to the relation with relId.
	{
		// if the attrName/offset field of the Attribute Catalog entry is equal to the input attrName/attrOffset:
		{
		
			//copy the searchIndex field of the corresponding Attribute Cache entry in the Attribute Cache Table to input searchIndex variable.

			return SUCCESS;
		}
	}
	
	return E_ATTRNOTEXIST;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                             </div>
</div>
					</li>
         <!-------------------------------setSearchIndex------------------------------------------------------------>
					<li>
						<div id="setsearchindex1" class="detail">
                            <h2><i>public:</i> setSearchIndex</h2>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>relId</td>
                                        <td>int</td>
                                        <td>The relation id of the relation in the Attribute Cache Table.</td>
                                    </tr>
                                    <tr>
					<td>attrName / attrOffset</td>
					<td>char[<a href="/constants.html#constants" target="_blank">ATTR_SIZE<a>] / int</td>
					<td>The name/offset of the target attribute.</td>
				    </tr>
                                    <tr>
                                        <td>searchIndex</td>
                                        <td><a href="buffer.html#indexid" target="_blank">IndexId</a>*</td>
                                        <td>Pointer to <i>struct IndexId</i> using which the searchIndex field of the Attribute Cache entry corresponding to the input relid and attribute is to be updated.</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td><a href="/constants.html#errors" target="_blank">SUCCESS</a></td>
                                        <td>Successfully updated the searchIndex field.</td>
                                    </tr>
                                     <tr>
					<td><a href="/constants.html#errors" target="_blank">E_OUTOFBOUND</a></td>
					<td>Input relId is outside the valid set of possible relation ids.</td>
				    </tr>
				    <tr>
					<td><a href="/constants.html#errors" target="_blank">E_NOTOPEN</a></td>
					<td>Entry corresponding to input relId is free in the Attribute Cache Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
				    </tr>
				    <tr>
					    <td><a href="/constants.html#errors" target="_blank">E_ATTRNOTEXIST</a></td>
					<td>No attribute with the input attribute name or offset exists.</td>
				    </tr>


                                </table>
                            </div>
                            <h5>Description:</h5>
                            <p>Sets the value of <a href="#attr_cache_entry"><i>searchIndex</i></a> field of the given attribute in the specified relation from Attribute Cache Table. This is used by the <a href="b+tree.html#search" target="_blank">B+ Tree search algorithm</a> to set the location of the previous hit so that the search can be resumed from the next leaf index entry.</p>
				<p><b>NOTE: </b>
				    <ul><li>This method is overloaded in type of the second argument
				        <li>The caller should allocate memory for the <i>struct IndexId</i> before calling the function.
				</ul></p>
                            <h5><a data-toggle="collapse" href="#algo-setsearchindexid"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-setsearchindexid" class="collapse">
                                <div class="code"><pre><code>int AttrCacheTable::setSearchIndex(relId relId, char attrName[ATTR_SIZE]/int attrOffset, IndexId *searchIndex){
	
	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Attribute Cache Table is free:
	{
		return E_NOTOPEN;
	}
	
	// iterate over all the attributes in the Attribute Cache Table corresponding to the relation with relId.
	{
		// if the attrName/offset field of the Attribute Catalog entry is equal to the input attrName/attrOffset:
		{
			// copy the input searchIndex variable to the searchIndex field of the corresponding Attribute Cache entry in the Attribute Cache Table.
			
			return SUCCESS;
		}
	}
	
	return E_ATTRNOTEXIST;
	
}</code></pre>
                                </div> <!-- End of algo div -->
                                
                            </div>
</div>
					</li>
<!----------------------RecordToAttrCacheEntry--------------------------->
					<li>
					<div class="detail" id="rectoattrcache">
					    <h2><i>private:</i> recordToAttrCacheEntry</h2>
					    <h5>Arguments:</h5>
					    <div class="table-responsive">
							<table class="table table-bordered table-hover">
							    <tr>
								<td>record</td>
								    <td><a href="buffer.html#block_structures" target="_blank">union Attribute</a>[<a href="/constants.html#constants" target="_blank">ATTRCAT_SIZE<a>]</td>
								<td>Record which is to be converted to a Attribute Cache entry.</td>
							    </tr>
								<tr>
									<td> attrCacheEntry </td>
									<td><a href="#attr_cache_entry">AttrCacheEntry</a>*</td>
									<td>Pointer to <i>struct AttrCacheEntry</i> to which the contents of the input record is to be copied.</td>
								 </tr>
							</table>
					    </div>
					    <h5>Return value:</h5>
						<p>void</p>

					    <h5>Description:</h5>
					<p>A utility function that converts a record, implemented as an array of <a href="buffer.html#block_structures"  target="_blank">union Attribute</a>, to <a href="#attr_cache_entry">AttrCacheEntry</a> structure.  The record content is used to populate the attrCatEntry field. The dirty, recId, searchIndex, and next fields are initialized with default values of false, {-1, -1}, {-1, -1}, and NULL, respectively. This function can be used to convert the records in Attribute Catalog block/blocks to the corresponding Attribute Cache entries when caching a relation in Attribute Cache Table. The details of the implementation are left to you.</p>
					<p><b>NOTE:</b> The caller should allocate memory for the <i>struct AttrCacheEntry</i> and array of <i>union Attribute</i> before calling the function.</p>
					</div>
					</li>
         <!-------------------------------AttrCacheEntryToRecord------------------------------------------------------------>
					<li>
					    <div class="detail" id="attrcachetorec">
					    <h2><i>private:</i> attrCacheEntryToRecord</h2>
					    <h5>Arguments:</h5>
					    <div class="table-responsive">
							<table class="table table-bordered table-hover">
								<tr>
									<td>attrCacheEntry</td>
									<td><a href="#attr_cache_entry">AttrCacheEntry</a>*</td>
									<td>Pointer to  <i>struct AttrCacheEntry</i> which is to be converted to a record.</td>
								 </tr>
								<tr>
									<td>record</td>
									<td><a href="buffer.html#block_structures" target="_blank">union Attribute</a>[<a href="/constants.html#constants" target="_blank">ATTRCAT_SIZE<a>]</td>
									<td>The record to which the given Attribute Cache entry is to be copied.</td>
								 </tr>
							</table>
					   </div>

					    <h5>Return value:</h5>
						    <p>void</p>

					    	<h5>Description:</h5>
						<p>A utility function that converts <a href="#attr_cache_entry">AttrCacheEntry</a> structure to a record, implemented as an array of <a href="buffer.html#block_structures" target="_blank">union Attribute</a>. The record is populated with the contents of the attrCatEntry field. The dirty, recId, searchIndex, and next fields are used only during runtime and are not written to the disk. This function can be used to convert the Attribute Cache entries to corresponding records that can be written back to Attribute Catalog block/blocks when closing a relation in the cache memory. The details of the implementation are left to you.</p>
						<p><b>NOTE:</b> The caller should allocate memory for the <i>struct AttrCacheEntry</i> and array of <i>union Attribute</i> before calling the function.</p>
					</div>
					
					</li>
         						
	<!----------------------------------------------------------------------->
				</ul>
			</div>
<!---------------------------------------------------------------------------------------------------------->
            
<!-----------------------------------class OpenRelTable----------------------------------------------------------------------------------->

			<div id="open_rel_table_class" class="details">
				<h2>class OpenRelTable</h2>
				<p>NITCbase requires that a relation be cached for the duration it is accessed to improve the processing time. 
					The <i>Open Relation Table</i> is a data structure used as an interface for operations that accesses both <a href="#rel_cache_table_class">Relation Cache</a> and <a href="#attr_cache_table_class">Attribute Cache</a> together. 
					The <i>OpenRelTable class</i> is used for this purpose. 
					As per the NITCbase design, the i<sup>th</sup> entry of the <i>OpenRelTable</i> corresponds to the i<sup>th</sup> entry of the <a href="#rel_cache_table_class">RelCacheTable</a> and <a href="#attr_cache_table_class">AttrCacheTable</a> and is used to store the data of a single relation whose relation id is i. 
					The public <i>getRelId()</i> method of the OpenRelTable returns the relation id of the input relation name.</p>
				<p>The <i>class OpenRelTable</i> contains as its private member field, <i>tableMetaInfo</i>, an array of <a href="#openrel_table_struct">struct OpenRelTableMetaInfo</a> that stores the meta information of the entries of the table. The OpenRelTable allows <a href="../constants.html#constant" target="_blank">MAX_OPEN</a> number of entries in the cache at any given time. 
					The first two entries of the <i>Open Relation Table</i> corresponding to <a href="/constants.html#constants" target="_blank">RELCAT_RELID</a> and <a href="/constants.html#constants" target="_blank">ATTRCAT_RELID</a> are reserved for storing the entries of <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> relation and <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog</a> relation, respectively. 
					These relations remain in cache memory throughout the session and can be closed only at shutdown. 
					The <i>OpenRelTable</i> constructor initializes the <i>tableMetaInfo</i> field and populates the Relation Cache Table and Attribute Cache Table with entries of both Relation Catalog relation and Attribute Catalog relation. 
					The <i>OpenRelTable</i> destructor closes any open relation remaining, including the Relation Catalog and Attribute Catalog relations, when the system is shut down.
					The public functions <i>openRel()</i>, <i>closeRel()</i>, and <i>deleteRel()</i> are used to open an entry in the <i>Open Relation Table</i>, close its entry in the <i>Open Relation Table</i>, and to delete the relation from the database. <i>OpenRelTable class</i> is a friend class to both <i>RelCacheTable class</i>, and <i>AtrrCacheTable class</i>. This allows it to access the private fields and methods of the two classes.</p>
				<p>OpenRelTable is a <b>static class</b>, i.e., all member fields and methods are declared static. Memory is allocated <a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">statically</a> for all member fields of the class. This class uses <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank">static methods</a> to access the static member fields. Static methods are accessed using the semantics class_name::function_name(). Only a single static object of the class needs to be created when NITCbase is running, whose sole purpose is to run the constructor and the destructor. The class definition of OpenRelTable is as given below:</p>
				<div class="code">
                                <pre><code>class OpenRelTable{

public:

	//methods
	OpenRelTable();
	~OpenRelTable();
	static int getRelId(unsigned char relName[ATTR_SIZE]);
	static int openRel(unsigned char relName[ATTR_SIZE]);
	static int closeRel(int relId);
	static int deleteRel(int relId);
	
private:
	//field
	static OpenRelTableMetaInfo tableMetaInfo[MAX_OPEN];
	
	//method
	static int getFreeOpenRelTableEntry();
	
};</code></pre>
					
				</div>
				<p>The following are the specifications for the methods in <i>class OpenRelTable</i>.
	     <!----------------------Constructor--------------------------->
					<li>
						<div id="open_rel_table_constructor" class="detail">
                            				<h2><i>public:</i> OpenRelTable (Constructor)</h2>
                            				<h5>Arguments:</h5>
							<p>Nil</p>
							<h5>Return type:</h5>
							<p>Nil</p>
							<h5>Description:</h5>
							<p>Initializes the meta information of each entry of the Open Relation Table to initial empty conditions. 
							It also loads the entries of the <a href="../storage-model.html#relcat" target="_blank">Relation Catalog</a> relation and <a href="../storage-model.html#attrcat" target="_blank">Attribute Catalog<a/> relation to the <a href="#rel_cache_table_class">Relation Cache Table</a> and <a href="#attr_cache_table_class">Attribute Cache Table</a>. 
							This function should be called at the beginning of the session.</p>
							<p><b>NOTE:</b> 
								<ul>
									<li>The object of the OpenRelTable class must be declared after the objects of the <a href="../storage-model.html" target="_blank">Physical Layer</a> and the <a href="buffer.html" target="_blank">Buffer Layer</a> to ensure that the main memory is properly set up before the constructor initializes cache memory.</li>
									<li>The first two entries corresponding to <a href="/constants.html#constants" target="_blank">RELCAT_RELID</a> and <a href="/constants.html#constants" target="_blank">ATTRCAT_RELID</a> in the all the three tables are reserved for Relation Catalog relation and Attribute Catalog relation, respectively.</li>
								</ul>
							</p>
							<h5><a data-toggle="collapse" href="#algo_open_rel_table_constructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_open_rel_table_constructor" class="collapse">
							    <div class="code">
								<pre><code>OpenRelTable::OpenRelTable(){

	// initialize tableMetaInfo of all the entries of the Open Relation Table with free as true and relName as an empty string.
	
	/************ Setting up Relation Catalog relation in the cache ************/
	
	/**** setting up Relation Catalog relation in the Relation Cache Table ****/
	
	/* read the record entry at index 0 from block 4, the block corresponding to Relation Catalog in the disk, and create a Relation Cache entry on it 
	   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and <a href="#rectorelcache">RelCacheTable::recordToRelCacheEntry()</a>.
	   update the recId field of this Relation Cache entry to {4,0}.
	   use it to set the 0<sup>th</sup> index entry of the RelCacheTable.*/
	
	/**** setting up Relation Catalog relation in the Attribute Cache Table ****/
	
	// let listHead be used to hold the head of the linked list of Attribute Cache entries.
	AttrCacheEntry listHead;
	
	for i from 0 to 5:
	{
	
         	/* read the i<sup>th</sup> record entry from bock 5, the block corresponding to Attribute Catalog in the disk, and create an Attribute Cache entry on it
		   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and <a href="#rectoattrcache">AttrCacheTable::recordToAttrCacheEntry()</a>.
		   update the recId field of this Attribute Cache entry to {5,i}.
		   add the Attribute Cache entry to the linked list of listHead .*/
	}
	
	// set the 0<sup>th</sup> entry of the AttrCacheTable to listHead.
	
	/**** setting up Relation Catalog relation in the Open Relation Table ****/
	
	//update the 0<sup>th</sup> entry of the tableMetaInfo with free as false and relName as the 'RelCatalog'.
	
	/************ Setting up Attribute Catalog relation in the cache ************/
	
	/**** setting up Attribute Catalog relation in the Relation Cache Table ****/
	
	/* read the record entry at index 1 from block 4, the block corresponding to Relation Catalog in the disk, and create a Relation Cache entry on it 
	   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and RelCacheTable::recordToRelCacheEntry().
	   update the recId field of this Relation Cache entry to {4,1}.
	   use it to set the 1<sup>st</sup> index entry of the RelCacheTable.*/
	
	/**** setting up Attribute Catalog relation in the Attribute Cache Table ****/
	
	// use listHead  to hold the head of the linked list of Attribute Cache entries.
	
	for i from 6 to 11:
	{
	
         	/* read the i<sup>th</sup> record entry from bock 5, the block corresponding to Attribute Catalog in the disk, and create an Attribute Cache entry on it
		   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and AttrCacheTable::recordToAttrCacheEntry().
		   update the recId field of this Attribute Cache entry to {5,i}.
		   add the Attribute Cache entry to the linked list of listHead .*/
	}
	
	// set the 1<sup>st</sup> entry of the AttrCacheTable to listHead.
	
	/**** setting up Attribute Catalog relation in the Open Relation Table ****/
	
	//update the 1<sup>st</sup> entry of the tableMetaInfo with free as false and relName as the 'AttrCatalog'.

}</code></pre>
							    </div>
							</div>
							
					    	</div>	
					</li>
         <!-------------------------------Destructor------------------------------------------------------------>
					<li>
						<div class="detail" id="open_rel_table_destructor">
							<h2><i>public:</i> ~OpenRelTable (Destructor)</h2>
							<h5>Arguments:</h5>
							<p>Nil</p>
							<h5>Return type:</h5>
							<p>Nil</p>
							<h5>Description:</h5>
							<p>Closes the still open relations in the Open Relation Table at the end of the current session. </p>
							<p><b>NOTE:</b> The object of the OpenRelTable class must be declared after the objects of the <a href="../storage-model.html" target="_blank">Physical Layer</a> and the <a href="buffer.html" target="_blank">Buffer Layer</a> to ensure that the destructor writes the cache contents to the main memory before the main memory is commited back to the disk.</p>
							<h5><a data-toggle="collapse" href="#algo_open_rel_table_destructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_open_rel_table_destructor" class="collapse">
							    <div class="code">
								<pre><code>OpenRelTable::~OpenRelTable(){

	for i from 2 to MAX_OPEN-1:
	{
		if i<sup>th</sup> relation is still open:
		{
	
			// close the relation using <a href="#closerel">openRelTable::closeRel()</a>.
		
		}
	}
	
	/************ Closing Attribute Catalog relation in the cache ************/
	
	/****** releasing the entry corresponding to Attribute Catalog relation from Relation Cache Table ******/
	
	// if the Relation Catalog entry of the <a href="/constants.html#constants" target="_blank">ATTRCAT_RELID</a><sup>th</sup> Relation Cache entry has been modified: 
	{
		/* write back the entry to the Relation Catalog block using 
		   <a href="#relcachetorec">RelCacheTable::relCacheEntryToRecord()</a>, recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
	}
	
	/****** releasing the entry corresponding to Attribute Catalog relation from Attribute Cache Table ******/
	
	// iterate over all the entries in the linked list of the ATTRCAT_RELID<sup>th</sup> Attribute Cache entry.
	{
		if the entry has been modified:
		{
			/* write back the entry to the Attribute Catalog block using
			   <a href="#attrcachetorec">AttrCacheTable::attrCacheEntryToRecord()</a>, recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
			
		}
		
		// free the memory dynamically alloted to this entry in Attribute Cache linked list.
	}
	
	/****** updating metadata corresponding to Attribute Catalog relation in the Open Relation Table ******/
	
	//free the ATTRCAT_RELID<sup>th</sup> entry of the tableMetaInfo.

	/************ Closing Relation Catalog relation in the cache ************/

	/****** releasing the entry corresponding to Relation Catalog relation from Relation Cache Table ******/
	
	// if the Relation Catalog entry of the <a href="/constants.html#constants" target="_blank">RELCAT_RELID</a><sup>th</sup> Relation Cache entry has been modified: 
	{
		/* write back the entry to the Relation Catalog block using 
		   <a href="#relcachetorec">RelCacheTable::relCacheEntryToRecord()</a>, recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
	}
	
	/****** releasing the entry corresponding to Relation Catalog relation from Attribute Cache Table ******/
	
	// iterate over all the entries in the linked list of the RELCAT_RELID<sup>th</sup> Attribute Cache entry.
	{
		if the entry has been modified:
		{
			/* write back the entry to the Attribute Catalog block using
			   <a href="#attrcachetorec">AttrCacheTable::attrCacheEntryToRecord()</a>, recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
			
		}
		
		// free the memory dynamically alloted to this entry in Attribute Cache linked list.
	}
	
	/****** updating metadata corresponding to Relation Catalog relation in the Open Relation Table ******/
	
	//free the RELCAT_RELID<sup>th</sup> entry of the tableMetaInfo.

}</code></pre>
							    </div>
							</div>
					    	</div>	
					</li>
         <!-------------------------------getRelId------------------------------------------------------------>
					<li>
					<div class="detail" id="getrelid">
							<h2><i>public:</i> getRelId</h2>
							<h5>Arguments:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relName</td>
								    <td>unsigned char[<a href="../constants.html#constant" target="_blank">ATTR_SIZE</a>]</td>
								    <td>Name of the relation whose relation id in the Open Relation Table is required.</td>
								</tr>
							    </table>
							</div>
							<h5>Return type:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relId</td>
								    <td>int</td>
								    <td>The relation id of the relation in the Open Relation Table.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_NOTOPEN </a></td>
								    <td>int</td>
								    <td>The relation corresponding to relationName do not have an open entry in the Open Relation Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
								</tr>
							    </table>
							</div>
							<h5>Description:</h5>
							<p>Returns the relation id, i.e., the index, of the entry corresponding to the input relation in the Open Relation Table. </p>
							<h5><a data-toggle="collapse" href="#algo_getrelid"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_getrelid" class="collapse">
							    <div class="code">
								<pre><code>int OpenRelTable::getRelId(unsigned char relName[ATTR_SIZE]){

	/* traverse through the tableMetaInfo array,
		find the entry in the Open Relation Table corresponding to <i>relName</i>.*/
    
	// if found return the relation id, else indicate that the relation do not have an entry in the Open Relation Table.
	
}</code></pre>
							    </div>
							</div>
					    	</div>
					</li>
         <!-------------------------------openRel------------------------------------------------------------>
					<li>
					<div class="detail" id="openrel">
							<h2><i>public:</i> openRel</h2>
							<h5>Arguments:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relName</td>
								    <td>unsigned char[<a href="../constants.html#constant" target="_blank">ATTR_SIZE</a>]</td>
								    <td>Name of the relation whose entry is to be created in the Open Relation Table.</td>
								</tr>
							    </table>
							</div>
							<h5>Return type:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relId</td>
								    <td>int</td>
								    <td>Relation id of the relation in the Open Relation Table.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_RELNOTEXIST </a></td>
								    <td>int</td>
								    <td>No relation with name, relName, exists in the disk.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_CACHEFULL </a></td>
								    <td>int</td>
								    <td>No free entries left in the Open Relation Table.</td>
								</tr>
							    </table>
							</div>
							<h5>Description:</h5>
							<p>Creates an entry for the input relation in the Open Relation Table and returns the corresponding relation id. </p>
							<h5><a data-toggle="collapse" href="#algo_openrel"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_openrel" class="collapse">
							    <div class="code">
								<pre><code>int OpenRelTable::openRel(unsigned char relName[ATTR_SIZE]){
	
	if the relation, <i>relName</i>, already has an entry in the Open Relation Table:
	{ // checked using <a href="#getrelid">OpenRelTable::getRelId()</a>.
	
		// return that relation id;
	}
	
	// find a free slot in the Open Relation Table using <a href="#get_free_open_rel_table_entry">OpenRelTable::getFreeOpenRelTableEntry()</a>.
	if free slot not available:
	{
		return E_CACHEFULL;
	}
	
	// let relId be used to store the free slot.
	int relId;
	
	/****** Setting up Relation Cache entry for the relation ******/
	
	/* search for the entry with relation name, <i>relName</i>, in the Relation Catalog using <a href="blockaccess.html#linear_search" target="_blank">linear_search()</a> of the <a href="blockaccess.html" target="_blank">Block Access Layer</a>.
	   care should be taken to reset the searchIndex of the relation, RELCAT_RELID, corresponding to 
	   Relation Catalog before calling linear_search().*/
	   
	// let relcatRecId store the record id of the relation, <i>relName</i>, in the Relation Catalog.
	RecId relcatRecId;
	
	if relcatRecId == {-1, -1}:
	{ 
		// the relation is not found in the Relation Catalog.
		return E_RELNOTEXIST;
	}
	
	/* read the record entry corresponding to relcatRecId and create a Relation Cache entry on it 
	   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and <a href="#rectorelcache">RelCacheTable::recordToRelCacheEntry()</a>.
	   update the recId field of this Relation Cache entry to relcatRecId.
	   use the Relation Cache entry to set the relId<sup>th</sup> entry of the RelCacheTable.*/
	
	/****** Setting up Attribute Cache entry for the relation ******/
	
	// let listHead be used to hold the head of the linked list of Attribute Cache entries.
	AttrCacheEntry listHead;
	
	/* iterate over all the entries in the Attribute Catalog corresponding to each attribute of
	   the relation, <i>relName</i> by multiple calls of <a href="blockaccess.html#linear_search" target="_blank">linear_search()</a> of the <a href="blockaccess.html" target="_blank">Block Access Layer</a>.
	   care should be taken to reset the searchIndex of the relation, ATTRCAT_RELID, corresponding to 
	   Attribute Catalog before the first call to linear_search().*/
	{
            	/* let attrcatRecId store a valid record id an entry of the relation, <i>relName</i>, 
		   in the Attribute Catalog.*/
		RecId attrcatRecId;
	
         	/* read the record entry corresponding to attrcatRecId and create an Attribute Cache entry on it
		   using <a href="buffer.html#getrecord" target="_blank">RecBuffer::getRecord()</a> and <a href="#rectoattrcache">AttrCacheTable::recordToAttrCacheEntry()</a>.
		   update the recId field of this Attribute Cache entry to attrcatRecId.
		   add the Attribute Cache entry to the linked list of listHead .*/
	}
	
	// set the relId<sup>th</sup> entry of the AttrCacheTable to listHead.
	
	/****** Setting up metadata in the Open Relation Table for the relation******/
	
	//update the relId<sup>th</sup> entry of the tableMetaInfo with free as false and relName as the input.
	
	return relId;
	
}</code></pre>
							    </div>
							</div>
					    	</div>
					</li>
         <!-------------------------------closeRel------------------------------------------------------------>
					<li>
						<div class="detail" id="closerel">
							<h2><i>public:</i> closeRel</h2>
							<h5>Arguments:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relId</td>
								    <td>int</td>
								    <td>Relation id of a relation in the Open Relation Table.</td>
								</tr>
							    </table>
							</div>
							<h5>Return type:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td><a href="../constants.html" target="_blank"> SUCCESS </a></td>
								    <td>int</td>
								    <td>Successfully closed the entry of the relation in the Open Relation Table.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_OUTOFBOUND </a></td>
								    <td>int</td>
								    <td>Input relId is outside the valid set of possible relation ids.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_NOTOPEN </a></td>
								    <td>int</td>
								    <td>Entry corresponding to input relId is free in the Open Relation Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
								</tr>
							    </table>
							</div>
							<h5>Description:</h5>
							<p>Closes the entry of the input relation in the Open Relation Table.</p>
							<h5><a data-toggle="collapse" href="#algo_closerel"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_closerel" class="collapse">
								<div class="code">
									<pre><code>int OpenRelTable::closeRel(int relId){

	if relId is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Open Relation Table is free:
	{
		return E_NOTOPEN;
	}
	
	/****** Releasing the Relation Cache entry of the relation ******/
	
	// if the Relation Catalog entry of the relId<sup>th</sup> Relation Cache entry has been modified: 
	{
		/* write back the entry to the Relation Catalog block using 
		   RelCacheTable::relCacheEntryToRecord(), recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
	}
	
	/****** Releasing the Attribute Cache entry of the relation ******/
	
	// iterate over all the entries in the linked list of the relId<sup>th</sup> Attribute Cache entry.
	{
		if the entry has been modified:
		{
			/* write back the entry to the Attribute Catalog block using
			   AttrCacheTable::attrCacheEntryToRecord(), recId member field, and <a href="buffer.html#setrecord" target="_blank">RecBuffer::setRecord()</a>.*/
			
		}
		
		// free the memory dynamically alloted to this entry in Attribute Cache linked list.
	}
	
	/****** Updating metadata in the Open Relation Table of the relation  ******/
	
	//free the relId<sup>th</sup> entry of the tableMetaInfo.

	return SUCCESS;	
	
}</code></pre>
								</div>
							</div>
						</div>
					</li>
         <!-------------------------------deleteRel------------------------------------------------------------>
					<li>
						<div class="detail" id="deleterel">
							<h2><i>public:</i> deleteRel</h2>
							<p><b>Note to NITCbase designers: This function is not part of this class. The same funcionality has to be written in Schema Layer. Function included for refernce purpose only. Remove after use.</b></p>
							<h5>Arguments:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td>relId</td>
								    <td>int</td>
								    <td>Relation id of a relation in the Open Relation Table.</td>
								</tr>
							    </table>
							</div>
							<h5>Return type:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
								    <td><a href="../constants.html" target="_blank"> SUCCESS </a></td>
								    <td>int</td>
								    <td>Successfully deleted the relation from the database.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_OUTOFBOUND </a></td>
								    <td>int</td>
								    <td>Input relId is outside the valid set of possible relation ids.</td>
								</tr>
								<tr>
								    <td><a href="../constants.html" target="_blank"> E_NOTOPEN </a></td>
								    <td>int</td>
								    <td>Entry corresponding to input relId is free in the Open Relation Table. Use <a href="#openrel">OpenRelTable::openRel()</a> to load the relation to cache memory.</td>
								</tr>
							    </table>
							</div>
							<h5>Description:</h5>
							<p>Deletes the input relation from the database. This function releases the record and index blocks holding the relation's data in the disk, deletes the entry corresponding to the relation in the Relation Catalog and Attribute Catalog blocks in the disk and also removes the relation from the cache memory.</p>
							<h5><a data-toggle="collapse" href="#algo_deleterel"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_deleterel" class="collapse">
								<div class="code">
									<pre><code>int OpenRelTable::deleteRel(int relId){

	if relid is outside the range [0, MAX_OPEN-1]:
	{
		return E_OUTOFBOUND;
	}
	
	if entry corresponding to the relId in the Open Relation Table is free:
	{
		return E_NOTOPEN;
	}
	
	/****** Deleting from Relation Cache******/
	
	//using the firstBlk and lastBlk fields of the Relation Catalog entry in the relId<sup>th</sup> Relation Cache entry, iteratively release the blocks of the relation calling <a href="buffer.html#releaseblock" target="_blank">BlockBuffer::releaseBlock()</a>.
	
	/* delete the record entry corresponding to the relation from the Relation Catalog by setting the recId.slot entry in 
	slotMap of recId.block to 0 using <a href="buffer.html#getslotmap" target="_blank">RecBuffer::getSlotmap()</a> and  <a href="buffer.html#setslotmap" target="_blank">RecBuffer::setSlotmap()</a>.*/
	

	
	/****** Deleting from Attribute Cache ******/
	
	// iterate over all the entries in the linked list of the relId<sup>th</sup> entry in Attribute Cache.
	{
	
		//if the attribute corresponding to the entry has a B+ Tree associated with it, release the allocated index blocks using <a href="b+tree.html##destroy" target="_blank">BPlusTree::bPlusDestroy()</a>.
	
		/* delete the record entry corresponding to the Attribute Cache entry from the Attribute Catalog by setting the recId.slot entry in 
		   slotMap of recId.block to 0 using <a href="buffer.html#getslotmap" target="_blank">RecBuffer::getSlotmap()</a> and  <a href="buffer.html#setslotmap" target="_blank">RecBuffer::setSlotmap()</a>.*/
		
		// free the memory dynamically alloted to this entry in Attribute Cache linked list.
	}
	
	/****** Deleting from Open Relation Table ******/
	
	// free the relId<sup>th</sup> entry of the tableMetaInfo.

	return SUCCESS;	
	
}</code></pre>
								</div>
							</div>
						</div>
					</li>

         <!-------------------------------getFreeOpenRelTableEntry------------------------------------------------------------>
					<li>
						<div class="detail" id="get_free_open_rel_table_entry">
							<h2><i>private:</i> getFreeOpenRelTableEntry</h2>
							<h5>Arguments:</h5>
							<p>void</p>
							<h5>Return type:</h5>
							<div class="table-responsive">
							    <table class="table table-bordered table-hover">
								<tr>
									<td>relId</td>
									<td>int</td>
									<td>Index of a free entry in the Open Relation Table.</td>
								</tr>
								<tr>
									<td><a href="../constants.html" target="_blank"> FAILURE </a></td>
									<td>int</td>
									<td>No free entries left in the Open Relation Table.</td>
								</tr>
							    </table>
							</div>
							<h5>Description:</h5>
							<p>Returns index of an unoccupied entry in the Open Relation Table. </p>
							<h5><a data-toggle="collapse" href="#algo_get_free_open_rel_table_entry"><span class="fas fa-code"></span>Algorithm:</a></h5>
							<div id="algo_get_free_open_rel_table_entry" class="collapse">
								<div class="code">
									<pre><code>int OpenRelTable::getFreeOpenRelTableEntry(){

	/* traverse through the tableMetaInfo array,
		find a free entry in the Open Relation Table.*/
    
	// if found return the relation id, else indicate failure.
	
}</code></pre>
								</div>
							</div>
						</div>
					</li>
				</ul>
			</div>
<!---------------------------------------------------------------------------------------------------------->
                                  
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
    </div>
    <!-- END OF CONTENT -->
</body>

</html>	
	

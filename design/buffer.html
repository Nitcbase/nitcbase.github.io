<!DOCTYPE HTML>
<html>

<head>
    <title>Buffer Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-md-2">
                    <nav class="navbar navbar-expand-md sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            <li> <a class="sec" href="#layout"> Layout</a></li>
                            <li> <a class="sec" href="#block_structures"> Block Structures</a></li>
                            <li> <a class="sec" href="#static_buffer_class"> Class StaticBuffer</a></li>
                            <ul>
                                <li><a href="#static_buffer_constructor">StaticBuffer</a> </li>
                                 <li><a href="#static_buffer_destructor">~StaticBuffer</a> </li>
                                 <li><a href="#getfreebuffer">getFreeBuffer()</a> </li>
                                 <li><a href="#getbuffernum">getBufferNum()</a> </li>
				 <li><a href="#getstaticblocktype">getStaticBlockType()</a> </li>
                            </ul>
                            <li> <a class="sec" href="#blkbuff_class"> Class BlockBuffer</a></li>
                            <ul>
                                <li><a href="#blk_buffer_constructor1">BlockBuffer 1</a> </li>
                                <li><a href="#blk_buffer_constructor2">BlockBuffer 2</a> </li>
                                <li><a href="#getbuffptr">getBufferPtr()</a> </li>
				<li><a href="#getheader">getHeader()</a> </li>
				<li><a href="#setheader">setHeader()</a> </li>
				<li><a href="#getblk">getBlock()</a> </li>
				<li><a href="#getfreeblk">getFreeBlock()</a> </li>
				<li><a href="#getblkNum">getBlockNum()</a> </li>
				<li><a href="#getblocktyper">getBlockType()</a> </li>
				<li><a href="#setblocktype">setBlockType()</a> </li>

                            </ul>
                            <li> <a class="sec" href="#recbuff_class"> Class RecBuffer</a></li>
			    <ul>
                                <li><a href="#recbuff_constructor1">RecBuffer 1</a> </li>
                                <li><a href="#recbuff_constructor2">RecBuffer 2</a> </li>
                                <li><a href="#getslotmap">getSlotmap()</a> </li>
				<li><a href="#setslotmap">setSlotmap()</a> </li>
				<li><a href="#getrecord">getRecord()</a> </li>
				<li><a href="#setrecord">setRecord()</a> </li>
			    </ul>
                            <li> <a class="sec" href="#indbuff_class"> Class IndBuffer</a></li>
			    <ul>
                                <li><a href="#indbuff_constructor1">IndBuffer 1</a> </li>
                                <li><a href="#indbuff_constructor2">IndBuffer 2</a> </li>
			    </ul>
                            <li> <a class="sec" href="#intbuff_class"> Class IndInternal</a></li>
			    <ul>
                                <li><a href="#intindbuff_constructor1">IndInternal 1</a> </li>
                                <li><a href="#intindbuff_constructor2">IndInternal 2</a> </li>
                                <li><a href="#intgetentry">getEntry()</a> </li>
				<li><a href="#intsetentry">setEntry()</a> </li>
			    </ul>
                            <li> <a class="sec" href="#leafbuff_class"> Class IndLeaf</a></li>
			    <ul>
                                <li><a href="#leafindbuff_constructor1">IndLeaf 1</a> </li>
                                <li><a href="#leafindbuff_constructor2">IndLeaf 2</a> </li>
                                <li><a href="#leafgetentry">getEntry()</a> </li>
				<li><a href="#leafsetentry">setEntry()</a> </li>
			    </ul>
                            <li> <a class="sec" href="#misc"> Miscellaneous</a></li>
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-md-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        
                         <div class="pagetitle">
                            <h1>Buffer Layer</h1>
                         </div>
                        
                         <div id="layout" class="detail">
                         	<h2>Layout</h2>
                            <p>Whenever NITCbase needs to work on a disk block, the block has to be first fetched from the secondary memory storage (the <a href="../storage-model.html" target="_blank">disk</a>) to the primary memory. A large pool of memory (called <i>buffer</i> in the documentation) is pre-allocated and managed to hold copies of disk blocks in the primary memory. When a request involving access/update of a disk block comes from any of the higher layers, the corresponding disk block is loaded into the buffer. After performing updates, the block has to be committed back to the disk. </p>   
                                
                            <p>NITCbase uses a dedicated <i>Buffer Layer</i> for the above task. All the requests involving disk blocks go through the Buffer Layer. The interface provided by the Buffer Layer gives a <i>memory disk abstraction</i> to higher layers. NITCbase has pre-allocated memory for holding 32 blocks in its buffer memory at a given time. Buffer Layer is responsible for maintaining the buffer memory and making replacements and writebacks as required. The <a href="../storage-model.html#disk_class" target="_blank">disk class</a> functions are used by the Buffer Layer to load blocks from the disk to the buffer and back. A single object of the disk class needs to be declared at the start of the session. Its purpose is to run the constructor and the destructor of the class. </p>
    
			    <p>NITCbase follows an Object-Oriented design for Buffer Layer. The class diagram is as shown below. </p>
                         
			    <center><img class="img-fluid" src="/img/buffer_class.png"></center>
                            <br><br>
				 
                            <p>Certain structure definitions and functions that help access record data and metadata from the disk block are also included in the Buffer Layer. These are discussed at the end of this page (see <a href="#misc">miscellaneous</a> section).</p>
                         </div>
                        
                        <div id="block_structures" class="detail">
                            <h2>Block Structures</h2>
                            <p>The Buffer Layer defines the following block data structures. </p>
                            <ol>
                                <li>HeadInfo</li>
                                <li>Attribute</li>
                                <li>InternalEntry</li>
                                <li>Index</li>
                            </ol>
                            <p>Each structure is designed to store a subset of the data stored in a disk block. A disk block contains 2048 bytes of data. Higher layer functions, however, instead of processing the whole block data together, typically request access to a particular set of related data in a disk block at a time. Whenever such a <i>selective access</i> request is made, the method in the Buffer Layer implementing the access functionality will pack the requested data into the corresponding block structure designed to store that particular type of data. Variables of these structures will be declared and used in the <a href="cache.html" target="_blank">Cache Layer</a>, the <a href="blockaccess.html" target="_blank">Block Access Layer</a>, and the <a href="b+tree.html" target="_blank">B+ Tree Layer</a>. </p>
                            
							<div id="block_structures_headinfo">
								<h4>HeadInfo</h4>
								<p>NITCbase maintains a 32 bytes fixed-size header for every disk block. This header stores meta-information, like the type of the block, and a few block specific information, like #Attrs and #Slots. Though the header has many fields, usage of the fields depends on the type of the block. The structure <i>HeadInfo</i> is used to collect all the entries of the header, as shown below. The <i><a href="#setheader">setHeader()</a></i>  and the <i><a href="#getheader">getHeader()</a></i> methods take a pointer to <i>struct HeadInfo</i> as argument. </p> 

								<p><b>Implementation Note:</b> <i>getHeader()</i> and <i>setHeader()</i> methods expect the higher layers to allocate memory for the <i>struct HeadInfo</i> before calling them. </p>
								<div class="code">
									<pre><code>struct HeadInfo{
	int32_t blockType;
	int32_t pBlock;
	int32_t lBlock;
	int32_t rBlock;
	int32_t numEntries;
	int32_t numAttrs;
	int32_t numSlots;
	unsigned char reserved[4];
};
	/* #include &lt;cstdint&gt; must be done */ 
	</code></pre>
								</div>
							</div>
			    			<div id="block_structures_attribute">
                            	<h4>Attribute</h4>
                            	<p>According to the Physical Layer storage model, a <a href="../storage-model.html#record_blk" target="_blank">Record</a> block has slots for storing records, and each record contains a set of attributes. The <i>Attribute</i> block data structure is used to hold an attribute in memory. Since an attribute can have one amongst different types (integer/ float/ string), <i>Attribute</i> is a union of all the three types. The size of an <i>Attribute</i> is fixed at 16 bytes. A record will be an array of <i>Attributes</i> whose size is equal to the number of attributes in the relation. An attribute being a fundamental unit of data in a record, the <i>Attribute</i> block data structure is used in several functions of NITCbase. </p>
                            	<div class="code">
                                	<pre><code>typedef union Attribute{
	int iVal;
	float fVal;
	char strVal[ATTR_SIZE];
} Attribute;</code></pre>
                            	</div>
			    			</div>
							<div id="block_structures_internal_entry">
								<h4>InternalEntry</h4>
								<p>Each <a href="../storage-model.html#intind_blk" target="_blank">Internal Index</a> block of a <a href="https://en.wikipedia.org/wiki/B%2B_tree" target="_blank">B+ Tree</a> consists of many attribute values and child pointers. This data is arranged in the block in such a way that an attribute value is stored between its left child and right child pointers. The right child pointer of one attribute value will be the same as the left child pointer of the next attribute value. Hence to avoid redundancy, only one copy is stored, making the data overlapped. The combination of left child, attribute value, and right child makes up the <i>InternalEntry</i> structure, as shown below. An Internal Index block is a combination of 100 such overlapped entries. The <i><a href="#intgetentry">getEntry()</a></i> and <i><a href="#intsetentry">setEntry()</a></i> methods of the class <a href="#intbuff_class">IndInternal</a> take a pointer to <i>struct InternalEntry</i> as an argument. </p>
								<p><b>Implementation Note:</b> The <i>getEntry()</i> and <i>setEntry()</i> methods are declared in the class <a href="#indbuff_class">IndBuffer</a> but are <a href="https://en.wikipedia.org/wiki/Method_overriding" target="_blank">overridden</a> in the class <a href="#intbuff_class">IndInternal</a>. <i>getEntry()</i> and <i>setEntry()</i> methods expect the higher layers to allocate memory for <i>struct InternalEntry</i> before calling them. </p>
								<div class="code">
								<pre><code>struct InternalEntry{
	int32_t lChild;
	union Attribute attrVal;
	int32_t rChild;
};
/* #include &lt;cstdint&gt; must be done */ </code></pre>
                            		</div>
							</div>
						   <div id="block_structures_index">
								<h4>Index</h4>
								<p>An index of a relation should store a reference to its record along with the corresponding attribute value. NITCbase uses <a href="#recid">RecId</a>, which is a (block#, slot#) pair, for referencing any record. In NITCbase, an <i>Index</i> structure is a combination of attribute value, block#, and slot#, followed by some unused space left for future use, as shown below. Each <a href="../storage-model.html#leafind_blk" target="_blank">Leaf Index</a> block is a combination of 63 such <i>Index</i> entries.  The <i><a href="#leafgetentry">getEntry()</a></i> and the <i><a href="#leafsetentry">setEntry()</a></i> methods of the class <a href="#leafbuff_class">IndLeaf</a> take a pointer to <i>struct Index</i> as an argument. </p>
								<p><b>Implementation Note:</b> The <i>getEntry()</i> and <i>setEntry()</i> methods are declared in the class <a href="#indbuff_class">IndBuffer</a> but are <a href="https://en.wikipedia.org/wiki/Method_overriding" target="_blank">overridden</a> in the class <a href="#leafbuff_class">LeafBuffer</a>. <i>getEntry()</i> and <i>setEntry()</i> methods expect the higher layers to allocate memory for <i>struct Index</i> before calling them. </p>
								<div class="code">
								<pre><code>struct Index{
	union Attribute attrVal;
	int32_t block;
	int32_t slot;
	unsigned char unused[8];
};
/* #include &lt;cstdint&gt; must be done */ </code></pre>
								</div>
						   </div>
						</div>
                         
			    
						<div id="buffer_structures" class="detail">
                            <h2>Buffer Structure</h2>
                            <p>The Buffer Layer also defines a buffer structure. <a href="#static_buffer_class">StaticBuffer</a> class maintains meta-information for each block loaded to a buffer. The <i>BufferMetaInfo</i> structure is used for storing this meta-information. This structure contains four fields: a <i>free</i> flag which indicates whether the buffer is occupied, a <i>dirty</i> flag which indicates whether the block has been modified, a <i>blockNum</i> field which is the block number of the block that is stored in the given buffer and a <i>timeStamp</i> field which indicates the last time the buffer had been accessed. Replacement is done using a simple <i>Least Recently Used</i>(LRU) algorithm, which has been implemented in the <a href="#getfreebuffer">getFreeBuffer()</a> method. The timeStamp field has to be updated each time the buffer is accessed, as is done in the <a href="#getbuffptr">getBufferPtr()</a> method. </p>
                            
			    <div class="code">
                                <pre><code>struct BufferMetaInfo{
	bool free;
	bool dirty;
	int blockNum;
	int timeStamp;
};</code></pre>
                             </div>
                        </div>
			    
                         <div id="static_buffer_class" class="detail">
                         	<h2>class StaticBuffer</h2>
                             
							 <p>The class <i>StaticBuffer</i> contains as its member field, <i>blocks[32][<a href="../constants.html" target="_blank">BLOCK_SIZE</a>]</i>, a two-dimensional array of unsigned characters with size sufficient to store 32 disk blocks in memory at any given time. Logically <i>blocks[i]</i> can be used to buffer one disk block for each 0 ≤ i ≤ 31. Each entry of <i>blocks</i>, i.e., <i>blocks[i]</i>, is referred to as <b>buffer block</b> in the NITCbase documentation. Buffer blocks will be committed back to the disk as and when required. In addition to storing the data of a block, class <i>StaticBuffer</i> also maintains meta-information for each loaded block in an array of <a href="#buffer_structures">BufferMetaInfo</a> structures through the <i>metaInfo[32]</i> field. <i>StaticBuffer</i> class also maintains a copy of the <a href="../storage-model.html#disk_model" target="_blank">Block Allocation Map</a> in its <i>blockAllocMap[<a href="../constants.html" target="_blank">DISK_BLOCKS</a>]</i> field. The i<sup>th</sup> entry      of the Block Allocation Map specifies whether the i<sup>th</sup> block is occupied or free. If occupied, it stores the type(<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF/UNUSED</a>) of the block.  </p>

				 			 <p>All these data fields are private to the <i>StaticBuffer</i> class and can only be accessed through public methods. This class provides the basic disk <i>fetch and commit</i> interfaces to the higher layers, creating an illusion of having the entire disk in memory at all times. <i>StaticBuffer</i> is a <b>static class</b>, i.e., all member fields and methods are declared static. By doing so, memory will be allocated <a href="https://en.wikipedia.org/wiki/Static_variable" target="_blank">statically</a> for all member fields of the class, and any access to them will refer to the same statically allocated memory. Also static methods in a class are allowed to access only static members of the class. Consequently, there needs to exist only a single static object of the class*. The class definition of <i>StaticBuffer</i> is as given below: </p>
                             
                             <p><b>Note:</b> The class <i>BlockBuffer</i> is a friend class to <i>StaticBuffer</i> class. This allows all methods in <i>BlockBuffer</i> to access the private fields and methods of the <i>StaticBuffer</i> class. At the same time, friendship is not inherited in C++, i.e., if a base class has a friend class, then the class doesn’t become a friend of the derived classes. This is explained in detail in the next section. </p>
                             
                             <p><b><span style="color: dodgerblue">*</span>Implementation Note:</b> C++ allows <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank">static methods</a> to be accessed using the semantics class_name::function_name(), instead of object_instance->function_name() as in the case of methods that are not declared statically. Since the class is static, only a single object of the class needs to be created when NITCbase is running, whose sole purpose is to run the <a href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)" target="_blank">constructor</a> and the <a href="https://en.wikipedia.org/wiki/Destructor_(computer_programming)" target="_blank">destructor</a>.</p>
                             <div class="code">
                                <pre><code>class StaticBuffer{
				
friend class BlockBuffer;

public:
	//methods
	StaticBuffer();
	~StaticBuffer();
	static int getStaticBlockType(int blockNum);
	static void setDirtyBit(int blockNum);
	
private:
	//fields
	static unsigned char blocks[32][BLOCK_SIZE];
	static struct BufferMetaInfo metaInfo[32];
	static unsigned char blockAllocMap[DISK_BLOCKS];

	//methods
	static int getBufferNum(int blockNum);
	static int getFreeBuffer(int blockNum);
	
};</code></pre>
                             </div>
                         	<br>
                             <p>The following are the specifications for the methods in class <i>StaticBuffer</i>. The stub code is availabe <a href="bufferStub.html" target="_blank">here</a>.</p>
                             <ul class="methods">
<!-------------------------------------------StaticBuffer Constructor----------------------------------------------------------->
                                 <li>
                                    <div class="detail" id="static_buffer_constructor">
                                        <h2><i>public:</i> StaticBuffer (Constructor)</h2>
                                        <h5>Arguments:</h5>
                                        <p>Nil</p>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Copies Block Allocation Map from disk to buffer memory and updates the meta information of each buffer to initial empty conditions. Should be called at the beginning of the session after the <a href="../storage-model.html#disk_constructor" target="_blank">Disk constructor</a>. </p>
                                        <h5><a data-toggle="collapse" href="#algo_static_buffer_constructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo_static_buffer_constructor" class="collapse">
                                            <div class="code">
                                                <pre><code>StaticBuffer::StaticBuffer(){
    // copy <a href="../storage-model.html#disk_model" target="_blank">Block Allocation Map</a> blocks from disk to <i>blockAllocMap</i> using <a href="../storage-model.html#disk_readBlock" target="_blank">Disk::readBlock()</a>.

    //initialize <i>metaInfo</i> of all the buffer blocks with free:true, dirty:false, blockNum:-1 and timeStamp:-1.
    
}</code></pre>
                                            </div>
                                        </div>
					<p><b>NOTE:</b> The object of the StaticBuffer class must be declared after the object of the <a href="../storage-model.html#disk_class" target="_blank">Disk class</a> to ensure that the StaticBuffer constructor is called after the Disk constructor.</p>
                                    </div>
                                 </li>
<!-------------------------------------------StaticBuffer Destructor----------------------------------------------------------->
                                 <li>
                                    <div class="detail" id="static_buffer_destructor">
                                        <h2><i>public:</i> ~StaticBuffer (Destructor)</h2>
                                        <h5>Arguments:</h5>
                                        <p>Nil</p>                            
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Copies the Block Allocation Map and the dirty blocks from the buffer memory to disk. Should be called at the end of the session before the <a href="../storage-model.html#disk_constructor" target="_blank">Disk destructor</a>.</p>
                                        <h5><a data-toggle="collapse" href="#algo_static_buffer_destructor"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo_static_buffer_destructor" class="collapse">
                                            <div class="code">
                                                <pre><code>StaticBuffer::~StaticBuffer(){
    // copy <i>blockAllocMap</i> to <a href="../storage-model.html#disk_model" target="_blank">Block Allocation Map</a> blocks in the disk using <a href="../storage-model.html#disk_writeBlock" target="_blank">Disk::writeBlock()</a>.

    /*iterate through all the <i>metaInfo</i> entries, 
    	write back buffer blocks with meta-info as free:false,dirty:true using <a href="../storage-model.html#disk_writeBlock" target="_blank">Disk::writeBlock()</a>.*/
	
}</code></pre>
                                            </div>
                                        </div>
									<p><b>NOTE:</b> The object of the StaticBuffer class must be declared after the object of the <a href="../storage-model.html#disk_class" target="_blank">Disk class</a> to ensure that the StaticBuffer destructor is called before the Disk destructor.</p>
                                    </div>
                                 </li>
<!-------------------------------------------getStaticBlockType Function----------------------------------------------------------->
								 <li>
                                    <div class="detail" id="getstaticblocktype">
                                        <h2><i>public: </i>getStaticBlockType</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the block whose type is required.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>blockType</td>
                                                    <td>int</td>
                                                    <td>Block type of the block (<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF/UNUSED</a>).</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Description:</h5>
                                        <p>Returns the block type of the block corresponding to the input block number. This function is used to find the block type without the creation of a block object. </p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-getstaticblocktype"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getstaticblocktype" class="collapse">
                                            <div class="code">
<pre><code> int StaticBuffer::getStaticBlockType(int blockNum){
    //traverse the <i>blockAllocMap</i> to find the type corresponding to blockNum.
    
    //return the blockType obtained(<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF/UNUSED</a>)
    
}
</code></pre>
                                            </div>
                                        </div>
									<p><b>NOTE:</b> This function is useful in cases where, given a block number, its block type is not known. Hence it is also not known which type of record object (Record, Internal Index, or Leaf Index) needs to be used to store the block. This function has been used in the <a href="b+tree.html" target="_blank">B+ Tree Layer</a>, where the block number of the constituent blocks of a B+ Tree is known, but it is not known whether the block is of type <a href="#intbuff_class">IndInternal</a> or <a href="#leafbuff_class">IndLeaf</a>. </p>
                                    </div>
                                 </li>
				     
<!-------------------------------------------setDirtyBit Function----------------------------------------------------------->
				<li>
                                    <div class="detail" id="setdirtybit">
                                        <h2><i>public: </i>setDirtyBit</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the block whose buffer's dirty bit is to be set.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>void</p>
					    
                                        <h5>Description:</h5>
                                        <p>Sets the dirty bit of the buffer corresponding to the block.</p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-setdirtybit"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-setdirtybit" class="collapse">
                                            <div class="code">
<pre><code> void StaticBuffer::setDirtyBit(int blockNum){
    //find the buffer number corresponding to the block using <a href="#getbuffernum">getBufferNum()</a>.
    
    //set the <i>dirty</i> flag of that buffer in <i>metaInfo</i> to true.
    
}
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>				     

<!-------------------------------------------getBufferNum Function----------------------------------------------------------->				     
                                 
                                 <li>
                                    <div class="detail" id="getbuffernum">
                                        <h2><i>private: </i>getBufferNum</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the block whose buffer number is required.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>bufferNum</td>
                                                    <td>int</td>
                                                    <td>Buffer number to which the given block is loaded.</td>
                                                </tr>
                                                <tr>
                                                    <td><a href="../constants.html" target="_blank"> FAILURE </a></td>
                                                    <td>int</td>
                                                    <td>Block is not loaded to any buffer.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Description:</h5>
                                        <p>Returns the buffer number of the buffer to which the block with the given block number is loaded.</p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-getbuffernum"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getbuffernum" class="collapse">
                                            <div class="code">
<pre><code> int StaticBuffer::getBufferNum(int blockNum){
    //traverse through the <i>metaInfo</i> array,
    	find the buffer number of the buffer to which the block is loaded.
    
    //if found return buffer number, else indicate failure.
	
}
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
				     
<!-------------------------------------------getFreeBuffer Function----------------------------------------------------------->
				                          
                                 <li>
                                    <div class="detail" id="getfreebuffer">
                                        <h2><i>private: </i>getFreeBuffer</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the block to be loaded to a buffer block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>bufferNum</td>
                                                    <td>int</td>
                                                    <td>Buffer number of the free/freed buffer block assigned to the input block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Description:</h5>
                                        <p>Assigns a buffer to the block and returns the buffer number. If no free buffer block is found, the <i>least recently used</i> (LRU) buffer block is replaced. </p>
                                        <h5><a data-toggle="collapse" href="#algo-getfreebuff"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getfreebuff" class="collapse">
                                            <div class="code">
<pre><code> int StaticBuffer::getFreeBuffer(int blockNum){
    // increase the <i>timeStamp</i> in <i>metaInfo</i> of all occupied buffers.
    
    // let <i>bufferNum</i> be used to store the buffer number of the free/freed buffer.
	
    // if a free buffer is available, <i>bufferNum</i> is the index of that free buffer.
    
    // if a free buffer is not available, write back the buffer with the largest <i>timeStamp</i> using <a href="../storage-model.html#disk_writeBlock" target="_blank">Disk::writeBlock()</a> and set it as <i>bufferNum</i>.
    
    // update the <i>metaInfo</i> entry corresponding to <i>bufferNum</i> with free:false, dirty:false, blockNum:the input block number and timeStamp:0.
    
    // return the <i>bufferNum</i>.
}
</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> 
											<ul>
												<li>This function never fails - a buffer is <i>always</i> assigned to the block.</li>
												<li>The <i>timeStamp</i> is reset to 0 each time the buffer block is accessed and incremented when other buffer blocks are accessed. Thus the buffer block with the largest <i>timeStamp</i> is the one that is least recently used. </li>
												<li>The function allots a free buffer block, fills its <i>metaInfo</i> with relevant information, and updates the timeStamp. The caller is responsible for actually loading the block into the buffer. </li>
											</ul>
										</p>
                                    </div>
                                 </li>
							</ul>
						</div>
                        <div id="blkbuff_class" class="detail">
                         	<h2>Class BlockBuffer </h2>
                             <p>The class <i>BlockBuffer</i> is a generic class for representing a disk block of any type (Record, Internal Index, or Leaf Index). Its only field is <i>blockNum</i>. The field <i>blockNum</i> stores the disk block number corresponding to the block object. The block has to be loaded and stored in one of the 32 buffers of the <i>StaticBuffer</i> class before its data can be accessed. Adding to the complexity is the fact that the block, once loaded, may not even be present in the buffer memory later on because of the buffer replacement algorithm implemented by Buffer Layer. In order to work with data of the block, any method of the <i>BlockBuffer</i> class or its descendent classes need to know the address of the buffer memory to which the block has been loaded. Hence any method of this class operating on the block data should first get the pointer to the buffer memory that holds the contents of the block. The <i>getBufferPtr()</i> method is used for this purpose. The public methods of <i>BlockBuffer</i> deal with the information like <a href="#block_structures_headinfo">header</a> and block type, which are generic to all blocks. <a href="#recbuff_class">RecBuffer</a> and <a href="#indbuff_class">IndBuffer</a> classes extend the class <i>BlockBuffer</i>, thereby inheriting all the fields and methods of <i>BlockBuffer</i>. </p>
                             <p><b>Note:</b>If the class definition of a class (say A) declares another class (say B) as a <a href="https://en.wikipedia.org/wiki/Friend_class" target="_blank">friend class</a>, then an instance of class B can access the private fields and methods of class A. This friendship is, however, not inherited by the child classes of B. As per the NITCbase design, the definition of the class StaticBuffer contains the declaration: <i>friend class BlockBuffer</i>. Hence, the methods in <i>BlockBuffer</i> can access the private fields and methods of the class StaticBuffer. On the other hand, <a href="#recbuff_class">RecBuffer</a> and <a href="#indbuff_class">IndBuffer</a> classes can access them only through the public functions of StaticBuffer and through the public and protected functions of <i>BlockBuffer</i> class. </p>
                            <div class="code">
                                <pre><code>class BlockBuffer{
public:
	//methods
	BlockBuffer(char blockType);
	BlockBuffer(int blockNum);
	int getBlockNum();
	int getBlockType();
	void setBlockType(int blockType);
	void getHeader(struct HeadInfo* head);
	void setHeader(struct HeadInfo* head);
	void releaseBlock();

protected:
	//field
	int blockNum;
	
	//methods
	unsigned char *getBufferPtr();
	int getBlock();
	int getFreeBlock(int BlockType);

};</code></pre> 
                            </div>
                            <p>The following are the specifications for the methods in class <i>BlockBuffer</i>. The stub code is availabe <a href="bufferStub.html" target="_blank">here</a>. </p>
                             <ul class="methods">
				     
<!-----------------------------BlockBuffer Constructor 1 -------------------------------------------------------->	     
				 				<li>
                                    <div class="detail" id="blk_buffer_constructor1">
                                        <h2><i>public:</i> BlockBuffer (Constructor 1)</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
												<tr>
													<td>R</td>
													<td>char</td>
													<td>new <a href="../constants.html" target="_blank">REC</a> block to be alloted.</td>
												</tr>
												<tr>
													<td>I</td>
													<td>char</td>
													<td>new <a href="../constants.html" target="_blank">IND_INTERNAL</a> block to be alloted.</td>
												</tr>
												<tr>
													<td>L</td>
													<td>char</td>
													<td>new <a href="../constants.html" target="_blank">IND_LEAF</a> block to be alloted.</td>
												</tr>
											</table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Called if a new block is to be allocated in the disk.</p>
					
                                        <h5><a data-toggle="collapse" href="#algo_blk_buffer_constructor1"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo_blk_buffer_constructor1" class="collapse">
                                            <div class="code">
                                                <pre><code>Blockbuffer::BlockBuffer(char blockType){
	// allocate a block in the disk and a buffer in memory to hold the new block of given type using <a href="#getfreeblk">getFreeBlock</a>().

	// set the <i>blockNum</i> field of the object to that of the allocated block number.

}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> If the block already exists on the disk use <a href="#blk_buffer_constructor2">constructor 2</a>.</p>
                                    </div>
                                 </li>
<!-------------------------------------------BlockBuffer Constructor 2----------------------------------------------------------->
                                 <li>
                                    <div class="detail" id="blk_buffer_constructor2">
                                        <h2><i>public:</i> BlockBuffer (Constructor 2)</h2>

                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <td>blockNum</td>
                                                <td>int</td>
                                                <td>Block number of the block whose object is to be created.</td>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Called when the block already exists on the disk.</p>
					
                                        <h5><a data-toggle="collapse" href="#algo_blk_buffer_constructor2"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo_blk_buffer_constructor2" class="collapse">
                                            <div class="code">
                                                <pre><code>Blockbuffer::BlockBuffer(int blockNum){
	// set the <i>blockNum</i> field of the object to input argument.

	// copy the block into buffer memory using <a href="#getblk">getBlock()</a> (discard the return value).

}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> If a new block is to be allocated in the disk use <a href="#blk_buffer_constructor1">constructor 1</a>.</p>
                                    </div>
                                 </li>            

 <!-------------------------------------------------getBlockNum-------------------------------------------------------------->
				     
				      			<li>
                                    <div class="detail" id="getblkNum">
                                        <h2><i>public:</i> getBlockNum</h2>
                                        <h5>Arguments:</h5>
										<p>Nil</p>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
						    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                       <h5>Description:</h5>
                                        <p>Returns the block number of the block.</p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-getblknum"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getblknum" class="collapse">
                                            <div class="code">
                                                <pre><code>int BlockBuffer::getBlockNum(){

	//return corresponding block number
}</code></pre>
                                            </div>
                                        </div>
                                     </div>
                                 </li>
					     
<!-----------------------------------getBlockType----------------------------------------------------------------------------->
				     
                                <li>
                                    <div class="detail" id="getblocktyper">
                                        <h2><i>public:</i> getBlockType</h2>
										<h5>Arguments:</h5>
                                        <p>Nil</p>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
						    <td>blockType</td>
                                                    <td>int</td>
                                                    <td>Type of the block(<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF</a>).</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Returns the type of the block corresponding to the block object.</p>
					                   
                                        <h5><a data-toggle="collapse" href="#algo-getblktype"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getblktype" class="collapse">
                                            <div class="code">
                                                <pre><code>int BlockBuffer::getBlockType(){

	// get the starting address of the buffer containing the block using <a href="#getbuffptr">getBufferPtr()</a>. 
	
	//return the first 4 bytes of the buffer that stores the block type.
	
}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
			
<!-----------------------------------setBlockType----------------------------------------------------------------------------->
				     
                                <li>
                                    <div class="detail" id="setblocktype">
                                        <h2><i>public:</i> setBlockType</h2>
										<h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
												    <td>blockType</td>
                                                    <td>int</td>
                                                    <td>Type used to set the block type(<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF</a>).</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5> 
										<p>void</p>
                                        
                                        <h5>Description:</h5>
                                        <p>Sets the type of the block with the input block type.</p>
					                   
                                        <h5><a data-toggle="collapse" href="#algo-setblktype"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-setblktype" class="collapse">
                                            <div class="code">
                                                <pre><code>void BlockBuffer::setBlockType(int blockType){						
	
	// get the starting address of the buffer containing the block using <a href="#getbuffptr">getBufferPtr()</a>.

	//store the input block type in the first 4 bytes of the buffer.

	//update the <i>StaticBuffer::blockAllocMap</i> entry corresponding to the object's block number. 

	//update dirty bit using <a href="#setdirtybit">StaticBuffer::setDirtyBit()</a>.
	
}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
			
<!------------------------------------------getheader--------------------------------------------------------------->				     
				     
                                <li>
                                    <div class="detail" id="getheader">
                                        <h2><i>public:</i> getHeader</h2>
					    
										<h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>head</td>
                                                    <td><a href="#block_structures_headinfo">struct HeadInfo*</a></td>
                                                    <td>Pointer to which the header contents of the block is copied.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>void</p>

                                        <h5>Description:</h5>
                                        <p>Gives the header of the block.</p>
					    
					                   
                                        <h5><a data-toggle="collapse" href="#algo-getheader"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getheader" class="collapse">
                                            <div class="code">
                                                <pre><code>void BlockBuffer::getHeader(struct HeadInfo *head){	
	
	// get the starting address of the buffer containing the block using <a href="#getbuffptr">getBufferPtr()</a>.

	//copy the header of block to the memory location pointed to by the <i>head</i> using appropriate type casting.

}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> 
											<ul>
												<li>Any type of block(Record, Internal Index, or Leaf Index) of NITCbase has the same header structure. Therefore, <i>getHeader()</i> method is kept in abstract <i>BlockBuffer</i> class.</li>
												<li>Higher layer must allocate memory for the pointer to <i>struct HeadInfo</i> before calling this function. </li>
											</ul>
								 		</p>
                                    </div> 
                                </li>
				     
<!------------------------------------------------setheader------------------------------------------------------->				     
                                <li>
                                    <div class="detail" id="setheader">
                                        <h2><i>public:</i> setHeader</h2>
										<h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>head</td>
                                                    <td><a href="#block_structures_headinfo">struct HeadInfo*</a></td>
                                                    <td>Pointer whose contents are copied to the block header.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>void</p>

                                        <h5>Description:</h5>
                                        <p>Sets the header of the block.</p>
                                        <h5><a data-toggle="collapse" href="#algo-setheader"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-setheader" class="collapse">
                                            <div class="code">
                                                <pre><code>void BlockBuffer::setHeader(struct HeadInfo *head){

	// get the starting address of the buffer containing the block using <a href="#getbuffptr">getBufferPtr()</a>.

	//copy the contents of the memory location pointed to by <i>head</i> to the header of block using appropriate type casting.

	//update dirty bit using <a href="#setdirtybit">StaticBuffer::setDirtyBit()</a>.
	
}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> 
											<ul>
												<li>Any type of block(Record, Internal Index, or Leaf Index) of NITCbase has the same header structure. Therefore, setHeader() method is kept in the abstract <i>BlockBuffer</i> class.</li>
												<li>Higher layer must allocate memory for the pointer to <i>struct HeadInfo</i> before calling this function. </li>
											</ul>
								 		</p>
                                    </div> 
                                </li>
				     
<!------------------------------------------------releaseblock------------------------------------------------------->	
		
                                <li>
                                    <div class="detail" id="releaseblock">
                                        <h2><i>public:</i> releaseBlock</h2>
										<h5>Arguments:</h5>
                                        <p>Nil</p>
                                        <h5>Return type:</h5>
                                        <p>void</p>

                                        <h5>Description:</h5>
                                        <p>Deletes the block from both the buffer memory and the disk.</p>
                                        <h5><a data-toggle="collapse" href="#algo-releaseblock"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-releaseblock" class="collapse">
                                            <div class="code">
                                                <pre><code>void BlockBufferBlockBuffer::releaseBlock(){

	// get the buffer number of the buffer assigned to the block using <a href="#getbuffernum">StaticBuffer::getBufferNum()</a>.

	//if the buffer number is valid, free the buffer by setting the <i>free</i> flag of its <i>metaInfo</i> entry to true.

	//free the block in disk by setting the data type of the entry corresponding to the block number in <i>StaticBuffer::blockAllocMap</i> to <a href="../constants.html" target="_blank">UNUSED</a>.
	
	//set the object's <i>blockNum</i> to -1.
	
}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
				     
<!-----------------------------------------------getBufferPtr------------------------------------------------------>
								 
                                <li>
                                    <div class="detail" id="getbuffptr">
                                        <h2><i>protected: </i>getBufferPtr</h2>
                                        <h5>Arguments:</h5>
					<p>Nil</p>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>bufferPtr</td>							
                                                    <td>unsigned char*</td>
                                                    <td>Pointer to the buffer containing the block.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Returns a pointer to the first byte of the buffer storing the block.
					
                                        <h5><a data-toggle="collapse" href="#algo-getbuffptr"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getbuffptr" class="collapse">
                                            <div class="code">
                                                <pre><code>unsigned char * BlockBuffer::getBufferPtr(){
	
	//find the buffer number of the block using <i>getBlock()</i> 
	
	// return the pointer to this buffer (given by <i>StaticBuffer::blocks[bufferNum]</i>).
}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b>All get and set methods accessing the block's data should call the <i>getBufferPtr()</i> method to get the starting address of the buffer block holding the block's data. This also ensures that the block is reloaded back to buffer memory if it had been replaced by the buffer replacement algorithm since the last data access. </p>
                                    </div> 
                                </li>
				     
<!-----------------------------------------------getblock---------------------------------------------------------->				     
				     
				    <li>
                                    <div class="detail" id="getblk">
                                        <h2><i>protected:</i> getBlock</h2>
                                        <h5>Arguments:</h5> Nil
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
						    <td>bufferNum</td>
                                                    <td>int</td>
                                                    <td>Buffer number of the buffer containing the block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                       <h5>Description:</h5>
                                        <p>Loads the block into buffer (if not present), updates the timestamps and returns the corresponding buffer number. </p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-getblk"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getblk" class="collapse">
                                            <div class="code">
                                                <pre><code>int BlockBuffer::getBlock(){

     // get the buffer number of the buffer assigned to the block using <a href="#getbuffernum">StaticBuffer::getBufferNum()</a>.
	 
     // if present in buffer memory(i.e., a valid buffer number), set the <i>timeStamp</i> of the corresponding buffer to 0 and increment the <i>timeStamp</i> in the <i>BufferMetaInfo</i> of all other occupied buffers.
     
     //if not present in buffer memory(i.e., an invalid buffer number), get a free buffer using <a href="#getfreebuffer">StaticBuffer::getFreeBuffer()</a> and read the block into the free buffer using <a href="../storage-model.html#disk_readBlock" target="_blank">Disk::readBlock()</a>.
   
   	//return the buffer number.
	
}</code></pre>
                                            </div>
                                        </div>
										<p><b>NOTE:</b> This function never fails - a buffer is <i>always</i> alloted to the block doing replacement, if necessary.</p>
                                     </div>
                                 </li>
		
<!--------------------------------------------getFreeBlock------------------------------------------------------------------->			     
				     
				      			<li>
                                    <div class="detail" id="getfreeblk">
                                        <h2><i>protected:</i> getFreeBlock</h2>
                                        <h5>Arguments:</h5> 
					    				<div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
						    						<td>blockType</td>
                                                    <td>int</td>
                                                    <td>Type of the required block (<a href="../constants.html" target="_blank">REC/IND_INTERNAL/IND_LEAF</a>).</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
						    <td>blockNum</td>
                                                    <td>int</td>
                                                    <td>Block number of the free block.</td>
                                                </tr>
						    
                                                <tr>
						    						<td><a href="../constants.html" target="_blank"> FAILURE </a></td>
                                                    <td>int</td>
                                                    <td>No free block is available on the disk.</td>
                                                </tr>
                                            </table>
                                        </div>
                                       <h5>Description:</h5>
                                        <p>Returns the block number of a free block of the input type in the disk and allots a buffer to that block. If free block is not available FAILURE is returned.</p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-getfreeblk"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getfreeblk" class="collapse">
                                            <div class="code">
                                                <pre><code>int BlockBuffer::getFreeBlock(int blockType){

	//iterate through the <i>StaticBuffer::blockAllocMap</i> and find the block number of a free block in the disk.

	//if no block is free, return FAILURE.
	
	//set the object's <i>blockNum</i> to the block number of the free block.

	//find a free buffer using <a href="#getfreebuffer">StaticBuffer::getFreeBuffer()</a> .
	
	//initialize the <a href="#block_structures_headinfo">header</a> of the block with pblock: -1, lblock: -1, rblock: -1, numEntries: 0, numAttrs: 0 and numSlots: 0 using <a href="#setheader">setHeader()</a>.	

	//update the block type of the block to the input block type using <a href="#setblocktype">setBlockType()</a>.

	//return block number of the free block.

}</code></pre>
                                            </div>
                                        </div>
                                     </div>
                                 </li>
			    			</ul>                    
                         </div>
                         
                         <div id="recbuff_class" class="detail">
                         	<h2>Class RecBuffer</h2>
                         	<p>An object of this class will be associated with a <i><a href="../storage-model.html#record_blk">record block</a></i>. Public methods of this class deal with access/retrieval of records and slotmap from a record block. <i>RecBuffer class</i> extends the <i><a href="#blkbuff_class">BlockBuffer class</a></i>.
                         	</p>
                             <div class="code">
                                <pre><code>class RecBuffer : public <a href="#blkbuff_class">BlockBuffer</a>{
public:

	//methods
	RecBuffer();
	RecBuffer(int blockNum);
	void getSlotmap(unsigned char *slotMap);
	void setSlotmap(unsigned char *slotMap);
	int getRecord(union Attribute *rec,int slotNum);
	int setRecord(union Attribute *rec,int slotNum);
};</code></pre>
                             </div>
                             <p>The following is the specification of methods of RecBuffer class</p>
                             <ul class="methods">

<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------Constructor 1----------------------------------------------------------------------------->
                                 <li>
                                    <div class="detail" id="recbuff_constructor1">
					    
					    
                                        <h2><i>public:</i> RecBuffer (Constructor 1)</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <td>blockNum</td>
                                                <td>int</td>
                                                <td>Block number of the record block</td>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Called when the record block already exists on the disk.</p>
					<p><b>NOTE:</b> If a new record block is to be allocated in the disk use <a href="#recbuff_constructor2">constructor 2</a>.</p>
                                        <h5><a data-toggle="collapse" href="#algo-recbuffer-constructor1"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-recbuffer-constructor1" class="collapse">
                                            <div class="code">
                                                <pre><code>RecBuffer::RecBuffer(int blockNum) : BlockBuffer(blockNum){} //this is a way to call parent non-default constructor.</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>

<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------Constructor 2----------------------------------------------------------------------------->

                                 <li>
                                    <div class="detail" id="recbuff_constructor2">
					    
					    
                                        <h2><i>public:</i> RecBuffer (Constructor 2)</h2>
                                        <h5>Arguments:</h5>
                                        Nil
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
                                        <p>Called if a new record block is to be allocated in the disk.</p>
					<p><b>NOTE:</b> If the record block already exists on the disk use <a href="#recbuff_constructor1">constructor 1</a>.</p>
                                        <h5><a data-toggle="collapse" href="#algo-recbuffer-constructor2"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-recbuffer-constructor2" class="collapse">
                                            <div class="code">
                                                <pre><code>
RecBuffer::RecBuffer() : BlockBuffer('R'){}  //this is a way to call parent non-default constructor.
					    // 'R' used to denote RecBuffer
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
				                                      
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------getslotmap----------------------------------------------------------------------------->

                                <li>
                                    <div class="detail" id="getslotmap" >
                                        <h2><i>public:</i> getSlotmap</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>slotMap</td>
                                                    <td>unsigned char *</td>
                                                    <td>Pointer to an array of unsigned char to which the slot map will be loaded.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>void</p>

                                        <h5>Description:</h5>
                                        <p>Gives the slotmap of the block.</p>
					<p><b>NOTE:</b> 
						<ul>
							<li>The array of unsigned char should have size equal to the size of slotmap.</li>
							<li>Higher layer must allocate memory for the unsigned char array before calling this function.</li>
					    	</ul>
					</p>
                                        <h5><a data-toggle="collapse" href="#algo-getslotmap"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getslotmap" class="collapse">
                                            <div class="code">
                                                <pre><code>void RecBuffer::getSlotmap(unsigned char *slotMap){ 
    // get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>. 
    
    // get the number of slots in the block.
    
    // using offset range copy the slotmap of the block to the memory pointed by the argument.
    
}</code></pre>
                                            </div>
                                        </div>
                                        
                                    </div> 
                                </li>
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------setslotmap----------------------------------------------------------------------------->
                                <li>
                                    <div class="detail" id="setslotmap" >
                                        <h2><i>public:</i> setSlotmap</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>slotMap</td>
                                                    <td>unsigned char *</td>
                                                    <td>Pointer to an array of type unsigned char from which the slot map will be loaded.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>void</p>

                                        <h5>Description:</h5>
                                        <p>Sets the slotmap of the block.</p>
					<p><b>NOTE:</b> The array of unsigned char should have size equal to the size of slotmap.</p>
                                        <h5><a data-toggle="collapse" href="#algo-setslotmap"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-setslotmap" class="collapse">
                                            <div class="code">
                                                <pre><code>void RecBuffer::setSlotmap(unsigned char *slotMap){ 
    // get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>. 
    
    // get the number of slots in the block.
    
    // using offset range copy the slotmap from the memory pointed by the argument to that of the block.
    
    //update dirty bit using setDirtyBit().
    
}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------getRecord----------------------------------------------------------------------------->
                                <li>
                                    <div class="detail" id="getrecord" >
                                        <h2><i>public:</i> getRecord</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>rec</td>
                                                    <td><a href="#block_structures_attribute">union Attribute</a> *</td>
                                                    <td>Pointer to an array of type <i>union Attribute</i> to which the record will be loaded.</td>
                                                </tr>
                                                <tr>
                                                    <td>slotNum</td>
                                                    <td>int</td>
                                                    <td>Slot number of the record in the block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
						    <td>int</td>
                                                    <td>Succesful copy of the record.</td>
                                                </tr>
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">E_OUTOFBOUND</a></td>
						    <td>int</td>
                                                    <td>The slotNum is outside the possible slot values of the block.</td>
                                                </tr>
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">E_FREESLOT</a></td>
						    <td>int</td>
                                                    <td>The slot corresponding to the slotNum is free.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Gives the <i>slotNum</i><sup>th</sup> record of the block.</p>
					<p><b>NOTE:</b> 
						<ul>
							<li>The array of <i>union Attribute</i> elements should have size equal to the number of attributes in the relation.</li>
							<li>Higher layer must allocate memory for the the array of <i>union Attribute</i> elements before calling this function.</li>
					    	</ul>
					</p>
                                        <h5><a data-toggle="collapse" href="#algo-getrecord"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-getrecord" class="collapse">
                                            <div class="code">
                                                <pre><code>int RecBuffer::getRecord(union Attribute *rec,int slotNum){ 
    // get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>. 

    // get number of attributes in the block.
    
    // get the number of slots in the block.

    // if input slotNum is not in the permitted range return E_OUTOFBOUND
    
    // if slot corresponding to input slotNum is free return E_FREESLOT

    // using offset range copy <i>slotNum</i><sup>th</sup> record to the memory pointed by <i>rec</i>.

    // return SUCCESS
	
}</code></pre>
                                            </div>
                                        </div>                                        
                                    </div> 
                                </li>
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------setrecord----------------------------------------------------------------------------->
                                <li>
                                    <div class="detail" id="setrecord" >
                                        <h2><i>public:</i> setRecord</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>rec</td>
                                                    <td><a href="#block_structures_attribute">union Attribute</a> *</td>
                                                    <td>Pointer to an array of type <i>union Attribute</i> from which the record will be loaded.</td>
                                                </tr>
                                                <tr>
                                                    <td>slotNum</td>
                                                    <td>int</td>
                                                    <td>Slot number of the record in the block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
						    <td>int</td>
                                                    <td>Succesful copy of the record.</td>
                                                </tr>
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">E_OUTOFBOUND</a></td>
						    <td>int</td>
                                                    <td>The slotNum is outside the possible slot values of the block.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Sets the <i>slotNum</i><sup>th</sup> record of the block as the input record.</p>
					<p><b>NOTE:</b> The array of <i>union Attribute</i> elements should have size equal to the number of attributes in the relation. </p>
                                        <h5><a data-toggle="collapse" href="#algo-setrecord"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-setrecord" class="collapse">
                                            <div class="code">
                                                <pre><code>void RecBuffer::setRecord(union Attribute *rec,int slotNum){ 
     // get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>. 
    
    // get number of attributes in the block.
    
    // get the number of slots in the block.

    // if input slotNum is not in the permitted range return E_OUTOFBOUND.
    
    // using offset range copy contents of the memory pointed by <i>rec</i> to <i>slotNum</i><sup>th</sup> record.

    // update dirty bit using setDirtyBit().
    
    // return SUCCESS
	
}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
                                 
                             </ul>
                            
                         </div>
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------IndBuffer----------------------------------------------------------------------------->
                        <div id="indbuff_class" class="detail">
                            <h2>Class IndBuffer</h2>
                            <p>IndBuffer extends <a href="#blkbuff_class">BlockBuffer class</a>. IndBuffer is a generic(abstract) class for Index Blocks. It has two <a href="https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions" target="_blank"><b>pure virtual methods</b></a>- getEntry() and setEntry(). These methods will be overridden in the child classes. The constructors of this class simply calls the constructor of the parent class with the argument received.</p>
                            <div class="code">
                                <pre><code>class IndBuffer : public <a href="#blkbuff_class">BlockBuffer</a>{
public:
	IndBuffer(int blockNum);
	IndBuffer(char blockType);
	virtual int getEntry(void *ptr, int indexNum) = 0;
	virtual int setEntry(void *ptr, int indexNum) = 0;
};</code></pre>
                            </div>
			    <p>The following is the specification of methods of IndBuffer class</p>
                            <ul class="methods">

<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------Constructor 1----------------------------------------------------------------------------->
                                <li>
                                    <div class="detail" id="indbuff_constructor1">
                                        <h2>IndBuffer (Constructor 1)</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <td>blockNum</td>
                                                <td>int</td>
                                                <td>Block number of the index block.</td>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
					    
                                        <h5>Description:</h5>
					<p>Called when the index block already exists on the disk.</p>
					<p><b>NOTE:</b> If a new index block is to be allocated in the disk use <a href="#indbuff_constructor2">constructor 2</a>.</p>
                                        
                                        <h5><a data-toggle="collapse" href="#algo-indbuffer-constructor1"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-indbuffer-constructor1" class="collapse">
                                            <div class="code">
                                                <pre><code>IndBuffer::IndBuffer(int blockNum) : BlockBuffer(blockNum){} //this is a way to call parent non-default constructor.</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
<!---------------------------------------------------------------------------------------------------------------->				     
				     

<!-----------------------------------Constructor 2----------------------------------------------------------------------------->
                                 <li>
                                    <div class="detail" id="indbuff_constructor2">
                                        <h2>IndBuffer (Constructor 2)</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
							<td>N</td>
							<td>char</td>
							<td><a href="../constants.html" target="_blank">IND_INTERNAL</a> block to be alloted</td>
						</tr>
						<tr>
							<td>L</td>
							<td>char</td>
							<td><a href="../constants.html" target="_blank">IND_LEAF</a> block to be alloted</td>
						</tr>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
					    
                                        <h5>Description:</h5>
					<p>Called if a index new block is to be allocated in the disk.</p>
					<p><b>NOTE:</b> If the index block already exists on the disk use <a href="#indbuff_constructor1">constructor 1</a>.</p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-indbuffer-constructor2"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-indbuffer-constructor2" class="collapse">
                                            <div class="code">
                                                <pre><code>IndBuffer::IndBuffer(char blockType) : BlockBuffer(blockType){} //this is a way to call parent non-default constructor.</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
                            </ul>
                        </div>
                        
<!---------------------------- IndInternal BEGINS------------------------------------------------------------------------->				     
				     
				     
                         <div id="intbuff_class" class="detail">
                         	<h2>Class IndInternal</h2>
                             <p>An object of this class will be associated with an <a href="../storage-model.html#intind_blk">internal index</a> buffer block. Public Methods of this class deal with the entries of <a href="../storage-model.html#intind_blk">Internal Index</a> (<a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a>) nodes in the buffer. IndInternal class extends <a href="#indbuff_class">IndBuffer</a> class and overrides the virtual methods in IndBuffer class. The constructor calls the constructor of the parent class by passing the argument.
                         	</p>
                             <div class="code">
                                 <pre><code>class IndInternal : public <a href="#indbuff_class">IndBuffer</a>{
public:
	//methods
	IndInternal();
	IndInternal(int blockNum);
	int getEntry(void *ptr, int indexNum) ;
	int setEntry(void *ptr, int indexNum) ;
};</code></pre>
                             </div>
                             <p>The following is the specification of methods of IndInternal class</p>
                             <ul class="methods">
<!------------------------------------Constructor 1------------------------------------------------------>
				     <li>
                                    <div class="detail" id="intindbuff_constructor1">
                                        <h2>IndInternal (Constructor 1)</h2>
                                        <h5>Arguments:</h5> 
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <td>blockNum</td>
                                                <td>int</td>
                                                <td>Block number of the internal index block</td>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
					    
                                        <h5>Description:</h5>
                                        <p>Called when the internal index block already exists on the disk.</p>
					<p><b>NOTE:</b> If a new internal index block is to be allocated in the disk use <a href="#intindbuff_constructor2">constructor 2</a>.</p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-intindbuffer-constructor1"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-intindbuffer-constructor1" class="collapse">
                                            <div class="code">
                                                <pre><code>IndInternal::IndInternal(int blockNum) : IndBuffer(blockNum){} //this is a way to call parent non-default constructor <i>IndBuffer::IndBuffer(int blockNum)</i>.
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
				     
<!------------------------------------Constructor 2------------------------------------------------------>
                                 <li>
                                    <div class="detail" id="intindbuff_constructor2">
                                        <h2>IndInternal (Constructor 2)</h2>
                                        <h5>Arguments:</h5>
					<p>Nil</p>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
					    
                                        <h5>Description:</h5>
                                        <p>Called if a new internal index block is to be allocated in the disk.</p>
					<p><b>NOTE:</b> If the internal index block already exists on the disk use <a href="#intindbuff_constructor1">constructor 1</a>.</p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-intindbuffer-constructor2"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-intindbuffer-constructor2" class="collapse">
                                            <div class="code">
                                                <pre><code>
IndInternal::IndInternal() : IndBuffer('N'){}  //this is a way to call parent non-default constructor <i>IndBuffer::IndBuffer(char blockType)</i>.
					       // 'N' used to denote IndInternal Buffer
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>

				     
<!---------------------------------------------getEntry-------------------------------------------------------------->                                 
                                 <li>
                                    <div class="detail" id="intgetentry">
                                        <h2><i>public:</i> getEntry</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>ptr</td>
                                                    <td>void *</td>
                                                    <td>Pointer of type <a href="#block_structures_internal_entry">struct InternalEntry*</a> to which the contents of the specified entry of internal index block are copied.</td>
                                                </tr>
                                                <tr>
							<td>indexNum</td>
                                                    <td>int</td>
                                                    <td>Index number of entry in internal index block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
                                                    <td>Successful copy of the internal index entry.</td>
                                                </tr>
                                                <tr>
						    <td><a href="/constants.html#constants" target="_blank">E_OUTOFBOUND</a></td>
                                                    <td>indexNum is outside valid range.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Gives the indexNum'th <i>InternalEntry</i> of the IndInternal block.</p>
					<p><b>NOTE:</b> <ul>
					    	    <li>The void pointer is a generic pointer that can be pointed at objects of any data type. 
							    However, because the void pointer does not know what type of object it is pointing to, 
							    the void pointer must first be explicitly cast to another pointer type before it is dereferenced.</li>
						    <li>Higher layer must pass the argument of type <i>struct InternalEntry *</i>.</li>
						    <li>Higher layer must also allocate memory for <i>struct InternalEntry</i> before calling this function.</li>
						    </ul>
					</p>
                                        <h5><a data-toggle="collapse" href="#algo-intgetentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-intgetentry" class="collapse">
                                            <div class="code">
                                                <pre><code>int IndInternal::getEntry(void *ptr, int indexNum){
	
// get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>.
  
// if the indexNum is not in range of 0-(#Entries(in block)-1) return E_OUTOFBOUND

// copy the indexNum'th Internalentry in block to memory ptr(ptr can be type casted appropriately if needed). 
    
// return SUCCESS.
	
}</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                </li>
<!---------------------------------------------setEntry-------------------------------------------------------------->                                  
                                 <li>
                                    <div class="detail" id="intsetentry">
                                        <h2><i>public:</i> setEntry</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>ptr</td>
                                                    <td>void *</td>
                                                    <td>Pointer of type <a href="#block_structures_internal_entry">struct InternalEntry*</a> whose contents are copied to the specified entry of internal index block.</td>
                                                </tr>
                                                <tr>
                                                    <td>indexNum</td>
                                                    <td>int</td>
                                                    <td>Index number of entry in internal index block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
                                                    <td>Successful copy of the internal index entry.</td>
                                                </tr>
                                                <tr>
                                                    <td>E_OUTOFBOUND</td>
                                                    <td>indexNum is outside valid range.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Sets the indexNum'th <i>InternalEntry</i> of the IndInternal block with the <i>InternalEntry</i> sent as argument.</p>
					<p><b>NOTE:</b> <ul>
					    	    <li>The void pointer is a generic pointer that can be pointed at objects of any data type. 
							    However, because the void pointer does not know what type of object it is pointing to, 
							    the void pointer must first be explicitly cast to another pointer type before it is dereferenced.</li>
						    <li>Higher layer must pass the argument of type <i>struct InternalEntry *</i>.</li>
						</ul>
					</p>   
                                        <h5><a data-toggle="collapse" href="#algo-intsetentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-intsetentry" class="collapse">
                                            <div class="code">
                                                <pre><code>int IndInternal::setEntry(void *ptr, int indexNum){
						
// get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>.

// if the indexNum is not in range of 0-(#Entries(in block)-1) return E_OUTOFBOUND

// copy the struct InternalEntry pointed by ptr to indexNum'th entry in block. 

//update dirty bit using setDirtyBit().

//return SUCCESS
	
}</code></pre>
                                            </div>
                                        </div>
                                     </div>
                                 </li>
                             </ul>
                        
                         </div>
 <!----------------------------------------IndInternal ENDS-------------------------------------------------------------------->                     
 
<!----------------------------------------IndLeaf BEGINS-------------------------------------------------------------------->                     
                         <div id="leafbuff_class" class="detail">
                         	<h2>Class IndLeaf</h2>
                             <p>An object of this class will be associated with an <a href="../storage-model.html#leafind_blk">leaf index</a> buffer block. Public Methods of this class deal with the entries of <a href="../storage-model.html#leafind_blk">leaf index</a> (<a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a>) nodes in the buffer. IndLeaf class extends <a href="#indbuff_class">IndBuffer</a> class and overrides the virtual methods in IndBuffer class. The constructor calls the constructor of the parent class by passing the argument.</p>
                             <div class="code">
                                <pre><code>class IndLeaf : public <a href="#indbuffer_class">IndBuffer</a>{
public:
	//methods
	IndLeaf();
	IndLeaf(int blockNum);
	int getEntry(void *ptr, int indexNum) ;
	int setEntry(void *ptr, int indexNum) ;
};</code></pre>
                             </div>
                             <p>The following is the specification of methods of IndLeaf class</p>
                             <ul class="methods">
<!--------------------------------------Constructor 1--------------------------------------------->				     
                                 <li>
                                    <div class="detail" id="leafindbuff_constructor1">
                                        <h2>IndLeaf (Constructor 1)</h2>
                                        <h5>Arguments:</h5> 
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <td>blockNum</td>
                                                <td>int</td>
                                                <td>Block number of the leaf index block.</td>
                                            </table>
                                        </div>
                                        <h5>Return type:</h5>
                                        <p>Nil</p>
                                        <h5>Description:</h5>
					    
                                        <p>Called when the leaf index block already exists on the disk.</p>
					<p><b>NOTE:</b> If a new leaf index block is to be allocated in the disk use <a href="#leafindbuff_constructor2">constructor 2</a>.</p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-leafindbuffer-constructor1"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-leafindbuffer-constructor1" class="collapse">
                                            <div class="code">
                                                <pre><code>IndLeaf::IndLeaf(int blockNum) : IndBuffer(blockNum){} //this is a way to call parent non-default constructor <i>IndBuffer::IndBuffer(int blockNum)</i>.
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>
                                 
                                 
				     
<!--------------------------------------Constructor 2--------------------------------------------->				     
                                 <li>
                                    <div class="detail" id="leafindbuff_constructor2">
                                        <h2>IndLeaf (Constructor 2)</h2>
                                        <h5>Arguments:</h5> 
					<p>Nil</p>
                                        <h5>Return type:</h5>
					<p>Nil</p>
                                        
					<h5>Description:</h5>
                                        <p>Called if a new leaf index block is to be allocated in the disk.</p>
					<p><b>NOTE:</b> If the leaf index block already exists on the disk use <a href="#leafindbuff_constructor1">constructor 1</a>.</p>
					    
                                        <h5><a data-toggle="collapse" href="#algo-leafindbuffer-constructor2"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-leafindbuffer-constructor2" class="collapse">
                                            <div class="code">
                                                <pre><code>
IndLeaf::IndLeaf() : IndBuffer('L'){} // this is a way to call parent non-default constructor <i>IndBuffer::IndBuffer(char blockType)</i>.
				      // 'L' used to denote IndInternal Buffer
</code></pre>
                                            </div>
                                        </div>
                                    </div>
                                 </li>


<!--------------------------------------------getEntry-------------------------------------------------------------->                                 
                                <li>
                                    <div class="detail" id="leafgetentry">
                                        <h2><i>public:</i> getEntry</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-resonsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>ptr</td>
                                                    <td>void *</td>
                                                    <td>Pointer of type <a href="#block_structures_index">struct Index*</a> to which the contents of the specified entry of leaf index block are copied.</td>
                                                </tr>
                                                <tr>
                                                    <td>indexNum</td>
                                                    <td>int</td>
                                                    <td>Index number of entry in leaf index block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
                                                    <td>Successful copy of the leaf index entry.</td>
                                                </tr>
                                                <tr>
						    <td><a href="/constants.html#constants" target="_blank">E_OUTOFBOUND</a></td>
                                                    <td>indexNum is outside valid range.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Gives the indexNum'th <i>Index</i> of the IndLeaf block.</p>
					<p><b>NOTE:</b> <ul>
					    	    <li>The void pointer is a generic pointer that can be pointed at objects of any data type. 
							    However, because the void pointer does not know what type of object it is pointing to, 
							    the void pointer must first be explicitly cast to another pointer type before it is dereferenced.</li>
						    <li>Higher layer must pass the argument of type <i>struct Index*</i>.</li>
						    <li>Higher layer must also allocate memory for <i>struct Index</i> before calling this function.</li>
						    </ul>
					</p>
					
                                        <h5><a data-toggle="collapse" href="#algo-leafgetentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-leafgetentry" class="collapse">
                                            <div class="code">
                                                <pre><code>int IndLeaf::getEntry(void *ptr, int indexNum){
						
// get the starting address of the buffer containing the block using <i>getBufferPtr()</i>.

// if the indexNum is not in range of 0-(#Entries(in block)-1), return E_OUTOFBOUND

// copy the indexNum'th Index entry in block to memory ptr(ptr can be type casted appropriately if needed). 
    
// return SUCCESS.

}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
				     
   <!----------------------------------setEntry------------------------------------------------------------------>                              
                                 <li>
                                    <div class="detail" id="leafsetentry">
                                        <h2><i>public:</i> setEntry (Leaf Index Buffer)</h2>
                                        <h5>Arguments:</h5>
                                        <div class="table-responsive">
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td>ptr</td>
                                                    <td>void *</td>
                                                    <td>Pointer of type <a href="#block_structures_index">struct Index*</a> whose contents are copied to the specified entry of leaf index block.</td>
                                                </tr>
                                                <tr>
                                                    <td>indexNum</td>
                                                    <td>int</td>
                                                    <td>Index number of entry in leaf index block.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <h5>Return value:</h5>
                                        <div class="table-responsive">
                                            
                                            <table class="table table-bordered table-hover">
                                                <tr>
                                                    <td><a href="/constants.html#constants" target="_blank">SUCCESS</a></td>
                                                    <td>Successful copy of the leaf index entry.</td>
                                                </tr>
                                                <tr>
                                                    <td>E_OUTOFBOUND</td>
                                                    <td>indexNum is outside valid range.</td>
                                                </tr>
                                            </table>
                                        </div>

                                        <h5>Description:</h5>
                                        <p>Sets the indexNum'th <i>Index</i> of the IndLeaf block with the <i>Index</i> sent as argument.</p>
					<p><b>NOTE:</b> <ul>
					    	    <li>The void pointer is a generic pointer that can be pointed at objects of any data type. 
							    However, because the void pointer does not know what type of object it is pointing to, 
							    the void pointer must first be explicitly cast to another pointer type before it is dereferenced.</li>
						    <li>Higher layer must pass the argument of type <i>struct Index*</i>.</li>
						</ul>
					</p>
					 
                                        <h5><a data-toggle="collapse" href="#algo-leafsetentry"><span class="fas fa-code"></span>Algorithm:</a></h5>
                                        <div id="algo-leafsetentry" class="collapse">
                                            <div class="code">
                                                <pre><code>int IndLeaf::setEntry(void *ptr, int indexNum){
						
// get the starting address of the buffer containing the block using <i>BlockBuffer.getBufferPtr()</i>.

// if the index_num is not in range of 0-(#Entries(in block)-1), return E_OUTOFBOUND

// copy the struct Index pointed by ptr to indexNum'th entry in block.

//update dirty bit using setDirtyBit().

//return SUCCESS

}</code></pre>
                                            </div>
                                        </div>
                                    </div> 
                                </li>
                         
<!----------------------------------------IndLeaf ENDS-------------------------------------------------------->     
                             </ul>           
                         </div>
                        
                        <div class="detail" id="misc">
                            <h2>Miscellaneous</h2>
                            <p>Here we give the definition of <i>RecId</i> and <i>IndexId</i> structures which will be of use in several modules of NITCbase. Variables of these structures will be declared in <a href="cache.html">Cache layer</a>, <a href="blockaccess.html">Block access layer</a> and <a href="b+tree.html">B+ tree layer</a>. </p>
							<div id = "#recid">
								<h4>RecId</h4>
								<p>Every record in a relation in NITCbase is referenced using an id called <i>recId</i>. <i>recId</i> is a combination of block# and slot# where the record is stored in the disk.</p>
								<div class="code">
									<pre><code>typedef struct recId{
		int block;
		int slot;
	} recId;</code></pre>
								</div>
							</div>
                            <h4>IndexId</h4>
                            <p>An <i><a href="#block_structures">Index</a></i> for a relation is a tuple (Attribute value, block#, slot#), which is present in a <i><a href="../storage-model.html#leafind_blk">Leaf Index Block</a></i> of a <a href="https://en.wikipedia.org/wiki/B-tree">B+ tree</a>. Any such index can be referenced using an id called <i>IndexId</i>. <i>IndexId</i> is a combination of block#(block number of the corresponding leaf index block) and index#(offset of index in that block). </p>
                            <div class="code">
                                <pre><code>typedef struct IndexId{
	int block;
	int index;
} IndexId;</code></pre>
                            </div>
                            
                            <h4>compare()</h4>
                            <p></p>
                            <h5>Arguments:</h5>
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>attr1</td>
                                        <td>union Attribute</td>
                                        <td>first attribute value to be compared</td>
                                    </tr>
                                    <tr>
                                        <td>attr2</td>
                                        <td>union Attribute</td>
                                        <td>second attribute value to be compared</td>
                                    </tr>
                                    <tr>
                                        <td>attrType</td>
                                        <td>int</td>
                                        <td>type of the attribute (INT/FLOAT/STR)</td>
                                    </tr>
                                </table>
                            </div>
                            <h5>Return value:</h5>
                            <div class="table-responsive">

                                <table class="table table-bordered table-hover">
                                    <tr>
                                        <td>Negative integer</td>
                                        <td>Value in attr1 is less than the value in attr2<span style="color: dodgerblue">*</span></td>
                                    </tr>
                                    <tr>
                                        <td>0</td>
                                        <td>Value in attr1 is equal to the value in attr2 *</td>
                                    </tr>
                                    <tr>
                                        <td>Positive integer</td>
                                        <td>Value in attr1 is greater to the value in attr2 *</td>
                                    </tr>
                                </table>
                            </div>
                            <p><span style="color: dodgerblue">*</span> For string types, the comparision is performed with respect to lexicographic order.</p>
                            <h5>Description:</h5>
                            <p>This function compares two attributes of type <i><a href="#block_structures">union Attribute</a></i> depending on the type of the value.</p>
                            <h5><a data-toggle="collapse" href="#algo-compare"><span class="fas fa-code"></span>Algorithm:</a></h5>
                            <div id="algo-compare" class="collapse">
                                <div class="code">
<pre><code>int compare(union Attribute attr1, union Attribute attr2, int AttrType){
    /* if attrType == <a href="/constants.html#constants" target="_blank">STRING</a>
       return strcmp(attr1.strval, attr2.strval); */
    
    /* else if attrType == <a href="/constants.html#constants" target="_blank">INT</a> -1, 0, 1 depending on whether the value attr1.ival
       is less than, equal to or greater than the value attr2.ival */ 
    
    /* else if attrType== <a href="/constants.html#constants" target="_blank">FLOAT</a> return -1, 0, 1 depending on whether the value attr1.fval
       is less than, equal to or greater than the value attr2.fval */ 
}
</code></pre>
                                </div>
                            </div>
                            
                        </div>
                                                
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
        
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

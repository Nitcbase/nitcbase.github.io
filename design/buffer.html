<!DOCTYPE HTML>
<html>

<head>
    <title>Buffer Layer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-sm-2">
                    <nav class="navbar navbar-expand-sm sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            <li> <a href="#layout">Layout</a></li>
                            <li> <a href="#buffer_class">Buffer Class</a></li>
                            <li> <a href="#blkbuff_class">BlockBuffer Class</a></li>
                            <li> <a href="#recbuff_class">RecBuffer Class</a></li>
                            <li> <a href="#intbuff_class">IndInternal Class</a></li>
                            <li> <a href="#leafbuff_class">IndLeaf Class</a></li>
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-sm-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        
                         <div class="pagetitle">
                            <h1>Buffer Layer</h1>
                        </div>
                        
                         <div id="layout" class="detail">
                         	<h2>Layout</h2>
                         	<p>According to Nitcbase Layered architecture, Buffer Layer comes above the Physical Layer, whenever above layers  need to work on disk blocks, Buffer Module loads the Disk block to Buffer, works on it and commits back the block to Disk when needed. Buffer is a run time object which gives disk abstraction to layers above the buffer layer by using the interfaces provided by the Buffer layer. Nitcbase follows object oriented programming(OOP) design for buffer management, following is the class diagram of Buffer Layer.
                         	</p>
                         	<center><img class="img-fluid" src="/img/buffer_class.png"></center>
                         </div>
                         
                         <div id="buffer_class" class="detail">
                         	<h2>Buffer class</h2>
                         	<p> Nitcbase assumes Buffer Class to be a Singleton class, Buffer contains 32 blocks(char: blocks[32][1024]) which are used to load the blocks from disk and also to commit the Buffer blocks back to disk. The metainfo of these buffer blocks is stored at respective index in struct metainfo array. struct metainfo contains following fields in it 1.free: type bool, value true in free indicates fallowing block in buffer is free and false indicates the blockis currently in use i.e loaded with some Disk block, 2.dirty: type bool, value true indicates respective page/block present in buffer is altered after loading from Disk whereas false indicates no change of block after loading it to buffer, 3.page_num:type int, which contains the Disk block number of correspoding buffer block.
                         	</p>
                         	<p>Buffer also stores block_alloc_map(unsigned char: block_alloc_map[DISK_BLOCKS]), an array where i'th element(byte) is 1 if i'th block in disk is allocated/used and 0 if not allocated/free. Layers above Buffer, uses public interfaces/methods of Buffer class to access Disk blocks(or to obtain Disk abstraction).                         
                         	</p>
                         	<h2>Public methods of Buffer class:</h2>
                         	<p>1. class RecBuffer *getFreeRecBlock(): searches for the free disk block using block_alloc_map array, if no free entry is found, returns null, else allocates the corresponding free disk block in block_alloc_map, searches for free Buffer block (out of 32 buffer blocks), if not found, uses buffer replacement policy to get a free buffer block, after getting the free buffer block updates the buffer block with REC type and associate the respective metainfo of buffer block with free:false, dirty:true, block_num: free entry index found from block_alloc_map. creates a RecBuffer object and associate it with corresponding disk block and returns RecBuffer object pointer.
                         	</p>
                         	<p>2. class IndInternal *getFreeIndInternalBlock()/class IndLeaf *getFreeIndLeafBlock(): searches for the free disk block using block_alloc_map array, if no free entry is found returns null,found, uses buffer replacement policy to get a free buffer block, after getting the free buffer block updates the buffer block with INDINT/INDLEAF type and associate the respective metainfo of buffer block with free:false, dirty:true, block_num: free entry index found from block_alloc_map. and creates a IndBuffer object and associate it with corresponding disk block and returns IndInternal/IndLeaf object pointer.
                         	</p>
                         	<p>3.class RecBuffer *getRecBlock(int block_num):Look ups the Buffer for the block with disk #block as block_num, if not present loads it to the buffer from disk( uses buffer replacement if all 32 blocks of buffer are full) and sets the respective meta_info(free:false,dirty:false, block_num: block_num(passed as argument). checks whether the disk block #block_num, corresponds to REC block or not, if it is not returns NULL. creates a RecBuffer object and associate it with corresponding disk block #block_num and returns RecBuffer object pointer, psuedo code for the same can be seen in below snippet.
                         	</p>
                         	<p>4.class IndBuffer *getRIndBlock(int block_num):Look ups the Buffer for the block with #disk_block as block_num, if not present loads it to the buffer from disk( uses buffer replacement if all 32 blocks of buffer are full) and sets the respective meta_info(free:false,dirty:false, block_num: block_num(passed as argument). checks whether the disk block #block_num, corresponds to IND block or not, if not returns NULL. creates an IndInternal/IndLeaf object(based on whether the block is internal or leaf block of b+tree) using IndBuffer class pointer and associate it with corresponding disk block #block_num and returns IndBuffer pointer.
                         	</p>
                         	<p>5.releaseBlock(int block_num): checks if buffer contains the disk block #block_num in one of the 32 blocks of buffer(by looking up the block_no in metainfo array), if present, have to free/release the the respective block from buffer. commits the buffer block back to Disk if respective buffer block is found to be dirty and update the free of respective metainfo array to true.
                         	</p>
                         	<p>6.void deleteBlock(int block_num): checks if buffer contains the disk block #block_num in one of the 32 blocks of buffer. if present, free/release the respective buffer block by using releaseblock(block_num) method. Delete the Disk block by updating #block_num'th entry in block_alloc_map to '0'. 
                         	</p>
                         </div>
                         
                         <div id="blkbuff_class" class="detail">
                         	<h2>Block Buffer Class</h2>
                         	<p>BlockBuffer class is a generic class for block of any type. The public Methods of this class deals with the information like Header info which is generic to all blocks of Disk. RecBuffer and IndBuffer classes will extend from BlockBuffer class.
                         	</p>
                         	<h2>Public methods:</h2>
                         	<p>1.struct HeadInfo getheader(): This method returns the header of buffer block correspoding to BlockBuffer object. gets the header fields from buffer block and puts them in a struct HeadInfo variable and returns the HeadInfo struct.
                         	</p>
                         	<p>2.void setheader(struct HeadInfo head): This method sets the header of buffer block correspoding to BlockBuffer object. updates the buffer blocks header with the fields of struct HeadInfo head.
                         	</p>                       
                         </div>
                         
                         <div id="recbuff_class" class="detail">
                         	<h2>RecBuffer Class</h2>
                         	<p>The object of this class will be associated with the REC type buffer blocks, public Methods of this class deals with the records and slotmap of the buffer block.
                         	</p>
                         	<h2>Public methods:</h2>
                         	<p>1.void getSlotmap(unsigned char *slotmap): slotmap consists of #slots(present in header of corresponding block) number of bytes. This method copies #slots sized slotmap from buffer block to memory pointed by slotmap variable(argument).
                         	</p>
                         	<p>2.void setSlotmap(unsigned char *slotmap): slotmap consists of #slots(present in header of corresponding block) number of bytes. This method copies #slots sized slotmap from memory pointed by slotmap variable(argument) to buffer block's slotmap.
                         	</p>
                         	<p>3.void getRecord(union Attribute *rec,int slot_num): checks whether the slot_num is within #slots entry present in corresponding buffer block, if yes, copies the slot_num'th record from buffer block to memory pointed by rec variable passed as argument.
                         	</p>
                        	<p>4.void setRecord(union Attribute *rec,int slot_num): checks whether the slot_num is within #slots entry present in corresponding buffer block, if yes, copies the record pointed by rec variable(passed as argument) to slot_num'th record of buffer block.
                         	</p>
                         </div>
                         
                         <div id="intbuff_class" class="detail">
                         	<h2>IndInternal Class</h2>
                         	<p>The object of this class will be associated with the INDINT type buffer blocks, public Methods of this class deals with the fields of Internal nodes of b+tree buffer block.
                         	</p>
                         	<h2>Public methods:</h2>
                         	<p>1.struct InternalEntry getInternalEntry(int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, if yes, returns the index_num'th InternalEntry of buffer block.
                         	</p>
                         	<p>2.void setInternalEntry(struct InternalEntry Entry,int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, if yes, updates the index_num'th InternalEntry of buffer block with Entry variable passed as argument.
                         	</p>
                         </div>
                         
                         <div id="leafbuff_class" class="detail">
                         	<h2>IndLeaf Class</h2>
                         	<p>The object of this class will be associated with the INDLEAF type buffer blocks, public Methods of this class deals with the indices of Leaf nodes of b+tree buffer block.
                         	</p>
                         	<h2>Public methods:</h2>
                         	<p>1.struct Index getIndexval(int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, if yes, returns the index_num'th Index of buffer block.
                         	</p>
                         	<p>2.void setIndexval(struct Index IndexEntry,int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, if yes, updates the index_num'th Index of buffer block with IndexEntry variable passed as argument.
                         	</p>
                         </div>
                                                
                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
        
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

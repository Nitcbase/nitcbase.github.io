<!DOCTYPE HTML>
<html>

<head>
    <title>B+ Trees</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">
    <link rel="stylesheet" href="/fontawesome/css/solid.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!--FAVICON-->
    <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
    
    <script type="text/javascript" src="/js/jquery-3.4.0.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js" charset="utf-8"></script>
    <!-- MATHJAX CONFIG AND SCRIPT -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>

</head>
    
    
<body>
    
    <!-- HEADER BEGIN -->
    <header id="header">
        <nav class="navbar navbar-expand-sm fixed-top bg-dark navbar-dark">
            <div class="container">
                <a class="navbar-brand" href="/index.html">
                    <h3><span style="color:DodgerBlue">NITC</span>base</h3>
                </a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse " id="collapsibleNavbar">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/documentation.html">Documentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/roadmap.html">Roadmap</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about.html">About Us</a>
                    </li>
                </ul>
                </div>  
            </div>
        </nav>
    </header>
    <!-- END OF HEADER -->
    
    <!-- CONTENT BEGIN -->
    <div id="content">
        <div class="container-fluid">
            <div class="row">
                
                <!-- SIDEBAR BEGIN -->
                <div class="col-sm-2">
                    <nav class="navbar navbar-expand-sm sticky-top sticky-offset">
                        <button class="navbar-toggler sticky-top sticky-offset" type="button" data-toggle="collapse" data-target="#collapsibleSidebar">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="collapsibleSidebar">
                        <ul class="nav flex-column sidemenu">
                            <li> <a href="#intro">Introduction</a></li>
                            <li> <a href="#bplustree">B+ Tree</a></li>
                            <li> <a href="#insert">Insertion in B+ Tree</a></li>
                          
                        </ul>
                        </div>
                    </nav>
                </div>
                <!-- END OF SIDEBAR -->
                
                <!--MAIN CONTENT START-->
                <div class="col-sm-10">
                    <div id="top">
                        <!-- PAGE STARTS -->
                        <div class="pagetitle">
                            <h1>B+ Trees</h1>
                        </div>
                        
                            
                            <div class="detail" id="intro">
                                <h2>Introduction</h2>
                                
                                <p>B Trees and B+ Trees are m-way search trees confined to rules of insertion and deletion. As you might already know, search becomes very easy in the case of a BST. Locating an entry in a BST accesses very few entries. In this case, the number of entries in each node is restricted to 1. Suppose we can increase this number and can introduce more branches to a single node so that the height of the tree as well as the number of accesses decreases. Such a tree is called the m-way search tree. Suppose you have 2 entries on a single node, then it can have at most 3 child nodes. For Example,
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/1.png"></center>
                                <br><br>
                                <p> This is known as a 3-way search tree with 2 keys.<br>
                                    Since there are no rules for insertion of elements into an m-way search tree, the order of search can expand to n. (Why? Because we do not know if the elements should be inserted in the same node or as a child i.e height of the tree is not defined.) <br> A <b>B tree</b> of<b> order m</b> is a tree which satisfies the following properties:
                                    <ol>
                                        <li>All leaves appear on the same level.</li>
                                        <li>Every node has at most $m$ children. </li>
                                        <li>Every non-leaf node (except root) has at least $\lceil m/2 \rceil$ child nodes.</li>
                                        <li>The root has at least two children if it is not a leaf node.</li>
                                        <li>A non-leaf node with $m$ children contains $m−1$ keys. </li>
                                        <li>A leaf node can store between $\lfloor m/2 \rfloor$ and $m-1$ keys.</li>
                                    </ol>
                                </p>

                                <p>The creation of a B Tree is bottom-up. We can visualize the tree as a multi-level index. The bottom layer can be considered the first level indexing, the layer above it as the second level indexing, so on. A pointer to access each of these entries is stored along with the key of the indices.</p>
                                <p>Consider a table of 9 records that need to be indexed by a particular attribute. Let’s use a left-biased B-tree of order 4. If the attribute values corresponding to each record are inserted, we get a B Tree as shown below. 
                                <br> Entries : <b>15, 20, 22, 30, 33, 45, 10, 53, 28.</b></p>
                                <center><img class="img-fluid" src="../img/bplustree/2.png"></center><br><br>
                                <p>R1-R9 are the data pointers pointing to the records corresponding to each entry on its left.  C1-C3 are the pointers to each of the child nodes from the internal node.<br>
                                Have you noticed, you get a different tree if the order of insertion is changed. 
                                <br>Entries : <b>10, 15, 20, 30, 53, 28, 45, 33, 22.</b></p>
                                <center><img class="img-fluid" src="../img/bplustree/3.png"></center><br><br>
                                <p>As you can see, a data pointer is required at each node. This is a disadvantage because it reduces the number of entries that can be stored in a single node. It also increases the number of levels in the tree thereby increasing the complexity of the search.<i>A solution to this problem is <b>B+ Tree.</b></i>  </p>

                        
                        </div>     
                                 
                        <div id="bplustree" class="detail">
                            <h2>B+ Tree </h2>
                            <p>B+ Tree is an extension of the B Tree. In a B+ Tree, a copy of all the internal nodes is stored in the leaf nodes. When a leaf node is split, a copy of the middle node becomes the new parent node and no data pointer is stored with it. The distinguishing features of a B+ Tree are:
                                <ul>
                                    <li>Every key must appear in a leaf.</li>
                                    <li>The leaf nodes are connected as a linked list. Therefore the leaf nodes can be considered as a dense index.</li>
                                    <li>In B+ Tree, the record pointers are stored in leaf nodes and only the keys are stored in the internal nodes. Whereas, in a B Tree, the keys and record pointers can be stored in internal as well as leaf node.</li>
                                    <li>There can be 2 orders i.e. one for the internal nodes and one for the leaf nodes.</li>
                                </ul>
                            <p> The advantages of a B+ Tree are: </p>
                                <ul>
                                    <li>Search keys can be repeated.</li>
                                    <li>The height of a B+ Tree is less compared to a B Tree.</li>
                                    <li>The number of disk accesses required to fetch any record is equal.</li>
                                    <li>Search is quicker and efficient as the record pointers are stored in leaf nodes only and as a linked list.</li>
                                    <li>Deletion of an entry is less complicated in case of a B+ Tree.</li>
                            </ul>
                            <br>
                            
                            <div class="question">
                                <div class="card">
                                    <div class="card-header">
                                        <a data-toggle="collapse" href="#collapse1">
                                            <b>Q.</b> How many keys can be stored in an internal block of a B Tree and B+ Tree? (Block size: 1024 bytes, Record and Child pointer: 6 bytes). 
                                        </a>
                                    </div>
                                    <div id="collapse1" class="collapse">
                                        <div class="card-body"> 
                                            <p><b>B Tree</b>:- An entry in an internal node can be considered as a set of a key, record pointer, and child pointer. Hence its size is 22 bytes (10+6+6). Hence number of entries is </p>
                                            <b><p> \[ 
                                                       \left \lfloor \frac {1024} {22} \right \rfloor = 46
                                                   \]</p></b>
                                            <p>We also need the remaining bytes to store the last child pointer. Therefore 46 keys in an internal node in a B Tree.</p>
                                            <p><b>B+ Tree</b>:- An entry in an internal node can have a key and a child pointer. This accounts for 16 bytes (10+6). Hence the number of entries is</p>
                                            <b><p> \[
                                                       \left \lfloor \frac {1024} {16} \right \rfloor = 64
                                                \]</p></b>
                                            <p>Since we need to store an extra child pointer too, we can only store 63 keys.</p>
                                            <p>We can see that more keys can be stored in a B+ Tree than in a B Tree. This becomes a huge difference as the block size and record pointer size increases. </p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br>
                           
                            <p>The above B Tree, when converted to a B+ Tree will look something like this. As discussed earlier, each of the entries in the B+ Tree corresponds to a particular attribute value in the relation. </p>
                             <center><img class="img-fluid" src="../img/bplustree/0.png"></center><br><br>

                            </p>
                        </div>

                        <div id="insert" class="detail">
                            <h2>Insertion in a B+ Tree</h2>
                            <p>Creating a B+ Tree and inserting elements into it becomes a simple task if the above-mentioned rules are followed. Let's consider a B+ tree with 4 keys in each internal node and a maximum of 3 keys in a leaf node.<br>
                            Every insertion guarantees that all the entries are in increasing order in the linked list created by the leaf nodes. Similar to a BST, all the entries in the left child of the entries in a node is less than or equal to itself. Likewise, all the entries in the right child of the entries in a node are greater than or equal to it.<br>
                            You can store the copy of internal entry either at the end of its left child or at the beginning of its right child. You may use a left-biased or right-biased B+ Tree i.e, on splitting left child has more entries than a right child in left-biased and vice versa. Make sure you follow the same convention throughout the building of the tree.<br>Let’s understand B+ Tree creation and insertion using the following data.<br>
                            <b>10, 5, 75, 20, 55, 60, 65, 15, 40, 70, 45, 25, 40</b><br><br>
                            For inserting any new entry, first, we traverse the B+ Tree from its root node and find its position in the corresponding leaf node. If the leaf node can accommodate the new entry, it is inserted without much thought.<br>
                            As there is no tree initially, the first entry is inserted into a leaf node. Similarly, the rest of the insertion takes place until the leaf node is full. Maintain a sorted order in every node.<br>
                            Let's insert : <b>10, 5, </b>and <b>75</b>.
                            </p>
                            <center><img class="img-fluid" src="../img/bplustree/4.png"></center><br><br>
                            <p>This leaf node is now the root node of the B+ Tree.<br><br>
                                Next, we must insert <b>20</b> into it. <br>
                                As you can see the leaf node is full. Hence we must create a new leaf node and redistribute the keys. Sort the entries (<b>5, 10, 20, 75</b>) and insert the first half (2 entries i.e <b>5</b> and <b>10</b>) in the previous leaf node followed by the second half (i.e <b>20</b> and <b>75</b>) in the new leaf node. The last entry of the first leaf node is stored in the internal node as the first entry whose left child points to the older leaf node and right child points to the new leaf node. This new internal node is the root node of the tree.<br>
                                You may see that a copy of the internal entries is always stored in the left child of the entry. Thus all the entries on its left child will be less than or equal to it as well as all the entries in its right child will be greater than it.
                            </p>
                            <center><img class="img-fluid" src="../img/bplustree/5.png"></center><br><br>
                            <p>Now let’s insert <b>55</b> into the above created B+ Tree.<br>
                                Always remember that insertion happens only in the leaf nodes. The first step is to find the child node from the root node where the new entry will belong. Here <b>55</b> is greater than <b>10</b>, hence we check the right child of <b>10</b>. Since we have reached the leaf node we can insert the new entry if there is a vacant slot. Here we can insert <b>55</b> between <b>20</b> and <b>75</b>. 
                            </p>
                                <center><img class="img-fluid" src="../img/bplustree/6.png"></center><br><br>
                                <p>The next entry to be inserted is <b>60</b>.<br>
                                    Traversing down the tree from the root node, <b>60</b> is to be inserted in the right child of <b>10</b>  i.e leaf node containing <b>20, 55, 75</b>. The leaf node is full hence we must split this into 2 leaf nodes and update the internal node. As explained above we can see <b>20</b> and <b>55</b> remain in the previous leaf node and <b>60</b> and <b>75</b> are stored in the new leaf node. <b>55</b> becomes the new entry to the internal node.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/7.png"></center><br><br>
                                <p>The next entry to be inserted is <b>65</b>.<br>
                                    Traversing down the tree from the root node, we can infer that <b>65</b> must be inserted in the right child of <b>55</b>. In that leaf node, we have to insert <b>65</b> between <b>60</b> and <b>75</b>. Since the leaf node is not full, we can directly insert <b>65</b>.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/8.png"></center><br><br>
                                <p>The next insertion is of entry <b>15</b>.<br>
                                    At a single glance, we can see a vacant slot after <b>10</b>. But we cannot insert <b>15</b> there. On traversing down the tree from the root node, <b>15</b> must be inserted in the child node between <b>10</b> and <b>55</b>. The said node is not full hence <b>15</b> can be inserted directly.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/9.png"></center><br><br>
                                <p>Next, we have to insert <b>40</b>.<br>
                                    Consider the root node. <b>40</b> must be inserted in the leaf node between <b>10</b> and <b>55</b>. Since this leaf node is full, split the leaf node into 2 and distribute the 4 entries (<b>15, 20, 40, 55</b>) as explained before into these leaf nodes. Now the new entry to the internal node is <b>20</b>. Since the internal node has vacant slots, we can insert <b>20</b> into it. We must make sure that the entries in internal nodes are also in sorted order.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/10.png"></center><br><br>
                                <p>The next entry is <b>70</b>.<br>
                                    The new entry is greater than all the entries in the root node. Hence it must be inserted in the child node after <b>55</b>. But the node is already full. Let’s split this node, insert the entries (<b>60, 65, 70, 75</b>) and update the parent node accordingly.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/11.png"></center><br><br>
                                <p>We must insert <b>45</b> next.<br>
                                    It must be inserted in the child node between <b>20</b> and <b>55</b>. Here we can directly insert <b>45</b>  between <b>40</b> and <b>55</b>.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/12.png"></center><br><br>
                                <p>The new entry is <b>25</b>.<br>At the root node, we infer it must be inserted in the child node between <b>20</b> and <b>55</b>. This leaf node is already full. Hence must be split in order to accommodate <b>25</b>. <b>25</b> and <b>40</b> remain in the leaf node. <b>45</b> and <b>55</b> are written to a new node. <b>40</b> is the new entry to the internal node. Here we can see that the internal node is full. Therefore it must be split into 2 internal nodes and use another internal node as a parent to both these nodes. Sort all the internal node entries along with the new entry (<b>10, 20, 40, 55, 65</b>). Entries before the middle entry (<b>10</b> and <b>20</b>) are written back to the first (old) internal node whereas entries after the middle entry (<b>55</b> and <b>65</b>) are written to the 2nd (new) internal node. Make sure that the pointers to child nodes are updated correspondingly. The middle entry <b>40</b> becomes the first entry to the parent internal node.
                                </p>
                                <center><img class="img-fluid" src="../img/bplustree/13.png"></center><br><br>
                                <p>Next insertion is again <b>40</b>.<br><b>40</b>  is equal to the entry in the root node, and it is greater than all the entries in its left child. Hence we get the required leaf node which contains <b>25</b> and <b>40</b>. Since the leaf node is not full, <b>40</b> is inserted into it.
                                </p>

                                <center><img class="img-fluid" src="../img/bplustree/14.png"></center><br><br>

                            
                        </div>




                        <!-- PAGE ENDS -->
                    </div>
                </div>
                <!-- END OF MAIN CONTENT -->
            </div>
        </div>
        
    </div>
    <!-- END OF CONTENT -->
</body>

</html>

<!DOCTYPE HTML>
<html>

<head>
    <title>Buffer Management</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">
</head>
    
    
<body>
    <div>
    <div class="header" id="top">
        <div id="title">
            <h1> <a href="index.html">Nitcbase</a></h1>
            <!--h3> Database Management System</h3-->
        </div>
        
        <div id="menubar">
            <ul id="menu">
                <li> <a href="index.html">Home</a></li>
                <li> <a href="documentation.html"> Documentation</a></li>
                <li> <a href="roadmap.html">Roadmap</a></li>
            </ul>
        </div>
    </div>
    </div>
    
    <div id="content">
        <div class="sidemenu">
            <ul>
                <li> <a href="#BufferClass">Buffer class</a></li>
                <li> <a href="#BlockBuffer_cls">BlockBuffer class</a></li>
                <li> <a href="#RecBlk_cls">RecBuffer class</a></li>
                <li> <a href="#IndInternal_cls">IndInternal class</a></li>
                <li> <a href="#IndLeaf_cls">IndLeaf class</a></li>
            </ul>
        </div>
        
        <div id="main-content">
            <div class="pagetitle"><h1>Buffer Management</h1></div>
            <!--div class="detail" id="intro">
                <p></p>
            </div-->
            <div class="detail" id="BufferclsDiagram">
                <p>According to Nitcbase Layered architecture, Buffer Layer comes above the Physical Layer,Buffer is a run time object which gives 
                    Disk abstraction to layers above the buffer layer by using the interfaces provided by the Buffer layer.
                    Nitcbase follows object oriented programming(OOP) design for buffer management, following is the class diagram of Buffer Layer
                </p>
                    <center><img src="img/buffer_class.png"></center>
            </div>

            <div class="detail" id="BufferClass">
                
                <h2>Buffer class</h2>
                Nitcbase assumes Buffer Class to be a Singleton class, Buffer contains 32 blocks(char: blocks[32][1024]) which are used to load the blocks 
                from disk and also to commit the Buffer blocks back to disk.
                metainfo of these buffer blocks is stored at respective index in struct metainfo array. struct metainfo contains 
                fallowing fields in it 1.free: type bool, value true in free indicates fallowing block in buffer is free and false indicates the block
                is currently in use i.e loaded with some Disk block, 2.dirty: type bool, value true indicates respective page/block present in buffer is altered 
                after loading from Disk whereas false indicates no change of block after loading it to buffer, 3.page_num:type int, which contains the Disk block 
                number of correspoding buffer block.
                <br><br>
                buffer also stores block_alloc_map(unsigned char: block_alloc_map[DISK_BLOCKS]), an array where i'th element(byte) is 1 if i'th block in disk 
                is allocated/used and 0 if not allocated/free.
                Layers above Buffer, uses public interfaces/methods of Buffer class to access Disk blocks(or Disk abstraction).
                
                    
                <br>

                <h2>Public methods of Buffer class:</h2>
                
                1. class RecBuffer *getFreeRecBlock(): searches for the free disk block using block_alloc_map array, if no free entry is found, returns null,
                else allocates the corresponding free disk block in block_alloc_map, searches for free Buffer block (out of 32 buffer blocks), if not 
                found, uses buffer replacement policy to get a free buffer block, after getting the free buffer block updates the buffer block with REC type
                and associate the respective metainfo of buffer block with free:false, dirty:true, block_num: free entry index found from block_alloc_map.
                creates a RecBuffer object and associate it with corresponding disk block and returns RecBuffer object pointer.
                <br><br>
                2. class IndInternal *getFreeIndInternalBlock()/class IndLeaf *getFreeIndLeafBlock(): searches for the free disk block using block_alloc_map array, 
                if no free entry is found returns null,found, uses buffer replacement policy to get a free buffer block, after getting the free buffer block 
                updates the buffer block with INDINT/INDLEAF type
                and associate the respective metainfo of buffer block with free:false, dirty:true, block_num: free entry index found from block_alloc_map.
                and creates a IndBuffer object and associate it with corresponding disk block and returns IndInternal/IndLeaf object pointer.

                <br><br>
                3.class RecBuffer *getRecBlock(int block_num):Look ups the Buffer for the block with disk #block as block_num, if not present loads it to the buffer
                from disk( uses buffer replacement if all 32 blocks of buffer are full) and sets the respective meta_info(free:false,dirty:false,
                    block_num: block_num(passed as argument)).
                checks whether the disk block #block_num, corresponds to REC block or not, if it is not returns NULL. creates a RecBuffer object and associate
                it with corresponding disk block #block_num and returns RecBuffer object pointer, psuedo code for the same can be seen in below snippet.

                <br><br>
                4.class IndBuffer *getRIndBlock(int block_num):Look ups the Buffer for the block with #disk_block as block_num, if not present loads it to the buffer
                from disk( uses buffer replacement if all 32 blocks of buffer are full) and sets the respective meta_info(free:false,dirty:false,
                    block_num: block_num(passed as argument)).
                checks whether the disk block #block_num, corresponds to IND block or not, if not returns NULL. creates an IndInternal/IndLeaf object(based on 
                whether the block is internal or leaf block of b+tree) using IndBuffer class pointer and associate
                it with corresponding disk block #block_num and returns IndBuffer pointer.

                <br><br>
                5.releaseBlock(int block_num): checks if buffer contains the disk block #block_num in one of the 32 blocks of buffer(by looking up
                the block_no in metainfo array), if present, have to free/release the the respective block from buffer. commits the buffer block back to Disk
                if respective buffer block is found to be dirty and update the free of respective metainfo array to true. 

                <br><br>
                6.void deleteBlock(int block_num): checks if buffer contains the disk block #block_num in one of the 32 blocks of buffer. if present,
                free/release the respective buffer block by using releaseblock(block_num) method. Delete the Disk block by updating #block_num'th entry
                in block_alloc_map to '0'. 
                
                <br><br>
                
            </div>
            
            <div class="detail" id="#BlockBuffer_cls">
                <h2>Public methods of BlockBuffer class:</h2>
                1.struct HeadInfo getheader(): This method returns the header of buffer block correspoding to BlockBuffer object. gets the header 
                fields from buffer block and puts them in a struct HeadInfo variable and returns the HeadInfo struct.
                    
                <br><br>
                2.void setheader(struct HeadInfo head): This method sets the header of buffer block correspoding to BlockBuffer object. updates 
                the buffer blocks header with the fields of struct HeadInfo head.
                
            </div>

            <div class="detail" id="RecBlk_cls">
                
                <h2>Public methods of RecBuffer class</h2>
                1.void getSlotmap(unsigned char *slotmap): slotmap consists of #slots(present in header of corresponding block) number of bytes. This method
                copies #slots sized slotmap from buffer block to memory pointed by slotmap variable(argument).
                
                <br><br>

                2.void setSlotmap(unsigned char *slotmap): slotmap consists of #slots(present in header of corresponding block) number of bytes. This method
                copies #slots sized slotmap from memory pointed by slotmap variable(argument) to buffer block's slotmap.

                <br><br>

                3.void getRecord(union Attribute *rec,int slot_num): checks whether the slot_num is within #slots entry present in corresponding buffer block, 
                if yes, copies the slot_num'th record from buffer block to memory pointed by rec variable passed as argument.

                <br><br>

                4.void setRecord(union Attribute *rec,int slot_num): checks whether the slot_num is within #slots entry present in corresponding buffer block, 
                if yes, copies the record pointed by rec variable(passed as argument) to slot_num'th record of buffer block.
                <br><br>

                
            </div>
            
            
            <div class="detail" id="IndInternal_cls">
                <h2>Public methods of IndInternal class:</h2>
                1.struct InternalEntry getInternalEntry(int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, 
                if yes, returns the index_num'th InternalEntry of buffer block.
                <br><br>
                2.void setInternalEntry(struct InternalEntry Entry,int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, 
                if yes, updates the index_num'th InternalEntry of buffer block with Entry variable passed as argument.
                
            </div>

            <div class="detail" id="IndLeaf_cls">
                <h2>Public methods of IndLeaf class:</h2>
                1.struct Index getIndexval(int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block,
                if yes, returns the index_num'th Index of buffer block.
                <br><br>
                2.void setIndexval(struct Index IndexEntry,int index_num): checks whether the index_num is within #Entries entry present in corresponding buffer block, 
                if yes, updates the index_num'th Index of buffer block with IndexEntry variable passed as argument.
            </div>
        </div>
    </div>
</body>

</html>